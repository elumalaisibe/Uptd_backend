/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["../chunks/_rollupPluginBabelHelpers","../chunks/tslib.es6","../core/arrayUtils","../core/lang","../core/accessorSupport/decorators/property","../core/accessorSupport/ensureType","../core/accessorSupport/decorators/subclass","../core/accessorSupport/decorators/writer","./Extent","./Geometry","./Point","./SpatialReference","./support/centroid","./support/contains","./support/coordsUtils","./support/extentUtils","./support/intersectsBase","./support/webMercatorUtils","./support/zmUtils"],(function(t,e,n,r,i,s,o,a,l,c,u,h,p,f,g,y,m,d,R){"use strict";var _;function x(t){return!Array.isArray(t[0])}let w=_=function(e){function i(...t){var n;return(n=e.call(this,...t)||this).rings=[],n.type="polygon",n}t._inherits(i,e),i.fromExtent=function(t){const e=t.clone().normalize(),n=t.spatialReference;let r=!1,i=!1;for(const o of e)o.hasZ&&(r=!0),o.hasM&&(i=!0);const s={rings:e.map((t=>{const e=[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]];if(r&&t.hasZ){const n=t.zmin+.5*(t.zmax-t.zmin);for(let t=0;t<e.length;t++)e[t].push(n)}if(i&&t.hasM){const n=t.mmin+.5*(t.mmax-t.mmin);for(let t=0;t<e.length;t++)e[t].push(n)}return e})),spatialReference:n};return r&&(s.hasZ=!0),i&&(s.hasM=!0),new _(s)};var s=i.prototype;return s.normalizeCtorArgs=function(t,e){let n,r,i=null,s=null;return t&&!Array.isArray(t)?(i=t.rings??null,e||(t.spatialReference?e=t.spatialReference:t.rings||(e=t)),n=t.hasZ,r=t.hasM):i=t,i=i||[],e=e||h.WGS84,i.length&&i[0]&&null!=i[0][0]&&"number"==typeof i[0][0]&&(i=[i]),s=i[0]&&i[0][0],s&&(void 0===n&&void 0===r?(n=s.length>2,r=s.length>3):void 0===n?n=r?s.length>3:s.length>2:void 0===r&&(r=n?s.length>3:s.length>2)),{rings:i,spatialReference:e,hasZ:n,hasM:r}},s.writeRings=function(t,e){e.rings=r.clone(this.rings)},s.addRing=function(t){if(!t)return;const e=this.rings,n=e.length;if(x(t)){const r=[];for(let e=0,n=t.length;e<n;e++)r[e]=t[e].toArray();e[n]=r}else e[n]=t.concat();return this.notifyChange("rings"),this},s.clone=function(){const t=new _;return t.spatialReference=this.spatialReference,t.rings=r.clone(this.rings),t.hasZ=this.hasZ,t.hasM=this.hasM,t},s.equals=function(t){if(this===t)return!0;if(null==t)return!1;const e=this.spatialReference,r=t.spatialReference;if(null!=e!=(null!=r))return!1;if(null!=e&&null!=r&&!e.equals(r))return!1;if(this.rings.length!==t.rings.length)return!1;const i=([t,e,n,r],[i,s,o,a])=>t===i&&e===s&&(null==n&&null==o||n===o)&&(null==r&&null==a||r===a);for(let s=0;s<this.rings.length;s++){const e=this.rings[s],r=t.rings[s];if(!n.equals(e,r,i))return!1}return!0},s.contains=function(t){if(!t)return!1;const e=d.project(t,this.spatialReference);return f.polygonContainsPoint(this,null!=e?e:t)},s.isClockwise=function(t){let e;return e=x(t)?t.map((t=>this.hasZ?this.hasM?[t.x,t.y,t.z,t.m]:[t.x,t.y,t.z]:[t.x,t.y])):t,g.isClockwise(e,this.hasM,this.hasZ)},s.getPoint=function(t,e){if(!this._validateInputs(t,e))return null;const n=this.rings[t][e],r=this.hasZ,i=this.hasM;return r&&!i?new u(n[0],n[1],n[2],void 0,this.spatialReference):i&&!r?new u(n[0],n[1],void 0,n[2],this.spatialReference):r&&i?new u(n[0],n[1],n[2],n[3],this.spatialReference):new u(n[0],n[1],this.spatialReference)},s.insertPoint=function(t,e,n){return this._validateInputs(t,e,!0)?(R.updateSupportFromPoint(this,n),Array.isArray(n)||(n=n.toArray()),this.rings[t].splice(e,0,n),this.notifyChange("rings"),this):this},s.removePoint=function(t,e){if(!this._validateInputs(t,e))return null;const n=new u(this.rings[t].splice(e,1)[0],this.spatialReference);return this.notifyChange("rings"),n},s.removeRing=function(t){if(!this._validateInputs(t,null))return null;const e=this.rings.splice(t,1)[0],n=this.spatialReference,r=e.map((t=>new u(t,n)));return this.notifyChange("rings"),r},s.setPoint=function(t,e,n){return this._validateInputs(t,e)?(R.updateSupportFromPoint(this,n),Array.isArray(n)||(n=n.toArray()),this.rings[t][e]=n,this.notifyChange("rings"),this):this},s._validateInputs=function(t,e,n=!1){if(null==t||t<0||t>=this.rings.length)return!1;if(null!=e){const r=this.rings[t];if(n&&(e<0||e>r.length))return!1;if(!n&&(e<0||e>=r.length))return!1}return!0},s.toJSON=function(t){return this.write({},t)},t._createClass(i,[{key:"cache",get:function(){return this.commitProperty("rings"),this.commitProperty("hasZ"),this.commitProperty("hasM"),this.commitProperty("spatialReference"),{}}},{key:"centroid",get:function(){const t=p.polygonCentroid(this);if(!t||isNaN(t[0])||isNaN(t[1])||this.hasZ&&isNaN(t[2]))return null;const e=new u;return e.x=t[0],e.y=t[1],e.spatialReference=this.spatialReference,this.hasZ&&(e.z=t[2]),e}},{key:"extent",get:function(){const{spatialReference:t}=this,e=y.getPolygonExtent(this);if(!e)return null;const n=new l(e);return n.spatialReference=t,n}},{key:"isSelfIntersecting",get:function(){return m.isSelfIntersecting(this.rings)}}]),i}(c);e.__decorate([i.property({readOnly:!0})],w.prototype,"cache",null),e.__decorate([i.property({readOnly:!0})],w.prototype,"centroid",null),e.__decorate([i.property({readOnly:!0})],w.prototype,"extent",null),e.__decorate([i.property({readOnly:!0})],w.prototype,"isSelfIntersecting",null),e.__decorate([i.property({type:[[[Number]]],json:{write:{isRequired:!0}}})],w.prototype,"rings",void 0),e.__decorate([a.writer("rings")],w.prototype,"writeRings",null),w=_=e.__decorate([o.subclass("esri.geometry.Polygon")],w),w.prototype.toJSON.isDefaultToJSON=!0;return w}));
