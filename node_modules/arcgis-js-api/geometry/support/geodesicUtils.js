/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["exports","../../chunks/_rollupPluginBabelHelpers","../../geometry","../../core/Error","../../core/unitUtils","./geodesicConstants","./spatialReferenceUtils","../Polyline","../Polygon","../Point","../SpatialReference"],(function(e,t,n,i,s,a,o,r,c,l,h){"use strict";function u(e){if(!e)return null;if(o.isGeographic(e)&&e.wkid){const t=a.spheroids[e.wkid];if(t)return t}if(e.wkt){const t=p(e.wkt);if(t)return t}return null}function p(e){const t=a.WKT_SPHEROID_REGEX.exec(e);if(!t||2!==t.length)return null;const n=t[1].split(",");if(!n||n.length<3)return null;const i=parseFloat(n[1]),s=parseFloat(n[2]);if(isNaN(i)||isNaN(s))return null;return{a:i,f:0===s?0:1/s}}function f(e){const t=u(e??h.WGS84);if(d(t))return t;const n=t.a*(1-t.f);return Object.assign(t,{b:n,eSq:1-(n/t.a)**2,radius:(2*t.a+n)/3,densificationRatio:1e4/((2*t.a+n)/3)})}function d(e){return null!=e&&"b"in e&&"eSq"in e&&"radius"in e}function g(e){return null!=e&&e<0?e+360:e}function m(e,t,n){const{a:i,eSq:s}=f(n),o=Math.sqrt(s),r=Math.sin(t[1]*a.toRadians),c=i*t[0]*a.toRadians;let l;if(s>0){l=i*((1-s)*(r/(1-s*(r*r))-1/(2*o)*Math.log((1-o*r)/(1+o*r))))*.5}else l=i*r;return e[0]=c,e[1]=l,e}function M(e){return null!==u(e)}function w(e,t="square-meters"){if(e.some((e=>!M(e.spatialReference))))throw new i("geodesic-areas:invalid-spatial-reference","the input geometries spatial reference is not supported");const n=[];for(let i=0;i<e.length;i++){const t=e[i],s=t.spatialReference,{radius:a,densificationRatio:o}=f(s),r=a*o;n.push(y(t,r))}const a=[],o=[0,0],r=[0,0];for(let i=0;i<n.length;i++){const{rings:e,spatialReference:c}=n[i];let l=0;for(let t=0;t<e.length;t++){const n=e[t];m(o,n[0],c),m(r,n[n.length-1],c);let i=r[0]*o[1]-o[0]*r[1];for(let e=0;e<n.length-1;e++)m(o,n[e+1],c),m(r,n[e],c),i+=r[0]*o[1]-o[0]*r[1];l+=i}l=s.convertUnit(l,"square-meters",t),a.push(l/-2)}return a}function R(e,t="meters"){if(!e)throw new i("geodesic-lengths:invalid-geometries","the input geometries type is not supported");const n=e.some((e=>!M(e.spatialReference)));if(n)throw new i("geodesic-lengths:invalid-spatial-reference","the input geometries spatial reference is not supported");const a=[];for(let i=0;i<e.length;i++){const n=e[i],{spatialReference:o}=n,r="polyline"===n.type?n.paths:n.rings;let c=0;for(let e=0;e<r.length;e++){const t=r[e];let n=0;for(let e=1;e<t.length;e++){const i=t[e-1][0],s=t[e][0],a=t[e-1][1],r=t[e][1];if(a!==r||i!==s){const e=new v;z(e,[i,a],[s,r],o),n+=e.distance}}c+=n}c=s.convertUnit(c,"meters",t),a.push(c)}return a}function y(e,t){if("polyline"!==e.type&&"polygon"!==e.type)throw new i("geodesic-densify:invalid-geometry","the input geometry is neither polyline nor polygon");const{spatialReference:n}=e;if(!M(n))throw new i("geodesic-densify:invalid-spatial-reference","the input geometry spatial reference is not supported");const s="polyline"===e.type?e.paths:e.rings,a=[],o=[0,0],l=new v;for(const i of s){const e=[];a.push(e),e.push([i[0][0],i[0][1]]);let s,r,c=i[0][0],h=i[0][1];for(let a=0;a<i.length-1;a++){if(s=i[a+1][0],r=i[a+1][1],c===s&&h===r)continue;const u=[c,h];z(l,[c,h],[s,r],n);const{azimuth:p,distance:f}=l,d=f/t;if(d>1){for(let i=1;i<=d-1;i++){b(o,u,p,i*t,n),e.push(o.slice(0))}b(o,u,p,(f+Math.floor(d-1)*t)/2,n),e.push(o.slice(0))}b(o,u,p,f,n),e.push(o.slice(0)),c=o[0],h=o[1]}}return"polyline"===e.type?new r({paths:a,spatialReference:n}):new c({rings:a,spatialReference:n})}let v=t._createClass((function(e=0,t=void 0,n=void 0){this.distance=e,this.azimuth=t,this.reverseAzimuth=n}));function b(e,t,n,i,s){const o=t[0],r=t[1],c=o*a.toRadians,l=r*a.toRadians,h=(n??0)*a.toRadians,{a:u,b:p,f:d}=f(s),g=Math.sin(h),m=Math.cos(h),M=(1-d)*Math.tan(l),w=1/Math.sqrt(1+M*M),R=M*w,y=Math.atan2(M,m),v=w*g,b=v*v,z=1-b,S=z*(u*u-p*p)/(p*p),q=1+S/16384*(4096+S*(S*(320-175*S)-768)),x=S/1024*(256+S*(S*(74-47*S)-128));let A,P,G,N,k=i/(p*q),U=2*Math.PI;for(;Math.abs(k-U)>1e-12;)G=Math.cos(2*y+k),A=Math.sin(k),P=Math.cos(k),N=x*A*(G+x/4*(P*(2*G*G-1)-x/6*G*(4*A*A-3)*(4*G*G-3))),U=k,k=i/(p*q)+N;const D=R*A-w*P*m,E=Math.atan2(R*P+w*A*m,(1-d)*Math.sqrt(b+D*D)),_=d/16*z*(4+d*(4-3*z)),F=Math.atan2(A*g,w*P-R*A*m)-(1-_)*d*v*(k+_*A*(G+_*P*(2*G*G-1))),I=E/a.toRadians,O=(c+F)/a.toRadians;return e[0]=O,e[1]=I,e}function z(e,t,n,i){const s=t[0]*a.toRadians,o=t[1]*a.toRadians,r=n[0]*a.toRadians,c=n[1]*a.toRadians,{a:l,b:h,f:u,radius:p}=f(i),d=r-s,g=Math.atan((1-u)*Math.tan(o)),m=Math.atan((1-u)*Math.tan(c)),M=Math.sin(g),w=Math.cos(g),R=Math.sin(m),y=Math.cos(m);let v,b,z,S,q,x,A,P,G,N,k=1e3,U=d;do{if(A=Math.sin(U),P=Math.cos(U),z=Math.sqrt(y*A*(y*A)+(w*R-M*y*P)*(w*R-M*y*P)),0===z)return e.distance=0,e.azimuth=void 0,e.reverseAzimuth=void 0,e;q=M*R+w*y*P,x=Math.atan2(z,q),G=w*y*A/z,b=1-G*G,S=q-2*M*R/b,isNaN(S)&&(S=0),N=u/16*b*(4+u*(4-3*b)),v=U,U=d+(1-N)*u*G*(x+N*z*(S+N*q*(2*S*S-1)))}while(Math.abs(U-v)>1e-12&&--k>0);if(0===k){const t=p,n=Math.acos(Math.sin(o)*Math.sin(c)+Math.cos(o)*Math.cos(c)*Math.cos(r-s))*t,i=r-s,l=Math.sin(i)*Math.cos(c),h=Math.cos(o)*Math.sin(c)-Math.sin(o)*Math.cos(c)*Math.cos(i),u=Math.atan2(l,h);return e.azimuth=u/a.toRadians,e.distance=n,e.reverseAzimuth=void 0,e}const D=b*(l*l-h*h)/(h*h),E=D/1024*(256+D*(D*(74-47*D)-128)),_=h*(1+D/16384*(4096+D*(D*(320-175*D)-768)))*(x-E*z*(S+E/4*(q*(2*S*S-1)-E/6*S*(4*z*z-3)*(4*S*S-3)))),F=Math.atan2(y*Math.sin(U),w*R-M*y*Math.cos(U)),I=Math.atan2(w*Math.sin(U),w*R*Math.cos(U)-M*y);return e.azimuth=F/a.toRadians,e.distance=_,e.reverseAzimuth=I/a.toRadians,e}function S(e,t,n="meters"){if(!e||!t)throw new i("geodesic-distance:missing-parameters","one or both input parameters are missing");if(!e.spatialReference||!t.spatialReference)throw new i("geodesic-distance:invalid-parameters","one or both input points do not have a spatial reference");if(!o.equals(e.spatialReference,t.spatialReference))throw new i("geodesic-distance:invalid-parameters","spatial references of input parameters do not match");const{spatialReference:a}=e;if(!M(a))throw new i("geodesic-distance:not-supported","input geometry spatial reference is not supported");if(e.x===t.x&&e.y===t.y)return new v(0,0,0);const r=new v;return z(r,[e.x,e.y],[t.x,t.y],a),r.distance=s.convertUnit(r.distance,"meters",n),r.azimuth=g(r.azimuth),r.reverseAzimuth=g(r.reverseAzimuth),r}function q(e,t,n){if(!e||null==t||null==n)throw new i("point-from-distance:missing-parameters","one or more input parameters are missing or undefined");if(n<0||n>360)throw new i("point-from-distance:-of-bounds","azimuth is restricted to angles between, and including, 0° to 360° degrees");if(!e.spatialReference)throw new i("point-from-distance:missing-spatial-reference","the input point must have a spatial reference");const{spatialReference:s}=e;if(!M(s))throw new i("geodesic-distance:not-supported","input geometry spatial reference is not supported");const a=[0,0];return b(a,[e.x,e.y],n,t,s),new l({x:a[0],y:a[1],spatialReference:s})}e.InverseGeodeticSolverResult=v,e.directGeodeticSolver=b,e.geodesicAreas=w,e.geodesicDensify=y,e.geodesicDistance=S,e.geodesicLengths=R,e.inverseGeodeticSolver=z,e.isSupported=M,e.pointFromDistance=q,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
