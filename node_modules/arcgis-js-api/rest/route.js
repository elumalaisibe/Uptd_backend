/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["exports","../request","../geometry/support/normalizeUtils","./networkService","./utils","./route/utils","./support/FeatureSet","./support/RouteSolveResult"],(function(e,r,t,s,o,a,n,i){"use strict";function u(e){return e instanceof n}async function c(e,n,i){const c=[],f=[],p={},y={},d=o.parseUrl(e),{path:m}=d;u(n.stops)&&s.collectGeometries(n.stops.features,f,"stops.features",p),u(n.pointBarriers)&&s.collectGeometries(n.pointBarriers.features,f,"pointBarriers.features",p),u(n.polylineBarriers)&&s.collectGeometries(n.polylineBarriers.features,f,"polylineBarriers.features",p),u(n.polygonBarriers)&&s.collectGeometries(n.polygonBarriers.features,f,"polygonBarriers.features",p);const g=await t.normalizeCentralMeridian(f);for(const r in p){const e=p[r];c.push(r),y[r]=g.slice(e[0],e[1])}if(s.isInputGeometryZAware(y,c)){let e=null;try{e=await s.fetchServiceDescription(m,n.apiKey,i)}catch{}e&&!e.hasZ&&s.dropZValuesOffInputGeometry(y,c)}for(const r in y)y[r].forEach(((e,t)=>{n.get(r)[t].geometry=e}));const h={...i,query:{...d.query,...a.routeParametersToQueryParameters(n),f:"json"}},v=m.endsWith("/solve")?m:`${m}/solve`,{data:R}=await r(v,h);return l(R)}function l(e){const{barriers:r,directionLines:t,directionPoints:s,directions:o,messages:a,polygonBarriers:n,polylineBarriers:u,routes:c,stops:l,traversedEdges:f,traversedJunctions:p,traversedTurns:y}=e,d=e=>{const r=g.find((r=>r.routeName===e));if(null!=r)return r;const t={routeId:g.length+1,routeName:e};return g.push(t),t},m=e=>{const r=g.find((r=>r.routeId===e));if(null!=r)return r;const t={routeId:e,routeName:null};return g.push(t),t},g=[];c?.features.forEach(((e,r)=>{e.geometry.spatialReference=c.spatialReference??void 0;const t=e.attributes.Name,s=r+1;g.push({routeId:s,routeName:t,route:e})})),o?.forEach((e=>{const{routeName:r}=e;d(r).directions=e}));const h=(l?.features.every((e=>null==e.attributes.RouteName))??!1)&&g.length>0?g[0].routeName:null;return l?.features.forEach((e=>{var r;e.geometry&&((r=e.geometry).spatialReference??(r.spatialReference=l.spatialReference??void 0));const t=h??e.attributes.RouteName,s=d(t);s.stops??(s.stops=[]),s.stops.push(e)})),t?.features.forEach((e=>{const r=e.attributes.RouteID,s=m(r),{geometryType:o,spatialReference:a}=t;s.directionLines??(s.directionLines={features:[],geometryType:o,spatialReference:a}),s.directionLines.features.push(e)})),s?.features.forEach((e=>{const r=e.attributes.RouteID,t=m(r),{geometryType:o,spatialReference:a}=s;t.directionPoints??(t.directionPoints={features:[],geometryType:o,spatialReference:a}),t.directionPoints.features.push(e)})),f?.features.forEach((e=>{const r=e.attributes.RouteID,t=m(r),{geometryType:s,spatialReference:o}=f;t.traversedEdges??(t.traversedEdges={features:[],geometryType:s,spatialReference:o}),t.traversedEdges.features.push(e)})),p?.features.forEach((e=>{const r=e.attributes.RouteID,t=m(r),{geometryType:s,spatialReference:o}=p;t.traversedJunctions??(t.traversedJunctions={features:[],geometryType:s,spatialReference:o}),t.traversedJunctions.features.push(e)})),y?.features.forEach((e=>{const r=e.attributes.RouteID,t=m(r);t.traversedTurns??(t.traversedTurns={features:[]}),t.traversedTurns.features.push(e)})),i.fromJSON({routeResults:g,barriers:r,polygonBarriers:n,polylineBarriers:u,messages:a})}e.solve=c,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
