/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["../../chunks/_rollupPluginBabelHelpers","../../chunks/tslib.es6","../../Graphic","../../core/Error","../../core/handleUtils","../../core/Logger","../../core/maybe","../../core/promiseUtils","../../core/Queue","../../core/reactiveUtils","../../core/accessorSupport/decorators/property","../../core/accessorSupport/ensureType","../../core/arrayUtils","../../core/has","../../core/accessorSupport/decorators/subclass","../../layers/support/editableLayers","../../layers/support/layerUtils","../../views/support/layerViewUtils","./CreateFeaturesWorkflow","./UpdateFeatureWorkflow","./UpdateRecordWorkflow","./UpdateWorkflowData","./Workflow","./workflowUtils","../Feature/support/featureUtils"],(function(e,t,a,o,i,r,n,s,l,d,c,u,p,h,w,f,g,y,k,v,m,b,_,W,C){"use strict";var S;const F="candidate-highlight",U="esri.widgets.Editor.UpdateWorkflow",A=r.getLogger(U);let I=S=function(t){function r(e){var a;return(a=t.call(this,e)||this)._workflowStack=new l((e=>{let t;for(t of e);return t})),a.type="update",a}e._inherits(r,t);var c=r.prototype;return c.back=async function(e=(()=>Promise.resolve(!0))){const{featureFormViewModel:t}=this.data.viewModel;if(null==t.relationshipId)if(this.activeWorkflow){if(this.activeWorkflow.hasPendingEdits){if(!await e())return}this.activeWorkflow.hasPreviousStep?await this.activeWorkflow.previous({cancelCurrentStep:!0}):await this.cancelActiveWorkflow({force:!0})}else this.hasPreviousStep?await this.previous({cancelCurrentStep:!0}):await this.cancel({force:!0});else t.relationshipId=null},c.cancelActiveWorkflow=async function(e){await(this.activeWorkflow?.cancel(e)),await this._popWorkflow()},c.commit=async function(){await this._drainWorkflowStack((e=>e.commit())),await e._get(e._getPrototypeOf(r.prototype),"commit",this).call(this)},r.create=function(e,t,a){const o=new S({data:new b({applyEditsCallback:a,viewModel:e}),onCommit:async()=>{}});return o._set("steps",this._createWorkflowSteps(o,t)),o},c.save=async function(){this.nestedWorkflowCount>1?(await(this.activeWorkflow?.commit()),await this._popWorkflow()):await this.commit()},c.startCreatingRelatedRecord=async function(e){try{const t=await this._createNestedCreateFeaturesWorkflow(e);await this._pushWorkflow(t)}catch(t){throw new o("editor:unable-to-start-creating","Could not begin updating the provided feature or table record.",{error:t})}},c.startUpdating=async function(e){try{const t=await this._createNestedUpdateWorkflow(e);await this._pushWorkflow(t)}catch(t){throw new o("editor:unable-to-start-updating","Could not begin updating the provided feature or table record.",{error:t})}},c.deleteActiveFeature=async function(){const{activeWorkflow:e}=this;if(!e)throw new o("editor:nothing-to-delete","There is no feature to delete");E(e)?await e.deleteAndCommit():await e.cancel(),1===this.nestedWorkflowCount?await this.reset():await this._popWorkflow()},c.cancelAll=async function(){await this._drainWorkflowStack((e=>e.cancel({force:!0})))},c._createNestedCreateFeaturesWorkflow=async function(e){const{relatedLayer:t}=e,{addAttachmentsCallback:i,applyEditsCallback:r,viewModel:n}=this.data;if(!f.isEditableLayer(t))throw new o("editor:unsupported-layer","Editing is not supported on the provided layer");const s=new a({sourceLayer:t,attributes:this._makeRelatedRecordAttributes(e)});return k.create({addAttachmentsCallback:i,applyEditsCallback:r,creationInfo:{layer:t,initialFeature:s,maxFeatures:1},startAt:"creating-features",viewModel:n})},c._createNestedUpdateWorkflow=async function(e){const t=g.isTable(e.sourceLayer)?m.UpdateRecordWorkflow:v.UpdateFeatureWorkflow,{applyEditsCallback:a,viewModel:o}=this.data,i=await t.create({feature:e,viewModel:o,applyEdits:a});return await d.whenOnce((()=>!i.updating)),i},c._drainWorkflowStack=async function(e){const t=this._workflowStack,a=[];for(;t.length>0;){const o=t.pop(),i=e(o).then((()=>o.destroy()));this.updatingHandles.addPromise(i),a.push(i)}await Promise.all(a)},c._highlight=function(e){this._removeHighlight();const t=this.data.viewModel.view;if(!t||!e)return;const a=e&&t.allLayerViews.items.find((({layer:t})=>t===e.layer||"subtype-sublayer"===e.layer?.type&&e.layer?.parent===t));y.highlightsSupported(a)&&this.handles.add(a.highlight(e),F)},c._makeRelatedRecordAttributes=function(e){const{parentFeature:t,relatedLayer:a,relationshipId:o}=e;if(!C.isGraphicForRelatableFeatureSupportedLayer(t))return;const i=a.relationships?.find((e=>e.id===o));if(!i)return void M("relationship-not-found","Could not begin creating a related record because the relationship specified could not be found on the destination layer.");if("origin"===i.role)return void M("unsupported-role","Creating new related records in the 'origin' table of a relationship is not yet supported");const r=t.sourceLayer;i.relatedTableId!==r.layerId&&M("invalid-argument-combination","The given parent feature does not belong to the relationship designated by the given relationship ID.");const n=r.relationships?.find((e=>e.id===o));if(!n)return void M("relationship-not-found","Could not begin creating a related record because the relationship specified could not be found on the origin layer.");const s=t.getAttribute(n.keyField);return s||M("no-key-on-origin-feature","The given parent feature does not have a value for the relationship's origin primary key field."),{[i.keyField]:s}},c._popWorkflow=async function(){this._workflowStack.pop()?.destroy();const e=await this._reconcileWorkflowStack();if(e.failureCount>0)throw new o("editor:next-workflow-failed","Popped the top workflow, but the next workflow in the stack failed to activate",e)},c._pushWorkflow=async function(e){const t=this._workflowRequiresSketchViewModel(e);this.activeWorkflow?.exit({removeSketchHandles:t}),await e.start(),this._workflowStack.push(e);const a=await this._reconcileWorkflowStack();if(a.failureCount>0)throw new o("editor:failed-to-start-updating-feature","Failed to enter the provided workflow.",a)},c._reconcileWorkflowStack=async function(){const e=this._workflowStack;try{const t=e.peek();return await(t?.enter()),{activeWorkflow:t,failureCount:0}}catch(t){e.pop().destroy();const{activeWorkflow:a,failureCount:o}=await this._reconcileWorkflowStack();return{activeWorkflow:a,failureCount:o+1}}},c._removeHighlight=function(){this.handles.remove(F)},c._workflowRequiresSketchViewModel=function(e){const{type:t}=e;return"update-features"===t||"create-features"===t&&!g.isTable(e.data.creationInfo?.layer)},r._createWorkflowSteps=function(e,t="awaiting-feature-to-update"){const{data:a,handles:r}=e,l={"awaiting-feature-to-update":()=>({id:"awaiting-feature-to-update",async setUp(){const{spinnerViewModel:t}=a.viewModel,o=a.viewModel.view;let l=null;r.add(i.makeHandle((()=>{l=n.abortMaybe(l)})),this.id),a.rootFeature=null,a.candidates=[];const d=o.on("immediate-click",(async i=>{t.location=i.mapPoint,t.visible=!0,l?.abort();const{editableItems:r}=a.viewModel;l=new AbortController;const n=await new Promise(((e,t)=>{s.onAbort(l?.signal,(()=>t(s.createAbortError()))),e(W.fetchCandidates(r,o,i,l?.signal))}));s.throwIfAborted(l),a.candidates=n.reduce(((e,t)=>t.error?e:[...e,...t.value]),[]),t.visible=1===a.candidates.length,0!==a.candidates.length&&(1===a.candidates.length?(a.rootFeature=a.candidates[0],e.go("editing-existing-feature").catch((()=>{})).then((()=>t.visible=!1))):e.next())}));o.focus(),r.add(d,this.id)},async tearDown(){r.remove(this.id)}}),"awaiting-update-feature-candidate":()=>({id:"awaiting-update-feature-candidate",async setUp(){a.rootFeature=null,r.add([d.watch((()=>a.rootFeature),(t=>e._highlight(t)),d.sync),i.makeHandle((()=>e._removeHighlight()))],this.id)},async tearDown(){r.remove(this.id)}}),"editing-existing-feature":()=>({id:"editing-existing-feature",async setUp(){const{rootFeature:t,viewModel:n}=e.data;if(!t)throw new o("editor:no-feature-specified","Cannot setup the 'updating-existing-feature' step until the root feature is defined");await e.startUpdating(t),n.spinnerViewModel.visible=!1;const l=s.debounce((async()=>{await d.whenOnce((()=>!e.updating)),e.previous()})),{featureFormViewModel:c}=a.viewModel,u=c.relatedRecordCallbacks;c.relatedRecordCallbacks={addRelatedRecord:async t=>{await e.startCreatingRelatedRecord(t),c.relationshipId=null},editRelatedRecord:async({relatedFeature:t})=>{await e.startUpdating(t),c.relationshipId=null},showAllRelatedRecords:e=>c.relationshipId=e.relationshipId},r.add([i.makeHandle((()=>c.relatedRecordCallbacks=u)),d.watch((()=>e.nestedWorkflowCount),((e,t)=>{0===e&&0!==t&&l()}),d.sync)],this.id)},async tearDown(){await e.cancelAll(),r.remove(this.id)}}),"adding-attachment":()=>({id:"adding-attachment",parent:"editing-existing-feature",async setUp(){},async tearDown(){a.viewModel.attachmentsViewModel.mode="view"}}),"editing-attachment":()=>({id:"editing-attachment",parent:"editing-existing-feature",async setUp(){},async tearDown(){a.viewModel.attachmentsViewModel.mode="view"}})};return W.createWorkflowSteps(["awaiting-feature-to-update","awaiting-update-feature-candidate","editing-existing-feature","adding-attachment","editing-attachment"],t,l)},e._createClass(r,[{key:"activeEditableItem",get:function(){const{activeWorkflow:e}=this;return E(e)?e.data.editableItem:void 0}},{key:"activeWorkflow",get:function(){return this._workflowStack.last()}},{key:"nestedWorkflowCount",get:function(){return this._workflowStack.length}},{key:"shouldShowAttachments",get:function(){return!!this.activeEditableItem?.attachmentsOnUpdateEnabled}},{key:"shouldAllowAttachmentEditing",get:function(){return!!this.activeEditableItem?.supports.includes("update")}},{key:"hasPendingEdits",get:function(){return Array.from(this._workflowStack).some((e=>e.hasPendingEdits))}},{key:"helpMessage",get:function(){return"awaiting-feature-to-update"===this.stepId?"select":void 0}},{key:"reliesOnOwnerAdminPrivileges",get:function(){return this.activeWorkflow?.reliesOnOwnerAdminPrivileges??!1}},{key:"hasInvalidFormTemplate",get:function(){return!!this.activeEditableItem?.hasInvalidFormTemplate}},{key:"hasUnsupportedFields",get:function(){return!!this.activeEditableItem?.hasUnsupportedFields}},{key:"updating",get:function(){return this.updatingHandles.updating}}]),r}(_);t.__decorate([c.property()],I.prototype,"activeEditableItem",null),t.__decorate([c.property()],I.prototype,"activeWorkflow",null),t.__decorate([c.property()],I.prototype,"nestedWorkflowCount",null),t.__decorate([c.property()],I.prototype,"shouldShowAttachments",null),t.__decorate([c.property()],I.prototype,"shouldAllowAttachmentEditing",null),t.__decorate([c.property()],I.prototype,"hasPendingEdits",null),t.__decorate([c.property()],I.prototype,"helpMessage",null),t.__decorate([c.property()],I.prototype,"reliesOnOwnerAdminPrivileges",null),t.__decorate([c.property()],I.prototype,"hasInvalidFormTemplate",null),t.__decorate([c.property()],I.prototype,"hasUnsupportedFields",null),t.__decorate([c.property()],I.prototype,"updating",null),I=S=t.__decorate([w.subclass(U)],I);const M=(e,t)=>A.warn(`editor:${e}`,t,"The create operation will be allowed to proceed, but the resulting feature may not be related to the given parent feature."),E=e=>!!e&&/update-/.test(e.type);return I}));
