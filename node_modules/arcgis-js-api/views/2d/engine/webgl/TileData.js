/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../core/arrayUtils","./enums","./MemoryRequirements","./TileBufferData","./TileDisplayData","./Utils","./WGLDisplayRecord","./cpuMapped/DisplayRecordReader","./mesh/VertexBuffer","./mesh/VertexVector","./util/Writer"],(function(e,t,r,n,s,i,o,a,f,l,u,c,d){"use strict";const D=new s,p=new s,y=5;function h(e,t){const r={};for(const n in e){const s={data:a.allocateTypedArrayBuffer(t,e[n]),stride:e[n]};r[n]=s}return r}function m(e){return[e.fill||{},e.line||{},e.icon||{},e.text||{},e.label||{}]}function x(e){const t=[[],[],[],[],[]],r=e;for(const n of r)for(const e of n.displayRecords)t[e.geometryType].push(e);return t}let B=function(){function e(){this.tileDisplayData=null,this.tileBufferData=null}var s=e.prototype;return s.reshuffle=function(){if(D.reset(),!this.tileDisplayData)return;const t=x(this.tileDisplayData.displayObjects);for(const e of t)for(const t of e)t&&D.needMore(t.geometryType,t.meshData?t.meshData.vertexCount:t.vertexCount,t.meshData?t.meshData.indexData.length:t.indexCount);const n=t.length,s=new i;for(let i=0;i<n;++i){s.geometries[i].indexBuffer=new Uint32Array(Math.round(r.ReallocGrowthFactor*D.indicesFor(i)));const t=[],n=this.tileBufferData?.geometries[i].vertexBuffer;if(!n)continue;for(const e in n)t.push(n[e].stride);const o=e._computeVertexAlignment(t),f=Math.round(r.ReallocGrowthFactor*D.verticesFor(i)),l=e._align(f,o);for(const e in n){const t=n[e].stride;s.geometries[i].vertexBuffer[e]={stride:t,data:a.allocateTypedArrayBuffer(l,t)}}}p.reset(),this.tileDisplayData.displayList?.clear();for(let e=0;e<n;++e){const r=t[e];for(const t of r){if(t.meshData)t.writeMeshDataToBuffers(p.verticesFor(e),s.geometries[e].vertexBuffer,p.indicesFor(e),s.geometries[e].indexBuffer),t.meshData=null;else{const r=this.tileBufferData?.geometries[e];if(r){const n=r.vertexBuffer,i=r.indexBuffer,o=s.geometries[e].vertexBuffer,f=s.geometries[e].indexBuffer,l=p.verticesFor(e),u=p.indicesFor(e);a.copyMeshData(l,u,o,f,t,n,i),t.vertexFrom=l,t.indexFrom=u}}p.needMore(e,t.vertexCount,t.indexCount)}}const{displayList:o,displayObjects:f}=this.tileDisplayData;if(o)for(const e of f)o.addToList(e.displayRecords);this.tileBufferData=s},s.getStrides=function(){const e=[],t=this.tileBufferData?.geometries;if(!t)return e;for(let r=0;r<t.length;++r){const n=t[r];e[r]={};for(const t in n.vertexBuffer)e[r][t]=n.vertexBuffer[t].stride}return e},s.clone=function(){const t=new e;return t.tileBufferData=this.tileBufferData?.clone()??null,t.tileDisplayData=this.tileDisplayData?.clone()??null,t},s._guessSize=function(){const e=this.tileDisplayData?.displayObjects??[],t=Math.min(e.length,4),r=12,n=40;let s=0;for(let i=0;i<t;i++)s=Math.max(s,e[i].displayRecords.length);return 2*(e.length*r+e.length*s*n)},s.serialize=function(){const e=this.tileBufferData.serialize(),t=this.tileBufferData.getBuffers(),r=this.tileDisplayData.serialize(new d(Int32Array,this._guessSize())).buffer();return t.push(r),{result:{displayData:r,bufferData:e},transferList:t}},e.fromVertexData=function(t,r){const s={},i=new Map;for(const e of r)i.set(e.id,e);return a.forEachGeometryType((e=>{const r=t.data[e];if(null!=r){const t=l.DisplayRecordReader.from(r.records).getCursor();for(;t.next();){const r=t.id,n=t.materialKey,s=t.indexFrom,o=t.indexCount,a=t.vertexFrom,l=t.vertexCount,u=i.get(r),c=new f(r,e,n);c.indexFrom=s,c.indexCount=o,c.vertexFrom=a,c.vertexCount=l,u.displayRecords.push(c)}s[e]=u.VertexBuffers.fromVertexData(r,e)}else s[e]=new c.VertexVectors(e,0,n.WGLSymbologyType.DEFAULT).intoBuffers()})),e.fromMeshData({displayObjects:r,vertexBuffersMap:s})},e.fromMeshData=function(t){const r=new e,n=new o,s=new i;n.displayObjects=t.displayObjects;for(const e in t.vertexBuffersMap){const r=e,n=t.vertexBuffersMap[r];s.geometries[r].indexBuffer=n.indexBuffer,s.geometries[r].vertexBuffer=n.namedBuffers}return r.tileDisplayData=n,r.tileBufferData=s,r},e.bind=function(t,r){const n=new e;return n.tileDisplayData=t,n.tileBufferData=r,n},e.create=function(t,r){const n=new e;n.tileDisplayData=new o,n.tileDisplayData.displayObjects=t;const s=[0,0,0,0,0],a=[0,0,0,0,0],l=[[],[],[],[],[]];for(const e of t)for(const t of e.displayRecords)l[t.geometryType].push(t),s[t.geometryType]+=t.meshData.vertexCount,a[t.geometryType]+=t.meshData.indexData.length;const u=new i,c=m(r);for(let e=0;e<y;e++){const t=new Uint32Array(a[e]),r=h(c[e],s[e]);f.writeAllMeshDataToBuffers(l[e],r,t),u.geometries[e]={indexBuffer:t,vertexBuffer:r}}return n.tileBufferData=u,n},e._align=function(e,t){const r=e%t;return 0===r?e:e+(t-r)},e._computeVertexAlignment=function(e){let t=!1,r=!1;for(const n of e)n%4==2?t=!0:n%4!=0&&(r=!0);return r?4:t?2:1},t._createClass(e)}();e.TileData=B,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
