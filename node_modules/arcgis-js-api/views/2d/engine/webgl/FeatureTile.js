/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../core/CircularArray","../../../../core/has","../../../../chunks/mat2df32","./enums","./Utils","./WGLTile","./collisions/MetricReader","./cpuMapped/Geometry"],(function(e,t,r,s,n,i,a,d,h,u){"use strict";const c=50,o=4,l=100;let _=0,f=function(e){function d(t,s,i,a,d,h){var u;return(u=e.call(this,t,s,i,a)||this).instanceId=_++,u.patchCount=0,u._renderState={current:{geometry:new Map,metrics:null},next:null,swap:!1,swapFrames:0,locked:!1},u._patches=new r(l),u._bufferPatches=new r(l),u._lastCommitTime=0,u.transforms.labelMat2d=n.create(),u._store=d,u._requestLabelUpdate=h,u}t._inherits(d,e);var f=d.prototype;return f.destroy=function(){t._get(t._getPrototypeOf(d.prototype),"destroy",this).call(this),this._renderState.current.geometry.forEach((e=>e.destroy())),null!=this._renderState.next&&this._renderState.next.geometry.forEach((e=>e.destroy())),this._renderState.current=null,this._renderState.next=null},f.getGeometry=function(e){return this._renderState.current.geometry.get(e)},f.patch=function(e,t){this.patchCount++,e.clear&&this._patches.size>=c&&this._dropPatches();const r=e,s=r.addOrUpdate&&this.key.id!==r.addOrUpdate.tileKeyOrigin;t&&s?this._bufferPatches.enqueue(r):(r.sort=r.sort&&!t,this._patches.enqueue(r)),this.requestRender()},f.commit=function(e){if(this._lastCommitTime!==e.time){this._lastCommitTime=e.time;for(let e=0;e<o;e++)this._updateMesh(),this.isReady&&this._updateBufferMesh();this._renderState.swap&&(this._swapRenderStates(),this.requestRender())}},f.lock=function(){this._renderState.locked=!0},f.unlock=function(){this._renderState.locked=!1,this._flushUpdates(),this._swap()},f._swapRenderStates=function(){if(this._renderState.next){if(this._renderState.locked)return this._renderState.swap=!0,void this.requestRender();this._renderState.swap=!0,this._swap()}},f._swap=function(){this._renderState.swap&&(this._renderState.swap=!1,null!=this._renderState.next&&(this._renderState.current.geometry.forEach((e=>e.destroy())),this._renderState.current=this._renderState.next,this._renderState.next=null,this._requestLabelUpdate()))},f._flushUpdates=function(){let e=this._patches.maxSize;for(;this._patches.size&&e--;)this._updateMesh(),this._swap()},f._updateBufferMesh=function(){const e=this._bufferPatches.peek();if(null==e||!e.clear||null===this._renderState.next)for(;this._bufferPatches.size;){const e=this._bufferPatches.dequeue();null!=e&&this._patchBuffer(e)}},f._updateMesh=function(){const e=this._patches.dequeue();if(null!=e){if(s("esri-2d-update-debug")){const t=e,r=t.addOrUpdate?.tileKeyOrigin,s=this.key.id===r?"SELF":r;let n="";for(let e=0;e<5;e++)n+=t.addOrUpdate?.data[e]?.records?.byteLength?1:0;console.debug(this.key.id,"FeatureTile:patch",`[clear: ${t.clear} origin: ${s}, end:${t.end} data:${n}]`)}!0===e.clear&&(null!=this._renderState.next&&(this._renderState.next.geometry.forEach((e=>e.destroy())),this._renderState.next=null),this._renderState.next={geometry:new Map,metrics:null},s("esri-2d-update-debug")&&console.debug(this.key.id,"FeatureTile:_updateMesh - Creating new renderState")),this.requestRender(),this._patch(e),e.end&&(s("esri-2d-update-debug")&&console.debug(this.key.id,"FeatureTile:_updateMesh - Encountered end message"),this.ready(),this._swapRenderStates())}},f._patch=function(e){a.forEachGeometryType((t=>{this._remove(t,e.remove),this._insert(t,e,!1)}))},f._patchBuffer=function(e){a.forEachGeometryType((t=>{this._insert(t,e,!0)}))},f._insert=function(e,t,r){try{const n=this._renderState.next??this._renderState.current,a=t.addOrUpdate?.data[e],d=n.geometry;if(null==a)return;d.has(e)||(s("esri-2d-update-debug")&&console.debug(this.key.id,`FeatureTile:_insert - Creating geometry buffer ${e}`),d.set(e,new u.Geometry(e,this.stage))),s("esri-2d-update-debug")&&console.debug(this.key.id,`FeatureTile:_insert - Inserting into ${e}, version=${t.addOrUpdate?.version} stride=${a.stride}`),d.get(e).insert(a,t.sort,r),e===i.WGLGeometryType.LABEL&&this._insertLabelMetrics(t.type,a.metrics,t.clear)}catch(n){}},f._insertLabelMetrics=function(e,t,r){const s=this._renderState.next??this._renderState.current;if(null==t)return;const n=h.MetricReader.from(t);if(null!=s.metrics){if("update"===e){const e=n.getCursor();for(;e.next();)s.metrics.delete(e.id)}s.metrics.link(n)}else s.metrics=n},f._remove=function(e,t){const r=(this._renderState.next??this._renderState.current).geometry.get(e);t&&t.length&&r&&(r.remove(t),this._removeLabelMetrics(t))},f._removeLabelMetrics=function(e){const{metrics:t}=this._renderState.next??this._renderState.current;if(null!=t&&e.length)for(const r of e)for(;t.delete(r););},f._dropPatches=function(){const e=new Array;let t=!1;for(;this._patches.size;){const r=this._patches.dequeue();if(null==r)break;if(r.clear){if(t)break;t=!0}e.push(r)}this._patches.clear(),e.forEach((e=>this._patches.enqueue(e)))},t._createClass(d,[{key:"labelMetrics",get:function(){return this._renderState.current.metrics}},{key:"hasData",get:function(){return!!this._renderState.current.geometry.size}},{key:"updateStatus",get:function(){return`renderState:${!!this._renderState.current}, ${!!this._renderState.next}, hasData:${this.hasData}, queue:${this._patches.size}`}}]),d}(d.WGLTile);e.FeatureTile=f,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
