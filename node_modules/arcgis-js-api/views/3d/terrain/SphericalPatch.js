/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["exports","../../../chunks/_rollupPluginBabelHelpers","../../../core/mathUtils","../../../chunks/vec3","../../../chunks/vec3f64","../../../geometry/projection","../../../geometry/support/DoubleArray","../../../geometry/support/frustum","../../../chunks/sphere","./interfaces","./ITile","./PatchGeometryFactory","./terrainUtils","./Tile","./tileUtils"],(function(e,t,i,n,s,o,r,l,a,c,u,h,d,p,f){"use strict";let _=function(e){function _(t,i,n){var s;return(s=e.call(this)||this)._convexHull=new Array(24),s._boundingSphere=a.create(),void 0!==t&&s.init(t,i,n),s}t._inherits(_,e);var x=_.prototype;return x.init=function(e,s,r){t._get(t._getPrototypeOf(_.prototype),"init",this).call(this,e,s,r);const l=this.ellipsoid.radius,a=this.extentInRadians[0],c=this.extentInRadians[1],u=this.extentInRadians[2],h=this.extentInRadians[3],d=e[0],p=i.lerp(c,h,.5),f=i.lerp(a,u,.5),m=0===d?0:Math.min(Math.abs(c),Math.abs(h));this._edgeLen=(u-a)*Math.cos(m)*l,this._edgeLen2=this._edgeLen*this._edgeLen,this._curvatureHeight=l-Math.sqrt(l*l-this._edgeLen2/4),o.lonLatToSphericalPCPF(this.centerAtSeaLevel,f,p,this.ellipsoid.radius),n.normalize(this.up,this.centerAtSeaLevel),this.updateRadiusAndCenter()},x.updateRadiusAndCenter=function(){this._updateBoundingVolumes();const e=this._center;if(0===this.lij[0])n.set(e[p.CenterPosition.MIDDLE],0,0,0),n.set(e[p.CenterPosition.TOP],0,0,0),n.set(e[p.CenterPosition.BOTTOM],0,0,0),e[p.CenterPosition.MIDDLE][3]=this.ellipsoid.radius+this.elevationBounds[1];else{this._updateCenter();const t=e[p.CenterPosition.MIDDLE],i=this.convexHull;let n=0;for(let e=0;e<8;++e)n=Math.max(n,g(t,i,3*e));e[p.CenterPosition.MIDDLE][3]=Math.sqrt(n)}},x._calculateFrustumVisibilityStatus=function(e){if(!l.intersectsSphere(e,this._boundingSphere))return u.TileFrustumVisibility.OUTSIDE;if(this.lij[0]<10)return u.TileFrustumVisibility.INTERSECTS;const t=this.convexHull,i=this.surface.view.state.camera.near;let n=!0;for(let s=0;s<l.NumPlanes;s++){const o=s===l.PlaneIndex.NEAR,r=e[s],a=r[0],c=r[1],h=r[2],d=r[3]-(o?i:0);let p=!1;for(let e=0;e<8;++e){const i=3*e;if(a*t[i]+c*t[i+1]+h*t[i+2]+d<0){if(p=!0,!n)break}else n=!1}if(!p)return u.TileFrustumVisibility.OUTSIDE}return n?u.TileFrustumVisibility.INSIDE:u.TileFrustumVisibility.INTERSECTS},x.computeElevationBounds=function(){t._get(t._getPrototypeOf(_.prototype),"computeElevationBounds",this).call(this),this._updateBoundingVolumes()},x.createGeometry=function(){h.createSphericalGlobePatch(this.renderData,this._getPatchType()),this._updateBoundingVolumes(),this.setMemoryDirty()},x._updateBoundingVolumes=function(){this._updateConvexHull(),this._updateBoundingSphere(),d.ENABLE_TERRAIN_INTERNAL_CHECKS&&this._checkBVs()},x._updateBoundingSphere=function(){const e=this._boundingSphere,t=e,i=this.elevationBounds,s=this.ellipsoid.radius,o=i[1];if(0===this.level)n.set(t,0,0,0),e[3]=s+o;else{const o=this.extentInRadians,r=.5*(o[0]+o[2]),l=o[1],a=o[3];$(v,r,l,s),$(y,r,a,s),n.add(t,v,y);const c=s+.5*(i[0]+i[1]);n.scale(t,t,c/n.len(t));const u=this.convexHull;let h=0;const d=(e,t)=>{const i=e[0]-u[3*t],n=e[1]-u[3*t+1],s=e[2]-u[3*t+2];return Math.sqrt(i*i+n*n+s*s)};for(let e=0;e<8;++e){const i=d(t,e);h=Math.max(h,i)}const p=h;e[3]=p+2}},x._updateConvexHull=function(){const e=this.extentInRadians,t=this.ellipsoid.radius;if(0===this.level)return;const i=this.elevationBounds,o=this._getPatchType(),r=this.surface.isWebMercator,l=r&&o===c.PatchType.HAS_NORTH_POLE,a=r&&o===c.PatchType.HAS_SOUTH_POLE,u=a||l,h=Math.PI/2,p=e[0],f=e[2],_=a?-h:e[1],m=l?h:e[3],g=.5*(p+f),T=i[0],v=t+(u?Math.min(0,T-1):T),y=(e,t,i)=>$(e,t,i,v),x=s.create(),S=s.create(),E=s.create(),P=s.create();y(x,p,_),y(S,p,m),y(E,f,m),y(P,f,_);const M=(e,t)=>{for(let i=0;i<3;++i)this._convexHull[3*t+i]=e[i]};M(x,0),M(S,1),M(E,2),M(P,3);const A=i[1],C=t+(u?Math.max(0,A+1):A),I=s.create(),L=s.create(),R=s.create();$(L,g,m,v),$(R,g,_,v),n.add(I,L,R),n.normalize(I,I);const H=s.create(),B=s.create(),D=(e,t)=>{n.sub(B,e,t),n.normalize(B,B);const i=-n.dot(e,H)/n.dot(B,H);d.internalAssert(i>=0),n.scale(B,B,i),n.add(e,e,B)};if(2**this.lij[0]>2*this.lij[1]){const e=R,t=s.create();n.cross(t,b,e),n.normalize(t,t),n.cross(H,e,t),n.normalize(H,H),d.internalAssert(d.almostEquals(n.dot(H,e)/n.len(e),0)),D(x,S),D(P,E),M(x,0),M(P,3)}else if(2**this.lij[0]!==2*this.lij[1]){const e=L,t=s.create();n.cross(t,b,e),n.normalize(t,t),n.cross(H,t,e),n.normalize(H,H),D(S,x),D(E,P),M(S,1),M(E,2)}const j=(e,t)=>{const i=C/n.dot(t,I);for(let n=0;n<3;++n)this._convexHull[3*e+n]=t[n]*i};j(4,x),j(5,S),j(6,E),j(7,P)},x._getPatchType=function(){const e=this.lij[1],t=0===e,i=e===(1<<this.level)-1;return t?i?c.PatchType.HAS_BOTH_POLES:c.PatchType.HAS_NORTH_POLE:i?c.PatchType.HAS_SOUTH_POLE:c.PatchType.REGULAR},x.intersectsRay=function(e,t,i,n){const s=this._boundingSphere,o=s[3]+i,r=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],l=s[0]-e[0],a=s[1]-e[1],c=s[2]-e[2],u=(l*t[0]+a*t[1]+c*t[2])/r,h=t[0]*u-l,d=t[1]*u-a,p=t[2]*u-c;return h*h+d*d+p*p<o*o},x.getDefaultVerticesPerSide=function(){return this.level<m.length?m[this.level]+1:2},x.updateCornerElevations=function(){h.updateCornerSpherical(this.renderData),this._updateBoundingVolumes()},x.updateEdgeElevations=function(){h.updateEdgesAndCornersSpherical(this.renderData),this._updateBoundingVolumes()},x._checkBVs=function(){if(!d.ENABLE_TERRAIN_INTERNAL_CHECKS)return;if(this.level<=2)return;const e=this._boundingSphere,t=e[3],i=e,o=s.create(),l=this.ellipsoid.radius,a=this.elevationBounds;a[1],a[0];const c=l+a[0],u=1,h=0,_=this._center[p.CenterPosition.MIDDLE][3],m=this.convexHull,g=(e,t)=>{for(let i=0;i<3;++i)e[i]=m[3*t+i]};{const e=s.create(),t=s.create(),i=s.create(),o=s.create(),r=s.create(),l=(s,l,a,c)=>{g(t,s),g(i,l),g(o,a),n.sub(t,t,i),n.sub(o,o,i),n.cross(e,t,o),n.normalize(e,e);const u=n.dot(e,i);g(r,c);const h=n.dot(e,r),p=Math.abs(h-u);d.internalAssert(d.almostEquals(p,0),`Non coplanar ${s},${l},${a},${c} diff = ${p}`)};l(0,1,2,3),l(4,5,6,7),l(0,1,4,5),l(1,2,5,6),l(2,3,6,7),l(3,0,7,4)}const b=r.newDoubleArray(24),v=(e,t,i)=>{const n=4*e;for(let s=0;s<3;++s)b[n+s]=t[s];b[n+3]=i},y=s.create(),x=s.create(),S=s.create(),E=s.create(),P=(e,t,i,s)=>{g(y,t),g(x,i),g(S,s),n.sub(y,y,x),n.normalize(y,y),n.sub(S,S,x),n.normalize(S,S),n.cross(E,y,S),n.normalize(E,E);const o=n.dot(E,x);v(e,E,o)};P(0,0,1,2),P(1,1,0,4),P(2,1,5,2),P(3,3,2,6),P(4,4,0,3),P(5,4,6,5);const M=1,A=(e,t,i,n)=>{const s=4*e;return b[s]*t+b[s+1]*i+b[s+2]*n-b[s+3]},C=(e,t,i,n)=>A(e,t,i,n)>=-M,I=(e,t)=>C(e,t[0],t[1],t[2]),L=2**this.lij[0]>2*this.lij[1],R=(e,n,s)=>Math.sqrt(T(e,n,s,i[0],i[1],i[2]))<t,H=e=>R(e[0],e[1],e[2]),B=(e,t)=>R(e[t],e[t+1],e[t+2]),D=this.extentInRadians,j=.5*(D[0]+D[2]),N=D[1],O=D[3],V=s.create(),F=s.create();$(V,j,O,c),$(F,j,N,c);const z=L?"Upper":"Lower";let k=!0;for(let n=0;n<6;++n){for(let e=0;e<8;++e){const t=3*e,i=C(n,m[t],m[t+1],m[t+2]);k&&(k=i),d.internalAssert(i,`Tile[${this.lij}] Convex hull point ${e} outside of plane ${n}`)}d.internalAssert(I(n,F),`Tile[${this.lij}] (${z}) bottom mid outside of plane ${n}`),d.internalAssert(I(n,V),`Tile[${this.lij}] (${z}) top mid outside of plane ${n}`)}d.internalAssert(k,"Not all convex hull points are inside  convex hull polyhedron"),d.internalAssert(H(F),`Tile[${this.lij}] (${z}) bottom mid outside of bounding sphere`),d.internalAssert(H(V),`Tile[${this.lij}] (${z}) top mid outside of bounding sphere`);for(let n=0;n<8;++n){const e=B(m,3*n);d.internalAssert(e,`Tile[${this.lij}] Convex hull point ${n} outside of bounding sphere`)}for(let n=0;n<6;++n)for(let e=0;e<8;++e){const t=3*e;C(n,m[t],m[t+1],m[t+2])||console.error(`Tile[${this.lij}] Convex hull point ${e} outside of plane ${n}`)}const U=this.extentInRadians,q=Math.max(U[2]-U[0],U[3]-U[1]),w=Math.round(q*l),G=this.renderData;if(!G)return;const{geometry:K,localOrigin:W}=G,J=K.vertexAttributes?.position;if(!J)return;const Q=J.count,X=s.create(),Y=K.numVerticesPerSide-2,Z=Y*Y,ee=G.geometryState.neighborData,te=ee.edgeResolutions.reduce(((e,t)=>e+t+1),0);for(let s=0;s<Q;++s){const e=s<Z,r=!e&&s<Z+te;let c=!1,d=-1;if(r){let e=Z;for(let t=0;t<4;++t){const i=ee.edgeResolutions[t];if(s===e||s===e+i-1){c=!0;break}if(e+=i,s<e){d=t;break}}}const p=r?ee.edgePeerNeighbors[d]:null,m=r&&p&&f.compareTilesByLij(this,p)>0;J.getVec(s,o),n.add(X,o,W);const g=n.len(X)-l;let T=0,$=!1;const b=a[0]-g,v=g-a[1],y=b>u,x=v>u,S=y||x,E=()=>{const t=e?"internal":r&&!c?"edge":c?"corner":"pole";return`Tile[${this.lij}].vertex[${s}]:${t}`+(y?"(below)":x?"(above)":"")+(m?"(Neighbor)":"")},P=n.dist(X,i);if(P>=t+h){const e=P-t;S||(console.error(`${E()} is out of the bounding sphere by ${e.toFixed(0)} / ${t.toFixed(0)}[tol=${h}] h=${g.toFixed(0)} / [${a[0].toFixed(0)}..${a[1].toFixed(0)}] (${(e/t).toFixed(0)})`),$=!0)}for(let i=0;i<6;++i)if(!C(i,X[0],X[1],X[2])){const e=A(i,X[0],X[1],X[2]),n=s%Y,o=(s-n)/Y;0===i&&b||5===i&&v||(console.error(`${E()} (${n},${o})|${Y}] is out of the bounding trapezoid plane ${i} h=${Math.round(g)} / [${Math.round(a[0])}..${Math.round(a[1])}] dist=${Math.round(e)} radii = ${Math.round(t)}/${Math.round(_)}} : maxL = ${w}`),++T)}if($||T>0)break}},t._createClass(_,[{key:"convexHull",get:function(){return this._convexHull}}]),_}(p.Tile);const m=[128,64,64,32,16,8,8,4];function g(e,t,i){return T(e[0],e[1],e[2],t[i],t[i+1],t[i+2])}function T(e,t,i,n,s,o){const r=n-e,l=s-t,a=o-i;return r*r+l*l+a*a}const $=(e,t,i,n)=>{const s=Math.cos(t),o=Math.sin(t),r=Math.cos(i),l=Math.sin(i);e[0]=n*r*s,e[1]=n*r*o,e[2]=n*l},b=[0,0,1],v=s.create(),y=s.create();e.SphericalPatch=_,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
