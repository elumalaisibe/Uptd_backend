/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["exports","../../../core/mathUtils","../../../chunks/vec4","../../../geometry/support/aaBoundingBox","../../../geometry/support/aaBoundingRect","./ElevationData","./interfaces","./ITile","./PatchGeometry","./PatchGeometryLUT","./PatchRenderData","./terrainUtils","./Tile","./tileUtils","../webgl-engine/lib/Normals"],(function(e,t,n,o,s,r,i,a,l,c,u,d,f,m,p){"use strict";const g=65536;function h(e,t){const n=e.tile,{extent:s,extentInRadians:r,surface:a}=n,c=e.localOrigin,u=e.geometryState,f=a.isWebMercator,m=u.numVerticesPerSide,g=m-1,h=(m-2)**2,M=f&&(t===i.PatchType.HAS_SOUTH_POLE||t===i.PatchType.HAS_BOTH_POLES),A=f&&(t===i.PatchType.HAS_NORTH_POLE||t===i.PatchType.HAS_BOTH_POLES),B=6,v=((M?1:0)+(A?1:0))*B*(g+1),S=u.neighborData,b=S.edgeResolutions.reduce(((e,t)=>e+t+1),0),T=h+v+b,R=l.acquireTerrainAttributes(T),N=e.geometry;N.numVerticesPerSide=u.numVerticesPerSide,N.vertexAttributes=R;const I=N.boundingBox;o.empty(I);const P=L(e);F.update(g,r,P),x(e),w(e,h),E(e);const C=[];if((()=>{let e=h+b;const t=c[0],o=c[1],r=c[2],i=n.ellipsoid.radius,a=s[1],u=s[3],d=(n,s)=>{const c=s*m,d=-t,f=-o,h=n*i-r;l.minMaxBoundingBox(d,f,h,I),C.push({connectedRowOffset:c,connectedOuterEdgeOffset:1===n?0:2,rowOffset:e,latitudeResolution:B});const x=y(-1===n?a:u,i),M=n*Math.PI/2-x,A=.99*(1===n?1:-1),E=i+0,v=R.position,S=R.uv0,{typedBuffer:b,typedBufferStride:L}=R.normalCompressed;for(let i=1;i<=B;++i){const n=x+M*(i/B),s=Math.cos(n),a=Math.sin(n);for(let i=0;i<=g;i++){const n=i/g,c=F.sinLonLUT[i],u=F.cosLonLUT[i]*s,d=c*s,f=a,m=u*E-t,h=d*E-o,x=f*E-r;l.minMaxBoundingBox(m,h,x,I),v.setValues(e,m,h,x),l.encodeUVInBuffer(S,e,n,A),p.compressNormal(b,e,u,d,f,L),++e}}};M&&d(-1,0),A&&d(1,g)})(),_(N,u.numVerticesPerSide,C,[0,m-1],[0,m-1],u.wireframe),e.intersectionData=null,d.ENABLE_TERRAIN_INTERNAL_CHECKS)for(let o=0;o<4;++o)d.internalAssert(N.outerEdges[o].count===S.edgeResolutions[o]+1)}function x(e){const t=e.tile;if(!t.intersectsClippingArea)return;const n=e.geometryState,o=n.numVerticesPerSide,s=o-2,i=o-1,a=e.geometry,c=a.vertexAttributes,u=c.position,d=c.uv0,{typedBuffer:f,typedBufferStride:m}=c.normalCompressed,g=t.extent,h=g[0],x=g[2],M=g[1],A=g[3],E=t.ellipsoid.radius,B=n.samplerData,v=e.localOrigin,y=v[0],S=v[1],b=v[2],L=u.typedBuffer,T=u.typedBufferStride,R=1/i,N=a.boundingBox;let I=0;if(1<=s){const e=R,t=M*(1-e)+A*e,n=F.sinLatLUT[1],o=F.cosLatLUT[1];for(let i=1;i<=s;i++){const s=i*R,a=h*(1-s)+x*s,c=F.sinLonLUT[i],u=F.cosLonLUT[i],f=E+r.sampleElevation(a,t,B),m=f*u*o-y,p=f*c*o-S,g=f*n-b;l.minMaxBoundingBox(m,p,g,N);const M=(i-1)*T;L[M]=m,L[M+1]=p,L[M+2]=g,l.encodeUVInBuffer(d,i-1,s,e)}}for(let P=1;P<=s;P++){const e=P*R,t=M*(1-e)+A*e,n=F.sinLatLUT[P],o=F.cosLatLUT[P],a=P+1,c=a*R,u=M*(1-c)+A*c,g=F.sinLatLUT[a],v=F.cosLatLUT[a],C=F.sinLonLUT[0],O=F.cosLonLUT[0],V=E+r.sampleElevation(h,t,B);let U=O*o*V-y,D=C*o*V-S,_=n*V-b;const w=I*T;let H=L[w],q=L[w+1],j=L[w+2];for(let A=1;A<=s;A++){const e=A*R,a=h*(1-e)+x*e,C=F.sinLonLUT[A],O=F.cosLonLUT[A];let V=0,w=0,K=0;if(A<s){const e=(I+1)*T;V=L[e],w=L[e+1],K=L[e+2]}else{const e=F.sinLonLUT[i],s=F.cosLonLUT[i],a=E+r.sampleElevation(x,t,B);V=s*o*a-y,w=e*o*a-S,K=n*a-b}const W=U,G=D,k=_;U=H,D=q,_=j,H=V,q=w,j=K;const z=V-W,J=w-G,Q=K-k;let X=0,Y=0,Z=0;if(P>1){const e=(I-s)*T;X=L[e],Y=L[e+1],Z=L[e+2]}else{const e=F.sinLatLUT[0],t=F.cosLatLUT[0],n=E+r.sampleElevation(a,M,B);X=O*t*n-y,Y=C*t*n-S,Z=e*n-b}const $=E+r.sampleElevation(a,u,B),ee=O*v*$-y,te=C*v*$-S,ne=g*$-b;if(P<s){const t=I+s,n=t*T;L[n]=ee,L[n+1]=te,L[n+2]=ne,l.minMaxBoundingBox(ee,te,ne,N),l.encodeUVInBuffer(d,t,e,c)}const oe=X-ee,se=Y-te,re=Z-ne;let ie=O*o,ae=C*o,le=n;le*le<.999&&(ie=Q*se-J*re,ae=z*re-Q*oe,le=J*oe-z*se);const ce=1/Math.sqrt(ie*ie+ae*ae+le*le);p.compressNormal(f,I,ie*ce,ae*ce,le*ce,m),++I}}}function M(e){e.tile.intersectsClippingArea&&(E(e),K(e))}function A(e){e.tile.intersectsClippingArea&&(v(e),B(e,!0),K(e))}function E(e){e.tile.intersectsClippingArea&&(v(e),B(e))}function B(e,n=!1){const o=e.geometryState,s=e.geometry,i=o.neighborData,a=e.tile,c=a.level,f=a.extent,p=a.ellipsoid.radius,g=a.extentInRadians,h=g[0],x=g[2],M=g[1],A=g[3],E=o.samplerData,B=f[0],v=f[2],y=f[1],S=f[3],b=L(e),T=s.boundingBox,R=e.localOrigin,N=R[0],I=R[1],P=R[2],C=s.vertexAttributes,O=C.position,V=O.typedBuffer,U=O.typedBufferStride,D=C.uv0;for(let L=0;L<4;++L){const o=1===L||3===L,g=i.edgeResolutions[L];d.internalAssert(t.isPowerOfTwo(g));const R=g+1,C=u.neighborTileIfLoadedOrSelf(a,i.edgePeerNeighbors[L]);if(z(a,C,L)){H(e,L,C);continue}const O=null!=C;d.internalAssert(!O||C.level===a.level),d.internalAssert(!O||m.compareTilesByLij(a,C)<=0);const _=C?.renderData,w=_?.geometryState;if(d.ENABLE_TERRAIN_INTERNAL_CHECKS){const e=a.surface;if(!C&&e&&!e.updatingRootTiles){const t=d.neighborEdgeIndices[L],n=a.findNeighborTile(t,(e=>e.isLoaded||e.isLeaf||e.level===a.level));n?n.intersectsClippingArea&&(d.internalAssert(!n.isLoaded),d.internalAssert(!n.isLeaf),d.internalAssert(n.level===c)):d.internalAssert(null==e?.rootTiles||!a.shouldHaveNeighbor(t))}}const q=1===L?f[2]:f[0],j=C?.extent,K=j&&o?1===L?j[0]:j[2]:q,W=0===L?f[3]:f[1],F=1===L?1:0,G=0===L?1:0,k=1===L?x:h,J=0===L?A:M,Q=Math.sin(k),X=Math.cos(k),Y=Math.sin(J),Z=Math.cos(J),$=w?.samplerData,ee=O?(e,t,n)=>.5*(r.sampleElevation(e,t,E)+r.sampleElevation(n,t,$)):(e,t,n)=>r.sampleElevation(e,t,E),te=s.outerEdges[L],ne=n&&R>3?R-3:1,oe=null!=E&&E.some((e=>null!=e)),se=null!=$&&$.some((e=>null!=e)),re=oe||se,ie=1/g,ae=te.index0;d.internalAssert(!j||d.almostEquals(j[2]-j[0],f[2]-f[0]));(()=>{const e=1===L?-1:3===L?1:0,t=0===L?-1:2===L?1:0,n=(f[2]-f[0])*ie,s=e*n,i=t*n,a=o?e*((x-h)*ie):0,c=o?0:t*ie,u=G,d=o?k+a:k,m=o?Math.sin(d):Q,g=o?Math.cos(d):X,M=o?k-a:k,A=o?Math.sin(M):Q,C=o?Math.cos(M):X,_=o?J:b(u+c),w=o?Y:Math.sin(_),H=o?Z:Math.cos(_),j=o?J:b(u-c),z=o?Y:Math.sin(j),oe=o?Z:Math.cos(j);let se=0,le=0,ce=0;{const e=0*ie,t=o?q:B*(1-e)+v*e,n=o?K:t,s=o?y*(1-e)+S*e:W,r=o?k:h*(1-e)+x*e,i=o?Q:Math.sin(r),a=o?X:Math.cos(r),l=o?b(e):J,c=o?Math.sin(l):Y,u=o?Math.cos(l):Z,d=p+ee(t,s,n);se=a*u*d,le=i*u*d,ce=c*d}let ue=0,de=0,fe=0;{const e=1*ie,t=o?q:B*(1-e)+v*e,n=o?K:t,s=o?y*(1-e)+S*e:W,r=o?k:h*(1-e)+x*e,i=o?Q:Math.sin(r),a=o?X:Math.cos(r),l=o?b(e):J,c=o?Math.sin(l):Y,u=o?Math.cos(l):Z,d=p+ee(t,s,n);ue=a*u*d,de=i*u*d,fe=c*d}for(let f=1;f<R-1;f+=ne){let e=0,t=0,n=0;{const s=(f+1)*ie,r=o?q:B*(1-s)+v*s,i=o?K:r,a=o?y*(1-s)+S*s:W,l=o?k:h*(1-s)+x*s,c=o?Q:Math.sin(l),u=o?X:Math.cos(l),d=o?b(s):J,m=o?Math.sin(d):Y,g=o?Math.cos(d):Z,M=p+ee(r,a,i);e=u*g*M,t=c*g*M,n=m*M}const a=e,c=t,u=n,d=ue,M=de,R=fe;ue=a,de=c,fe=u;{const e=ae+f,t=e*U,n=d-N,s=M-I,r=R-P;V[t]=n,V[t+1]=s,V[t+2]=r,l.minMaxBoundingBox(n,s,r,T);const i=f*ie,a=o?F:i,c=o?i:G;l.encodeUVInBuffer(D,e,a,c)}const _=se,j=le,ne=ce;se=d,le=M,ce=R;const me=d,pe=M,ge=R,he=1/Math.sqrt(me*me+pe*pe+ge*ge),xe=ge*he;let Me=0,Ae=0,Ee=0;if(re&&xe*xe<.999){let e=0,t=0,n=0;{const o=0===L?-1:1;e=o*(a-_),t=o*(c-j),n=o*(u-ne)}{const a=f*ie,l=o?q:B*(1-a)+v*a,c=o?K:l,u=o?y*(1-a)+S*a:W,d=o?k:h*(1-a)+x*a,M=o?Q:Math.sin(d),T=o?X:Math.cos(d),R=o?b(a):J,N=o?Math.sin(R):Y,I=o?Math.cos(R):Z;let P=me,V=pe,U=ge;if(O){const e=c-s,t=u-i,n=p+r.sampleElevation(e,t,$),a=o?I:oe;P=(o?C:T)*a*n,V=(o?A:M)*a*n,U=(o?N:z)*n}{const a=l+s,c=u+i,d=p+r.sampleElevation(a,c,E),f=o?I:H,h=(o?g:T)*f*d,x=(o?m:M)*f*d,A=(o?N:w)*d;O||(P=2*me-h,V=2*pe-x,U=2*ge-A);const B=3===L?-1:1,v=B*(P-h),y=B*(V-x),S=B*(U-A);Me=n*y-t*S,Ae=e*S-n*v,Ee=t*v-e*y;const b=1/Math.sqrt(Me*Me+Ae*Ae+Ee*Ee);Me*=b,Ae*=b,Ee*=b}}}else Me=me*he,Ae=pe*he,Ee=ge*he;te.setNormalFromValues(f,Me,Ae,Ee)}})()}}function v(e){q(e)}function y(e,t){return Math.PI/2-2*Math.atan(Math.exp(-e/t))}function S(e,t,n,o){return y(e*(1-o)+t*o,n)}function b(e,t,n){return e*(1-n)+t*n}function L(e){const t=e.tile;if(t.surface.isWebMercator){const e=t.extent,n=t.ellipsoid.radius;return t=>S(e[1],e[3],n,t)}const n=t.extentInRadians;return e=>b(n[1],n[3],e)}function T(e,t){const s=e.tile.extent,r=e.geometryState,i=s[0],a=s[1],c=s[2]-i,u=s[3]-a,d=r.clippingArea,f=null!=d?Math.max(0,(d[0]-i)/c):0,m=null!=d?Math.max(0,(d[1]-a)/u):0,p=null!=d?Math.min(1,(d[2]-i)/c):1,g=null!=d?Math.min(1,(d[3]-a)/u):1,h=r.numVerticesPerSide,x=(h-2)**2,M=x+r.neighborData.edgeResolutions.reduce(((e,t)=>e+t+1),0),A=l.acquireTerrainAttributes(M),E=e.geometry,B=E.boundingBox;o.empty(B),E.numVerticesPerSide=r.numVerticesPerSide,E.vertexAttributes=A,n.set(E.uvRange,f,m,p,g),R(e),w(e,x),P(e),_(E,r.numVerticesPerSide,[],[0,h-1],[0,h-1],r.wireframe),e.intersectionData=null}function R(e){const n=e.tile;if(!n.intersectsClippingArea)return;const o=n.surface,s=e.geometryState,i=s.samplerData,a=e.localOrigin,c=o.isWebMercatorOnPlateeCarree,u=s.clippingArea,d=null!=u?u:G,f=n.extent,m=f[0],g=f[1],h=f[2],x=f[3],M=Math.max(m,d[0]),A=Math.min(h,d[2]),E=Math.max(g,d[1]),B=Math.min(x,d[3]),v=n.ellipsoid.radius,y=n.horizontalScale,S=s.numVerticesPerSide,b=S-1,L=S-2,T=e.geometry,R=T.vertexAttributes,N=R.position,I=R.uv0,{typedBuffer:P,typedBufferStride:C}=R.normalCompressed,O=T.uvRange,V=O[0],U=O[1],D=O[2],_=O[3],w=T.boundingBox,H=a[0],q=a[1],j=a[2],K=N.typedBuffer,W=N.typedBufferStride;let F=0;const k=t.clamp(g,E,B),z=c?(Math.PI/2-2*Math.atan(Math.exp(-k/v)))*v:k*y,J=1/b,Q=t.clamp(g*(1-J)+x*J,E,B);let X=z,Y=c?(Math.PI/2-2*Math.atan(Math.exp(-Q/v)))*v:Q*y;for(let G=1;G<=L;G++){const e=G/b,n=t.clamp(g*(1-e)+x*e,E,B),o=t.clamp(e,U,_),s=Y,a=(G-1)/b,u=t.clamp(g*(1-a)+x*a,E,B),d=X,f=(G+1)/b,S=t.clamp(g*(1-f)+x*f,E,B),T=c?(Math.PI/2-2*Math.atan(Math.exp(-S/v)))*v:S*y,R=t.clamp(f,U,_);X=Y,Y=T;const N=t.clamp(m,M,A);let O=N*y,k=r.sampleElevation(N,n,i);const z=1/b,J=t.clamp(z,V,D),Q=t.clamp(m*(1-J)+h*J,M,A);let Z=J,$=Q,ee=Q*y,te=r.sampleElevation(Q,n,i);if(1===G){const e=ee-H,n=X-q,s=te-j,r=0*W;K[r]=e,K[r+1]=n,K[r+2]=s,l.minMaxBoundingBox(e,n,s,w);const i=t.clamp(z,V,D);l.encodeUVInBuffer(I,F,i,o)}for(let c=1;c<=L;c++){const e=ee,a=te,f=(c+1)/b,g=t.clamp(f,V,D),x=t.clamp(m*(1-f)+h*f,M,A),E=$;$=x;{const e=F+1,t=e*W;if(1===G||c===L){const a=x*y,u=r.sampleElevation(x,n,i);if(1===G&&c<L){const n=a-H,r=s-q,i=u-j;K[t]=n,K[t+1]=r,K[t+2]=i,l.minMaxBoundingBox(n,r,i,w),l.encodeUVInBuffer(I,e,g,o)}ee=a,te=u}else ee=K[t]+H,te=K[t+2]+j}const B=ee,v=te,N=O,U=k;O=e,k=a;const _=(F-L)*W,z=1===G?r.sampleElevation(E,u,i):K[_+2]+j,J=r.sampleElevation(E,S,i);if(G<L){const t=F+L,n=t*W,o=e-H,s=T-q,r=J-j;K[n]=o,K[n+1]=s,K[n+2]=r,l.minMaxBoundingBox(o,s,r,w);const i=Z;Z=g,l.encodeUVInBuffer(I,t,i,R)}{const e=B-N,t=d-T,n=t*(v-U),o=e*(z-J),s=-t*e,r=n*n+o*o+s*s;if(0===r)p.compressNormal(P,F,0,0,1,C);else{const e=1/Math.sqrt(r);p.compressNormal(P,F,n*e,o*e,s*e,C)}}++F}}}function N(e,t){e.tile.intersectsClippingArea&&(O(e),C(e,!0),K(e))}function I(e,t){e.tile.intersectsClippingArea&&(P(e),K(e))}function P(e,t){e.tile.intersectsClippingArea&&(O(e),C(e,!1))}function C(e,n){const o=e.geometryState,s=o.neighborData,i=e.tile,a=i.surface,c=i.extent,f=o.clippingArea,p=null!=f?f:G,g=c[0],h=c[2],x=c[1],M=c[3],A=[M>p[3],h>p[2],x<p[1],g<p[0]],E=e.geometry,B=i.horizontalScale,v=D(a.isWebMercatorOnPlateeCarree,i.ellipsoid.radius,B),y=E.boundingBox,S=E.uvRange[0],b=E.uvRange[1],L=E.uvRange[2],T=E.uvRange[3],R=Math.max(g,p[0]),N=Math.min(h,p[2]),I=Math.max(x,p[1]),P=Math.min(M,p[3]),C=e.localOrigin,O=C[0],V=C[1],U=C[2],_=o.samplerData;for(let D=0;D<4;++D){const o=1===D||3===D,c=s.edgeResolutions[D];d.internalAssert(t.isPowerOfTwo(c));const f=c+1,p=A[D],C=u.neighborTileIfLoadedOrSelf(i,s.edgePeerNeighbors[D]);if(!p&&z(i,C,D)){H(e,D,C);continue}const w=null!=C&&!p,q=C?.renderData,j=q?.geometryState;if(d.ENABLE_TERRAIN_INTERNAL_CHECKS&&(d.internalAssert(!w||C.level===i.level),d.internalAssert(!w||m.compareTilesByLij(i,C)<=0),i&&!C&&!a.updatingRootTiles)){const e=d.neighborEdgeIndices[D],t=i.findNeighborTile(e,(e=>e.isLoaded||e.isLeaf||e.level===i.level));a.updatingRootTiles||(t?t.intersectsClippingArea&&(d.internalAssert(!t.isLoaded),d.internalAssert(!t.isLeaf),d.internalAssert(t.level===i.level)):d.internalAssert(null==a?.rootTiles||!i.shouldHaveNeighbor(e)))}const K=t.clamp(1===D?h:g,R,N),W=t.clamp(0===D?M:x,I,P),F=j?.samplerData,G=E.outerEdges[D],k=n&&f>3?f-3:1,J=t.clamp(1===D?1:0,S,L),Q=t.clamp(0===D?1:0,b,T),X=w?(e,t)=>.5*(r.sampleElevation(e,t,F)+r.sampleElevation(e,t,_)):(e,t)=>r.sampleElevation(e,t,_),Y=(h-g)/c,Z=o?1===D?Y:-Y:0,$=o?0:0===D?Y:-Y,ee=-Z,te=-$;let ne=0,oe=0,se=0;{const e=0/c,n=o?K:t.clamp(g*(1-e)+h*e,R,N),s=o?t.clamp(x*(1-e)+M*e,I,P):W,r=X(n,s);ne=n*B,oe=v(s),se=r}let re=0,ie=0,ae=0;{const e=1/c,n=o?K:t.clamp(g*(1-e)+h*e,R,N),s=o?t.clamp(x*(1-e)+M*e,I,P):W,r=X(n,s);re=n*B,ie=v(s),ae=r}for(let e=1;e<f-1;e+=k){const n=e/c,s=re,i=ie,a=ae;{const r=o?J:t.clamp(n,S,L),c=o?t.clamp(n,b,T):Q,u=s-O,d=i-V,f=a-U;l.minMaxBoundingBox(s,d,f,y),G.setVertexFromValuesRawPositionUV(e,u,d,f,r,c)}{const n=(e+1)/c,s=o?K:t.clamp(g*(1-n)+h*n,R,N),r=o?t.clamp(x*(1-n)+M*n,I,P):W,i=X(s,r);re=s*B,ie=v(r),ae=i}const u=re,d=ae,f=ne,m=oe,p=se;ne=s,oe=i,se=a;let A=0,E=0,C=0;if(o){const e=ie-i,o=d-a,l=m-i,c=p-a,u=t.clamp(x*(1-n)+M*n,I,P),f=K+ee,g=u,h=f*B-s,v=r.sampleElevation(f,g,_)-a,y=3===D?-1:1;if(A=y*(-l+e)*v,E=y*h*(-c+o),C=-y*h*(-l+e),w){const t=K+Z,n=u,i=t*B-s;A=(-l+e)*(v-(r.sampleElevation(t,n,F)-a)),E=(h-i)*(-c+o),C=-(h-i)*(-l+e)}}else{const e=u-s,o=d-a,l=f-s,c=p-a,m=t.clamp(g*(1-n)+h*n,R,N),x=m,M=W+te,B=r.sampleElevation(x,M,_)-a,y=v(M)-i,S=2===D?-1:1;if(A=S*y*(-c+o),E=S*(-l+e)*B,C=-S*y*(-l+e),w){const t=m,n=W+$,s=v(n)-i;A=(-y+s)*(-c+o),E=(-l+e)*(-B+(r.sampleElevation(t,n,F)-a)),C=-(-y+s)*(-l+e)}}const H=1/Math.sqrt(A*A+E*E+C*C);G.setNormalFromValues(e,A*H,E*H,C*H)}}}function O(e,t){q(e)}function V(e,t){return(Math.PI/2-2*Math.atan(Math.exp(-e/t)))*t}function U(e,t){return e*t}function D(e,t,n){return e?e=>V(e,t):e=>U(e,n)}function _(e,t,n,o,s,r){const i=t-1,a=e.vertexAttributes.count,l=2*(Math.min(t-2,o[1])-Math.max(1,o[0]))*(Math.min(t-2,s[1])-Math.max(1,s[0])),c=d.neighborEdgeIndices.map(((e,n)=>0===n&&s[1]<t-2||1===n&&o[1]<t-2||2===n&&s[0]>1||3===n&&o[0]>1)),u=e.outerEdges.reduce(((e,t,n)=>e+(c[n]?0:i-2+t.count-1)),0),f=n.reduce(((e,t)=>e+i*(2*(t.latitudeResolution-1)+1)),0),m=r?2:1,p=3*(l+u+f)*m,h=a>=g?new Uint32Array(p):new Uint16Array(p);let x=0;const M=t-2,A=i-2;d.internalAssert(A>=0);const E=(e,t,n,o,s,r)=>{const i=e*s,a=r[i],l=r[i+1],c=r[i+2],u=t*s,d=r[u],f=r[u+1],m=r[u+2],p=n*s,g=r[p],h=r[p+1],x=r[p+2],M=o*s,A=r[M],E=r[M+1],B=r[M+2];return(d-A)*(d-A)+(f-E)*(f-E)+(m-B)*(m-B)>(a-g)*(a-g)+(l-h)*(l-h)+(c-x)*(c-x)};if(r){const r=(e,t,n)=>{h[x++]=e,h[x++]=t,h[x++]=t,h[x++]=n,h[x++]=n,h[x++]=e,d.ENABLE_TERRAIN_INTERNAL_CHECKS&&(d.internalAssert(e<a),d.internalAssert(t<a),d.internalAssert(n<a),d.internalAssert(x<=p))};(()=>{for(let n=Math.max(s[0],1)-1;n<Math.min(s[1],t-2)-1;++n){const s=n*M;for(let i=Math.max(o[0],1)-1;i<Math.min(o[1],t-2)-1;++i){const t=n*M+i,o=t+1,a=o+M,l=a-1,c=s+i,u=c+1,d=u+M,f=d-1,m=e.vertexAttributes.position.typedBuffer,p=e.vertexAttributes.position.typedBufferStride;E(c,u,d,f,p,m)?(r(t,o,a),r(a,l,t)):(r(t,o,l),r(l,a,o))}}})(),d.internalAssert(x===3*l*m);(()=>{for(let t=0;t<4;++t){const n=x;if(c[t])continue;const o=e.outerEdges[t],s=e.innerEdges[t];let a=0,l=0;const u=o.count,f=s.count;d.internalAssert(f===i-1);let p=0;const g=1===t||2===t?(e,t,n)=>r(e,t,n):(e,t,n)=>r(e,n,t);for(;a<u-1||l<f-1;){const e=s.getVertexIndex(l),t=o.getVertexIndex(a),n=a<u-1,r=l<f-1;if(n&&(!r||(n?0+i*(a+.5)/(u-1):0)<=(r?1+A*(l+.5)/(f-1):0))){++a,d.ENABLE_TERRAIN_INTERNAL_CHECKS&&d.internalAssert(a<u);g(e,t,o.getVertexIndex(a)),p++}else{++l,d.ENABLE_TERRAIN_INTERNAL_CHECKS&&d.internalAssert(l<f);g(e,t,s.getVertexIndex(l)),p++}}d.ENABLE_TERRAIN_INTERNAL_CHECKS&&(d.internalAssert(a===u-1),d.internalAssert(l===f-1),d.internalAssert(p===u+f-2),d.internalAssert(p===i-2+o.count-1),d.internalAssert(x===n+3*p*m))}})(),d.internalAssert(x===3*(l+u)*m);const f=n=>{const o=e.outerEdges[n.connectedOuterEdgeOffset];let s=o.getVertexIndex(0),a=o.stride;for(let e=0;e<n.latitudeResolution;++e){const o=0===e?n.rowOffset:s+t;for(let t=0;t<i;t++)r(s,s+1,o+t),e<n.latitudeResolution-1&&r(s+1,o+t+1,o+t),s+=a;s=o,a=1}};(()=>n.forEach(f))()}else{(()=>{const n=Math.max(s[0],1)-1,r=Math.min(s[1],t-2)-1,i=Math.max(o[0],1)-1,a=Math.min(o[1],t-2)-1;for(let t=n;t<r;++t){const n=t*M;for(let t=i;t<a;++t){const o=n+t,s=o+1,r=s+M,i=r-1,a=e.vertexAttributes.position.typedBuffer,l=e.vertexAttributes.position.typedBufferStride;E(o,s,r,i,l,a)?(h[x]=o,h[x+1]=s,h[x+2]=r,h[x+3]=r,h[x+4]=i,h[x+5]=o):(h[x]=o,h[x+1]=s,h[x+2]=i,h[x+3]=i,h[x+4]=s,h[x+5]=r),x+=6}}})(),d.internalAssert(x===3*l*m);(()=>{for(let t=0;t<4;++t){if(c[t])continue;const n=e.outerEdges[t],o=e.innerEdges[t];let s=0,r=0;const a=n.count,l=o.count;d.internalAssert(l===i-1);const u=1===t||2===t,f=u?1:2,m=u?2:1,p=n.index0,g=n.stride,M=o.index0,E=o.stride;for(;s<a-1||r<l-1;){const e=M+r*E,t=p+s*g,n=s<a-1,o=r<l-1,c=n&&(!o||(n?0+i*(s+.5)/(a-1):0)<=(o?1+A*(r+.5)/(l-1):0));c?++s:++r;const u=c?t+g:e+E;h[x]=e,h[x+f]=t,h[x+m]=u,x+=3}}})(),d.internalAssert(x===3*(l+u)*m);const r=n=>{const o=e.outerEdges[n.connectedOuterEdgeOffset];let s=o.getVertexIndex(0),r=o.stride;for(let e=0;e<n.latitudeResolution;++e){const o=0===e?n.rowOffset:s+t;for(let t=0;t<i;t++){const i=o+t;h[x]=s,h[x+1]=s+1,h[x+2]=i,e<n.latitudeResolution-1?(h[x+3]=s+1,h[x+4]=i+1,h[x+5]=i,x+=6):x+=3,s+=r}s=o,r=1}};(()=>n.forEach(r))()}d.internalAssert(x===p),e.indices=h,e.indexCount=p}function w(e,t){const n=e.localOrigin,o=e.geometry,s=e.geometryState.neighborData.edgeResolutions,r=o.numVerticesPerSide-2,i=o.vertexAttributes;let a=t;for(let c=0;c<4;++c){{const e=0===c||2===c,t=(0===c?r-1:0)*r+(1===c?r-1:0),s=(e?0:1)*r+(e?1:0);o.innerEdges[c]=new l.EdgeDescriptor(i,n,t,s,r)}{const e=a,t=s[c]+1;o.outerEdges[c]=new l.EdgeDescriptor(i,n,e,1,t),a+=t}}}function H(e,n,o){const s=(n+2)%4,r=e.geometryState,i=e.tile,a=r.neighborData,c=i.level-o.level,u=1===n||3===n,f=a.edgeResolutions[n];d.internalAssert(t.isPowerOfTwo(f));const m=f+1,p=e.geometry,g=p.boundingBox,h=p.outerEdges[n],x=p.uvRange[0],M=p.uvRange[1],A=p.uvRange[2],E=p.uvRange[3],B=t.clamp(1===n?1:0,x,A),v=t.clamp(0===n?1:0,M,E),y=o.renderData,S=y.geometryState,b=y.geometry.outerEdges[s],L=i.getNeighborEdgeStartVertexIndex(n,o)*f,T=f*2**c;d.internalAssert(S.neighborData.edgeResolutions[s]===T),d.internalAssert(b.count-1===T);const R=y.localOrigin[0]-e.localOrigin[0],N=y.localOrigin[1]-e.localOrigin[1],I=y.localOrigin[2]-e.localOrigin[2],P=h.attributes,C=h.index0,O=h.stride,V=P.position.typedBuffer,U=P.position.typedBufferStride,D=P.normalCompressed.typedBuffer,_=P.normalCompressed.typedBufferStride,w=P.uv0,H=b.attributes,q=b.index0,j=b.stride,K=H.position.typedBuffer,W=H.position.typedBufferStride,F=H.normalCompressed.typedBuffer,G=H.normalCompressed.typedBufferStride;for(let d=1;d<m-1;++d){const e=C+O*d,n=q+j*(L+d),o=e*U,s=n*W,r=K[s]+R,i=K[s+1]+N,a=K[s+2]+I;V[o]=r,V[o+1]=i,V[o+2]=a,l.minMaxBoundingBox(r,i,a,g);const c=e*_,m=n*G;D[c]=F[m],D[c+1]=F[m+1];const p=d/f,h=u?B:t.clamp(p,x,A),y=u?t.clamp(p,M,E):v;l.encodeUVInBuffer(w,e,h,y)}}function q(e){const n=e.geometryState,o=n.neighborData,s=e.localOrigin,i=o.cornerNeighborData,a=e.geometry,c=a.outerEdges,u=a.boundingBox,f=e.tile,p="local"===e.tile.surface.view?.viewingMode,g=f.ellipsoid.radius,h=f.extentInRadians,x=f.horizontalScale;let M=0,A=0,E=0;const B=(e,t,n)=>{const o=h[0===t?1:3],s=h[0===e?0:2],r=Math.cos(o),i=Math.sin(o),a=Math.sin(s),l=Math.cos(s),c=g+n;M=l*r*c,A=a*r*c,E=i*c},v=p?(()=>{const n=e.geometryState.clippingArea,o=f.extent,s=null!=n&&(o[3]>n[3]||o[2]>n[2]||o[1]<n[1]||o[0]<n[0]),r=D(f.surface.isWebMercatorOnPlateeCarree,f.ellipsoid.radius,x);return(e,o,i)=>{const a=0===e?U[0]:U[2],l=0===o?U[1]:U[3],c=s?t.clamp(a,n[0],n[2]):a,u=s?t.clamp(l,n[1],n[3]):l,d=i;M=c*x,A=r(u),E=d}})():B;let y=0,S=0,b=0,T=0,R=0,N=0,I=0,P=0,C=0;const O=p&&e.tile.surface.isWebMercatorOnPlateeCarree,V=(e,t,n,o,s)=>{let r=0,i=0,a=0;if(p){const e=t*x,s=O?(Math.PI/2-2*Math.atan(Math.exp(-n/g)))*g:n*x;r=e-M,i=s-A,a=o-E}else{const s=L(e),l=e.tile,c=l.extent,u=l.extentInRadians,d=(t-c[0])/(c[2]-c[0]),f=(n-c[1])/(c[3]-c[1]),m=u[0]*(1-d)+u[2]*d,p=s(f),h=Math.cos(p),x=Math.sin(p),B=Math.sin(m),v=Math.cos(m),y=g+o;r=v*h*y-M,i=B*h*y-A,a=x*y-E}switch(s){case 0:I+=r,P+=i,C+=a;break;case 1:T-=r,R-=i,N-=a;break;case 2:I-=r,P-=i,C-=a;break;case 3:T+=r,R+=i,N+=a}},U=f.extent,_=n.clippingArea,w=null!=_?_:G,H=U[0],q=U[2],K=U[1],F=U[3],z=[F>w[3],q>w[2],K<w[1],H<w[0]],J=Math.max(H,w[0]),Q=Math.min(q,w[2]),X=Math.max(K,w[1]),Y=Math.min(F,w[3]),Z=a.uvRange[0],$=a.uvRange[1],ee=a.uvRange[2],te=a.uvRange[3],ne=e=>{const t=i[e].cornerTiles;y=0,S=0,b=1,T=0,R=0,N=0,I=0,P=0,C=0;let n=1/0;for(let r=0;r<4;++r)n=Math.min(n,t[r]?.level??1/0);for(let r=0;r<4;++r){const e=t[r];k[r]=e?.level===n?e:null}let o=1,s=0;for(let r=0;r<4;++r){const e=k[r];e&&(o=Math.max(o,e?.renderData.geometryState.numVerticesPerSide),s=e.extent[2]-e.extent[0])}const a=s,l=o;d.internalAssert(l>1);const c=a/l;for(let i=0;i<4;++i){const e=k[(i+3)%4],t=k[i%4];if(!e&&!t)continue;const n=0===i?1:1===i?2:2===i?3:0,o=0===i?2:1===i?3:2===i?0:1;if(e&&t){const s=W[i][0]*c,a=W[i][1]*c,l=e.extent,u=l[0===n||1===n?2:0]+s,d=l[0===n||3===n?3:1]+a,f=t.extent,m=f[0===o||1===o?2:0]+s,p=f[0===o||3===o?3:1]+a,g=e.renderData,h=t.renderData,x=r.sampleElevation(u,d,g.geometryState.samplerData),M=r.sampleElevation(m,p,h.geometryState.samplerData);V(g,u,d,.5*(x+M),i)}else{const s=e??t,a=e?n:o,l=s.extent,u=W[i],d=l[0===a||1===a?2:0]+u[0]*c,f=l[0===a||3===a?3:1]+u[1]*c,m=s.renderData,p=r.sampleElevation(d,f,m.geometryState.samplerData);V(m,d,f,p,i)}}if(!p){const e=Math.sqrt(M*M+A*A+E*E);y=M/e,S=A/e,b=E/e}if(p||b*b<.999){const e=Math.sqrt(T*T+R*R+N*N);T/=e,R/=e,N/=e;const t=Math.sqrt(I*I+P*P+C*C);I/=t,P/=t,C/=t,y=N*P-R*C,S=T*C-N*I,b=R*I-T*P;const n=1/Math.sqrt(y*y+S*S+b*b);y*=n,S*=n,b*=n}};for(let L=0;L<4;++L){const o=L,a=(L+1)%4,p=0===L||1===L?1:0,g=0===L||3===L?1:0,h=t.clamp(p,Z,ee),x=t.clamp(g,$,te),B=c[o],T=0===L||3===L?B.count-1:0,R=c[a],N=0===L||1===L?R.count-1:0,I=i[L].cornerTiles;let P=-1;for(let e=0;e<4;++e){const t=I[e];t&&(-1===P||m.compareTilesByLij(I[P],t)>0)&&(P=e)}const C=P,O=I[C];if(O!==f){const t=f.level-O.level,n=2**t,o=[O.lij[0]+t,O.lij[1]*n,O.lij[2]*n],s=[o[1]+n===f.lij[1],0===L&&(1===C||0===C&&O!==I[3])||1===L&&(0===C||1===C&&O!==I[2]),o[1]===f.lij[1]+1,2===L&&(3===C||2===C&&O!==I[1])||3===L&&(2===C||3===C&&O!==I[0])],r=s.reduce(((e,t)=>e+(t?1:0)),0);d.internalAssert(1===r||2===r);let i=-1,a=-1;const c=O.renderData;if(1===r){const t=s.findIndex((e=>e));d.internalAssert(0<=t&&t<=3),i=(t+2)%4;const n=e.geometryState.neighborData.edgeResolutions[t];a=f.getNeighborEdgeStartVertexIndex(t,O)*n+n*(0===t&&0===L||1===t&&0===L||2===t&&1===L||3===t&&3===L?1:0)}else{d.internalAssert(s[1]||s[3]),i=s[1]?3:1;const e=c.geometryState.neighborData.edgeResolutions[i];a=0===L||3===L?0:e}const m=c.geometry.outerEdges[i];{const t=B.index0+T*B.stride,n=R.index0+N*R.stride,o=m.index0+a*m.stride;{const s=m.attributes.position,r=s.typedBuffer,i=o*s.typedBufferStride,a=e.localOrigin,c=m.localOrigin,d=r[i]+c[0]-a[0],f=r[i+1]+c[1]-a[1],p=r[i+2]+c[2]-a[2];l.minMaxBoundingBox(d,f,p,u);{const e=B.attributes.position,n=e.typedBuffer,o=t*e.typedBufferStride;n[o]=d,n[o+1]=f,n[o+2]=p}{const e=R.attributes.position,t=e.typedBuffer,o=n*e.typedBufferStride;t[o]=d,t[o+1]=f,t[o+2]=p}}l.encodeUVInBuffer(B.attributes.uv0,t,h,x),l.encodeUVInBuffer(R.attributes.uv0,n,h,x);{const e=m.attributes.normalCompressed.typedBuffer,s=o*m.attributes.normalCompressed.typedBufferStride;{const n=B.attributes.normalCompressed,o=n.typedBuffer,r=t*n.typedBufferStride;o[r]=e[s],o[r+1]=e[s+1]}{const t=R.attributes.normalCompressed,o=t.typedBuffer,r=n*t.typedBufferStride;o[r]=e[s],o[r+1]=e[s+1]}}}}else{const e=z[o],i=z[a];let c;if(e||i){const e=t.clamp(H*(1-p)+q*p,J,Q),o=t.clamp(K*(1-g)+F*g,X,Y),s=n.samplerData;c=r.sampleElevation(e,o,s)}else c=j(I);v(p,g,c),ne(L);const d=M-s[0],f=A-s[1],m=E-s[2];l.minMaxBoundingBox(d,f,m,u),B.setVertexFromValuesRawPositionUVNormal(T,d,f,m,h,x,y,S,b),R.setVertexFromValuesRawPositionUVNormal(N,d,f,m,h,x,y,S,b)}}for(let t=0;t<4;++t)k[t]=null}function j(e){const t=e.reduce(((e,t)=>Math.min(e,t?.level??1/0)),1/0);d.ENABLE_TERRAIN_INTERNAL_CHECKS&&(d.internalAssert(!e[0]||!e[2]||f.isCornerNeighbor(e[0],e[2],a.NeighborIndex.SOUTH_WEST)),d.internalAssert(!e[1]||!e[3]||f.isCornerNeighbor(e[1],e[3],a.NeighborIndex.NORTH_WEST)));let n=0,o=0;for(let i=0;i<4;++i){const s=e[i];if(s&&s.level===t){const e=0===i||1===i,t=0===i||3===i,a=s.extent,l=a[e?0:2],c=a[t?1:3],u=s.renderData?.geometryState?.samplerData;o+=r.sampleElevation(l,c,u),n++}}const s=n?o/n:0;return d.internalAssert(null!=s),s}function K(e){const t=e.vao,n=e.geometry.vertexAttributes.position.typedBuffer;t.vertexBuffers.geometry.setSubData(n,0,0,n.length)}const W=[[0,1],[1,0],[0,-1],[-1,0]],F=new c.PatchGeometryLUT,G=s.fromValues(-1/0,-1/0,1/0,1/0),k=[null,null,null,null];function z(e,t,n){if(!t)return!1;const o=m.compareTilesByLij(e,t);return o>0||0===o&&n>=2}e.createPlanarGlobePatch=T,e.createSphericalGlobePatch=h,e.updateCornerSpherical=A,e.updateCornersPlanar=N,e.updateEdgesAndCornersPlanar=I,e.updateEdgesAndCornersSpherical=M,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
