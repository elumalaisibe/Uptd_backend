/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["exports","../../../chunks/_rollupPluginBabelHelpers","../../../core/arrayUtils","../../../core/mathUtils","../../../chunks/vec3","../../../chunks/vec3f64","../../../geometry/support/aaBoundingBox","../../../geometry/support/aaBoundingRect","../../../geometry/support/Ellipsoid","../support/buffer/glUtil","./GeometryState","./ITile","./LayerClass","./PatchGeometry","./terrainUtils","./TextureFader","./Tile","./TileOverlayData","./tileUtils","../webgl-engine/lib/VertexArrayObject","../webgl-engine/shaders/TerrainTechnique","../../webgl/BufferObject"],(function(e,t,r,i,n,s,a,o,l,h,c,d,u,g,m,y,f,_,p,A,x,E){"use strict";let b=function(){function e(){this.geometry=new g.PatchGeometry,this.intersectionData=null,this.geometryState=null,this._textureRef=new y.TextureFader((()=>this.tile.surface.textureFadeDuration)),this.overlay=new _,this._geometryStateChangedSinceLastUpdate=!0,this._hasGeometry=!1,this._numVerticesPerSideChanged=!1,this._samplerDataChanged=!1,this._clippingAreaChanged=!1,this._wireframeChanged=!1,this._dirtyEdgeResolutions=15,this._dirtyEdges=15,this._dirtyCorners=15}var b=e.prototype;return b.init=function(e){this.clear(),this._tile=e;const t=this.geometry;t.indices=null,t.vertexAttributes=null,a.empty(t.boundingBox),t.indexCount=0,t.numVerticesPerSide=0,this.intersectionData=null,this.geometryState=new c.GeometryState,this.localOrigin=null,this.overlay.clear()},b.clear=function(){this.releaseGeometry(),this.releaseTexture(),this._textureRef.clear(),this._tile=null,this.intersectionData=null,this.geometryState=null},b.updateGeometryIfNeeded=function(e){if((!this._vao||this._geometryStateChangedSinceLastUpdate||this._wireframeChanged||this._clippingAreaChanged||this._samplerDataChanged||this._numVerticesPerSideChanged||this._dirtyCorners||this._dirtyEdgeResolutions||this._dirtyEdges)&&(this._updateGeometry(e),this._geometryStateChangedSinceLastUpdate=!1),m.ENABLE_TERRAIN_INTERNAL_CHECKS&&this.tile.intersectsClippingArea)for(let t=0;t<4;++t)m.internalAssert(this.geometry.outerEdges[t].count===this.geometryState.neighborData.edgeResolutions[t]+1)},b._calculateEdgeResolution=function(e,t){const r=this.tile,i=this.geometryState.numVerticesPerSide-1;if(!r.surface.isGlobal){const t=r.surface.extent;if(null!=t&&(0===e&&r.extent[3]>t[3]||1===e&&r.extent[2]>t[2]||2===e&&r.extent[1]<t[1]||3===e&&r.extent[0]<t[0]))return i}const n=r.level,s=m.neighborEdgeIndices[e];if(!t)return m.internalAssert(null==r.surface?.rootTiles||r.surface.updatingRootTiles||!r.shouldHaveNeighbor(s)),i;if(t.isLoaded){const r=t,s=r.renderData.geometryState,a=n-r.level;if(m.internalAssert(a>=0),0===a){const e=s.numVerticesPerSide-1;return Math.max(e,i)}const o=2**a,l=s.neighborData.edgeResolutions[(e+2)%4]/o;return Math.max(1,l)}m.internalAssert(!t.isLeaf);let a=i;return t.forAllSubtreeOnSide(m.oppositeEdge(s),(e=>e===r||(e.isLoaded?(a=Math.max(a,2**(e.level-n)),!0):(m.internalAssert(!e.isLeaf),!1)))),a},b.updateNeighborData=function(){const e=this.tile;if(!e.intersectsClippingArea)return;const t=e.renderData.geometryState.neighborData,r=t=>(t.isLoaded||t.level===e.level)&&t?.intersectsClippingArea,n=t.edgePeerNeighbors,s=t.edgePeerNeighborSamplerVersions;for(let o=0;o<4;++o){const a=e.findNeighborTile(m.neighborEdgeIndices[o],r),l=L(e,a),h=l?.renderData?.geometryState.samplerDataVersion??-1,c=n[o],d=l!==L(e,c),u=s[o]!==h;n[o]=a,(d||u)&&(s[o]=h,this._markEdgeDirty(o));const g=t.edgeResolutions[o],y=this._calculateEdgeResolution(o,a);m.internalAssert(i.isPowerOfTwo(y)),m.internalAssert(y>=1),t.edgeResolutions[o]=y,g!==y&&this._markEdgeResolutionDirty(o)}const a=t.cornerPeerNeighbors;for(let i=0;i<4;++i){const s=e.findNeighborTile(m.neighborCornerIndices[i],r);a[i]=s;const o=L(e,n[i]),l=L(e,n[(i+1)%4]),h=L(e,s);R[i]=h,R[(i+1)%4]=l,R[(i+2)%4]=e,R[(i+3)%4]=o,m.internalAssert(R.some((t=>t?.isLoaded||t===e)));const c=R.reduce(((e,t)=>Math.min(e,t?.level??1/0)),1/0);R.forEach(((e,t)=>{e&&e?.level>c&&(R[t]=null)})),m.internalAssert(R.some((t=>t?.isLoaded||t===e)));const d=t.cornerNeighborData[i].cornerTiles,u=t.cornerNeighborData[i].cornerTileSamplerVersions;for(let e=0;e<4;++e){const t=R[e],r=t?.renderData.geometryState.samplerDataVersion??-1,n=d[e]!==t,s=!n&&u[e]!==r;(n||s)&&(d[e]=t,u[e]=r,this._markCornerDirty(i))}m.internalAssert(d.some((t=>t?.isLoaded||t===e)))}m.ENABLE_TERRAIN_INTERNAL_CHECKS&&m.internalAssert(this.geometryState.neighborData.edgeResolutions.every((e=>e>0)));for(let i=0;i<4;++i)R[i]=null},b._updateGeometry=function(e){if(!this.tile.intersectsClippingArea)return;m.ENABLE_TERRAIN_INTERNAL_CHECKS&&m.internalAssert(!this.tile.intersectsClippingArea||this.geometryState.neighborData.edgeResolutions.every((e=>e>0))),this.intersectionData=null;const t=this.tile,r=this._vao,i=this.geometry.vertexAttributes,n=!r||!i||this._wireframeChanged||this._numVerticesPerSideChanged||this._samplerDataChanged||this._clippingAreaChanged||this._dirtyEdgeResolutions,s=!n&&(0!==this._dirtyEdges||0!==this._dirtyEdgeResolutions),a=!s&&0!==this._dirtyCorners;n?(this.releaseGeometry(),this._createGeometry(e)):s||a?t.updateEdgeElevations():a?t.updateCornerElevations():console.warn("Update for no reason?"),this._numVerticesPerSideChanged=!1,this._samplerDataChanged=!1,this._dirtyEdgeResolutions=0,this._dirtyEdges=0,this._dirtyCorners=0,this._clippingAreaChanged=!1,this._wireframeChanged=!1},b.releaseGeometry=function(){return this._hasGeometry=!1,this.intersectionData=null,!!this._vao&&(this._vao.dispose(),this._vao=null,g.releaseGeometry(this.geometry),!0)},b.ensureTexture=function(e,t){return null!=this._texture&&this._texture.descriptor.width!==e&&this.releaseTexture(),null==this._texture&&(this._texture=t(),this.tile.setMemoryDirty()),this._texture},b.releaseTexture=function(){null!=this._texture&&(this._texture.release(),this._texture=null,this.tile.setMemoryDirty())},b._markCornerDirty=function(e){const t=1<<e;this._dirtyCorners|=t},b._markEdgeDirty=function(e){const t=1<<e;this._dirtyEdges|=t,this._markCornerDirty((e+0)%4),this._markCornerDirty((e+3)%4)},b._markEdgeResolutionDirty=function(e){const t=1<<e;this._dirtyEdgeResolutions|=t,this._markEdgeDirty(e)},b._markAllEdgesAndCornersDirty=function(){this._dirtyCorners=15,this._dirtyEdges=15,this._dirtyEdgeResolutions=15},b.updateGeometryState=function(){const e=this._getElevationInfo(),t=this.tile,i=e.samplerData?t.getElevationVerticesPerSide(e.maxTileLevel):t.getDefaultVerticesPerSide(),n=Math.max(i,5);let s=t.clippingArea;t.intersectsClippingArea&&!t.isWithinClippingArea||(s=null);const a=this.geometryState;let o=!1;a.numVerticesPerSide!==n&&(this._numVerticesPerSideChanged=!0,a.numVerticesPerSide=n,a.samplerDataVersion++,o=!0),e.changed&&(this._samplerDataChanged=!0,a.samplerData=e.samplerData,a.samplerDataVersion++,o=!0),r.equals(a.clippingArea,s)||(this._clippingAreaChanged=!0,a.clippingArea=s,o=!0);const l=t.surface.wireframe;return a.wireframe!==l&&(this._wireframeChanged=!0,a.wireframe=l,o=!0),this._geometryStateChangedSinceLastUpdate||(this._geometryStateChangedSinceLastUpdate=o),o&&this._markAllEdgesAndCornersDirty(),this._hasGeometry=!0,this._geometryStateChangedSinceLastUpdate},b._createGeometry=function(e){this.tile.createGeometry();const t=this.geometry.vertexAttributes,r=this.geometry.indices,i=e.gl;this._vao=new A.VertexArrayObject(e,x.terrainVertexAttributeLocations,{geometry:h.glLayout(t.layout)},{geometry:E.BufferObject.createVertex(e,i.STATIC_DRAW,t.buffer)},E.BufferObject.createIndex(e,i.STATIC_DRAW,r)),this._hasGeometry=!0},b.setTextureReference=function(e,t=y.ActivationTime.Immediate){null!=e&&e.texture!==this._texture&&this.releaseTexture(),this._textureRef.push(e,t)},b._getElevationInfo=function(){const e=this.geometryState.samplerData,t=this.tile.layerInfo[u.LayerClass.ELEVATION],r=t.length,i=new Array(r);let n=0,s=0,a=!1;for(let h=0;h<r;h++){const r=t[h];if(null!=r.upsampleInfo){const t=r.upsampleInfo.tile,o=t.layerInfo[u.LayerClass.ELEVATION][h].data,l=o&&o.samplerData;e&&e[n]===l||(a=!0),i[n++]=l,s=Math.max(s,t.lij[0])}else if(r.data){const t=this.tile.surface.layerViewByIndex(h,u.LayerClass.ELEVATION);if(p.fallsWithinLayer(this.tile,t.layer,!1)){const t=r.data;e&&e[n]===t.samplerData||(a=!0),i[n++]=t.samplerData,s=this.tile.level}}}null!=e&&e.length!==n&&(a=!0);const o=n>0,l=o?i:null;return o&&(i.length=n),{changed:a,samplerData:l,maxTileLevel:s}},b.checkGeometryWaterproofness=function(){if(!m.ENABLE_TERRAIN_INTERNAL_CHECKS)return;const e=this.tile;if(!e.isLoaded||!e.intersectsClippingArea||0===e.level)return void m.internalAssert(e?.isLoaded);const t=e.surface.extent;if(null!=t&&!e.intersectsExtent(t))return;const r=m.neighborEdgeIndices.map(((r,i)=>null!=t&&(i<2?-1:1)*(e.extent[3-i]-t[3-i])<0)),a=e.level;m.internalAssert(0===this._dirtyCorners),m.internalAssert(0===this._dirtyEdges),m.internalAssert(0===this._dirtyEdgeResolutions),m.internalAssert(!this._numVerticesPerSideChanged),m.internalAssert(!this._samplerDataChanged),m.internalAssert(!this._clippingAreaChanged),m.internalAssert(!this._wireframeChanged);const h=m.neighborCornerIndices.map((t=>e.findNeighborCornerTileExact(t,(t=>!t.intersectsClippingArea||t.isLoaded||t.level===e.level))??null)).map((e=>e?.intersectsClippingArea?e:null)),c=this.geometryState.neighborData;for(let i=0;i<4;++i){const t=c.cornerPeerNeighbors[i],r=h[i];m.internalAssert(r===t,`Tile[${e.lij}].corner[${i}] out of date: cur=[${t?.lij}] exp=[${r?.lij}]`)}m.neighborEdgeIndices.forEach(((t,h)=>{if(r[h])return;const c=e.findNeighborTile(t,(e=>(e.level===a||e?.isLoaded)&&e?.intersectsClippingArea));if(!c){const r=!e.surface.updatingRootTiles&&null!=e.surface.rootTiles&&e.surface.rootTiles.length>0&&e.shouldHaveNeighbor(t);return void m.internalAssert(!r)}m.internalAssert(c.isLoaded||c.level===e.level),m.internalAssert(c===this.geometryState.neighborData.edgePeerNeighbors[h]);const u=a-c.level;if(!c.isLoaded)return m.internalAssert(!c.isLeaf),void m.internalAssert(0===u);const g=c.renderData;m.internalAssert(f.isEdgeNeighbor(e,c,t)),m.internalAssert(u>=0);const y=2**u;if(u<0)return void m.internalAssert(!1);const _=e.renderData,p=_.geometry,A=p.outerEdges[h],x=p.numVerticesPerSide-1,E=g.geometry;if(!E)return void m.internalAssert(!1);const b=this.geometryState.neighborData.edgePeerNeighbors[h];if(b?.isLoaded){const e=b.renderData;m.internalAssert(b==b),m.internalAssert(_.geometryState.neighborData.edgePeerNeighborSamplerVersions[h]===e.geometryState.samplerDataVersion),m.internalAssert(this.geometryState.neighborData.edgePeerNeighborSamplerVersions[h]===e.geometryState.samplerDataVersion)}const R=(h+2)%4,L=E.outerEdges[R],V=A.count-1,I=L.count-1;m.internalAssert(V*y===I,`Tile[${e.lij}]:e${h},res=${V} edgeRes mismatch with Neighbor[${c.lij}]:e${R},res=${I} (expected:${V*y})`);const P=e.extent,w=t===d.NeighborIndex.NORTH||t===d.NeighborIndex.SOUTH,k=L.count-1,G=k/2**u,O=A.count-1;if(G<1)return void m.internalAssert(1===O);m.internalAssert(G===O),m.internalAssert(i.isPowerOfTwo(G));const j=E.numVerticesPerSide-1;m.internalAssert(u>0||G===Math.max(j,x));const M=e.getNeighborEdgeStartVertexIndex(h,c);m.internalAssert(0<=M&&M<y);const U=M*G;m.internalAssert(0<=U&&U<=k-G);let B=0,H=U;A.getVertexPos(v,0),A.getVertexPos(C,A.count-1);const F=n.distance(v,C),X=Math.max(N,1e-4*F);for(let r=0;r<=G;++r){A.getVertexPos(v,B),L.getVertexPos(C,H);const i=r/G,a=w?P[0]+i*(P[2]-P[0]):t===d.NeighborIndex.WEST?P[0]:P[2],u=w?t===d.NeighborIndex.SOUTH?P[1]:P[3]:P[1]+i*(P[3]-P[1]),y=e.surface.extent;if(null==y||o.containsXY(y,a,u)){const t=n.dist(v,C),r=n.len(v)-l.earth.radius,i=n.len(C)-l.earth.radius,o=t<X;if(!o){console.warn(`Tile edge vertex position mismatch: between [${e.lij}].edge${h}[${B}/${A.count}] and [${c.lij}].edge${R}[${H}/${L.count}]`),null!=y&&console.warn("  surface extent= ",y," x,y=",a,",",u);const l=s.create();n.subtract(l,_.localOrigin,g.localOrigin),n.len(l)>0&&console.warn(`   localOrigins: ${_.localOrigin} vs ${g.localOrigin} d=${n.len(l)} [${l}]`);(()=>{const t=s.clone(v),r=s.clone(C);e.updateEdgeElevations(),c.updateEdgeElevations(),A.getVertexPos(v,B),L.getVertexPos(C,H);const i=s.create();n.sub(i,v,t),n.len(i)>0&&console.warn(`  XXX Tile[${e.lij}] edge out of date: ${t} vs ${v} d=${n.len(i)} [${i}]`),n.sub(i,C,r),n.len(i)>0&&console.warn(`  XXX Neighbor[${c.lij}] edge out of date: ${r} vs ${C} d=${n.len(i)} [${i}]`)})(),m.internalAssert(o,`Mismatch in tile [${e.lij}].edge[${h}][${B}/${A.count}] vs neighbor [${c.lij}].edge[${R}][${H}/${L.count}] ${m.v32s(v)} vs ${m.v32s(C)}  dist=${t} h(t|n|d)=${r}|${i}|${i-r}`)}A.getNormal(S,B),L.getNormal(D,H),n.normalize($,S),n.normalize(T,D);const d=n.dot($,T),f=1-d<.01||!1||e===c;if(!f){const t=s.create();n.sub(t,S,D);const r=()=>`Mismatch in tile edge normal ${m.lij2s(e.lij)} (${B}/${A.count-1}) edge ${h} vs neighbor ${m.lij2s(c.lij)}  (${H}/${L.count-1}) nedge ${R} :${m.v32s(S)} vs ${m.v32s(D)}  dot = ${d} : ${m.v32s(t)}`;console.warn("Mismatch in tile edge normal: ",r());{e.updateEdgeElevations(),c.updateEdgeElevations();const t=s.create(),r=s.create();A.getNormal(t,B),L.getNormal(r,H),n.equals(S,t)||console.warn("Missing update in tile normal: ",m.v32s(S)," => ",m.v32s(t)),n.equals(D,r)||console.warn("Missing update in neighbor normal: ",m.v32s(D)," => ",m.v32s(r))}m.internalAssert(f,r())}}B+=1,H+=1}}))},t._createClass(e,[{key:"tile",get:function(){return this._tile}},{key:"hasGeometry",get:function(){return this._hasGeometry}},{key:"vao",get:function(){return this._vao}},{key:"textureReference",get:function(){return this._textureRef.current}},{key:"nextTextureReference",get:function(){return this._textureRef.next}},{key:"textureFadeFactor",get:function(){return this._textureRef.fadeFactor}},{key:"textureIsFading",get:function(){return this._textureRef.isFading}},{key:"estimatedGeometryMemoryUsage",get:function(){const e=this.intersectionData?.estimatedMemoryUsage??0;return(this.geometry.indices?.byteLength??0)+(this.geometry.vertexAttributes?.byteLength??0)+e}},{key:"texture",get:function(){return this._texture}},{key:"test",get:function(){return{hasTexture:null!=this._texture}}}]),e}();const v=s.create(),C=s.create(),S=s.create(),D=s.create(),$=s.create(),T=s.create(),N=1,R=[null,null,null,null];function L(e,t){return t?.isLoaded||t===e?t:null}Object.defineProperty(e,"ActivationTime",{enumerable:!0,get:()=>y.ActivationTime}),e.PatchRenderData=b,e.neighborTileIfLoadedOrSelf=L,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
