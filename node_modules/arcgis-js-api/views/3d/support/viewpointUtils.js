/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["exports","../../../Camera","../../../geometry","../../../Graphic","../../../Viewpoint","../../../core/asyncUtils","../../../core/has","../../../core/Cyclical","../../../core/Error","../../../core/promiseUtils","../../../chunks/mat3","../../../chunks/mat3f64","../../../chunks/mat4f64","../../../chunks/vec3","../../../chunks/vec3f64","../../../geometry/projection","../../../geometry/support/aaBoundingBox","../../../geometry/support/aaBoundingRect","../../../geometry/support/frustum","../../../geometry/support/scaleUtils","../../../geometry/support/webMercatorUtils","../camera/intersectionUtils","./cameraUtils","./ElevationProvider","../../../geometry/Point","../../../geometry/SpatialReference","../../../geometry/Extent","../../../geometry/Geometry"],(function(e,t,n,a,r,o,i,c,l,s,u,m,f,p,g,d,h,y,x,w,v,b,T,R,S,G,z,A){"use strict";const M=.66;function O(e){return 360-c.cyclicalDegrees.normalize(e)}function C(e){return c.cyclicalDegrees.normalize(360-e)}function j(e){return null!=e&&e.resolver&&e.resolver.reject(),null}function P(e,t){return null!=e&&e.resolver&&e.resolver.resolve(t),t}function B(e,t,n,a=null){if(!t)return j(a);const r=e.spatialReference||G.WGS84;if(null!=t.camera){const e=v.project(t.camera.position,r);if(null==e)return j(a);const n=t.camera.clone();return n.position=e.clone(),P(a,n)}if(null==t.targetGeometry)return j(a);const o=t.get("targetGeometry.spatialReference");if(o&&!v.canProject(o,r))return j(a);const i=T.internalToExternal(e,e.state.camera);let c=T.OrientationMode.ADJUST;if(null!=t.rotation&&(i.heading=O(t.rotation),c=T.OrientationMode.LOCKED),null!=n&&(i.tilt=n),"point"===t.targetGeometry.type){const n=t.targetGeometry;let r;const o=t.targetGeometry.clone();return r=null!=t.scale?T.scaleToDistance(e,t.scale,n.latitude):e.state.camera.distance,T.fromCenterDistance(e,o,r,i,c,a)}const l=t.targetGeometry.extent;return l?T.fromExtent(e,l,i.heading,i.tilt,c,a):j(a)}function D(e,t,n=null){return null==n&&(n=new r),U(e,null,t.clone(),n)}async function E(e,n,a){const o=_(e,n);if(!o)throw new l("viewpointutils-create:no-target","Missing target for creating viewpoint");const i=new t({fov:e.camera.fov}),c=new r({camera:i});if(o.target instanceof r){return Q(await J(e,o.target,o,a,c))}if(o.target instanceof t)return Q(K(e,o.target,c));const s=null!=o.scale||null!=o.zoom;if(o.target instanceof z){const t=o.target.xmin===o.target.xmax||o.target.ymin===o.target.ymax;return Q(s||t?await N(e,o,o.target.center,i,a,c):await $(e,o,o.target,i,a,c))}const u={boundingBox:h.empty(),hasZ:!1,screenSpaceObjects:[]},m=s?k(e,o):void 0;if(await W(e,o.target,m,u),isFinite(u.boundingBox[0])){let t;if(h.center(u.boundingBox,te),ue.x=te[0],ue.y=te[1],ue.z=te[2],ue.spatialReference=e.spatialReference,isFinite(ue.z)&&u.hasZ?t=h.isPoint(u.boundingBox):(ue.z=void 0,t=y.isPoint(h.toRect(u.boundingBox,oe))),s||t)return Q(await N(e,o,ue,i,a,c));const n=ee(e,u.screenSpaceObjects);return Q(await X(e,o,ue,u.boundingBox,n,i,a,c))}return o.position?Q(H(e,o,i,c)):Q(await Y(e,o,i,a,c))}function V(e,t){return null==t.scale&&null!=t.zoom?T.zoomToScale(e,t.zoom):t.scale}function k(e,t){const n=V(e,t);return n?w.getResolutionInMetersForScale(n):void 0}function F(e,t){let n=!1;return null!=t.heading?(e.heading=t.heading,n=!0):null!=t.rotation&&(e.heading=O(t.rotation),n=!0),null!=t.tilt&&(e.tilt=t.tilt,n=!0),null!=t.fov&&(e.fov=t.fov),n}function U(e,t,n,a){const r=e.spatialReference||G.WGS84;return null==(t=null!=t?t:T.externalToInternal(e,n))||(a.targetGeometry=d.projectVectorToPoint(t.center,e.renderSpatialReference,r),a.scale=T.computeScale(e,t),a.rotation=C(n.heading),a.camera=n),a}function Z(e,t,n){const a=()=>new l("viewpointutils:invalid-geometry","The target is missing a valid geometry");if(!t)throw a();if(!v.canProject(t.spatialReference,e.spatialReference))throw new l("viewpointutils:incompatible-spatialreference",`Spatial reference (${t.spatialReference?t.spatialReference.wkid:"unknown"}) is incompatible with the view (${e.spatialReference?.wkid})`,{geometry:t});const r=[];if(!t.hasZ&&e.basemapTerrain){let n;switch(t.type){case"point":n=t;break;case"multipoint":case"polyline":n=t.extent?.center;break;case"mesh":n=t.origin;break;case"extent":n=t.center;break;case"polygon":n=t.centroid}n&&null!=e.basemapTerrain.spatialReference&&v.canProject(n,e.basemapTerrain.spatialReference)&&e.elevationProvider?te[2]=R.getElevationAtPoint(e.elevationProvider,n)??0:te[2]=0}(0,me[t.type])(t,(e=>{r.push(e[0],e[1],e[2])}),te);const o=r.length/3;if(0===o)throw a();const i=new Array(r.length);if(d.projectBuffer(r,t.spatialReference,0,i,e.spatialReference,0,o)){t.hasZ&&(n.hasZ=!0);for(let e=0;e<i.length;e+=3)t.hasZ?(te[0]=i[e],te[1]=i[e+1],te[2]=i[e+2]):(te[0]=i[e],te[1]=i[e+1]),h.expandWithVec3(n.boundingBox,te)}}async function I(e,t,n,a){const r=await o.result(e.whenViewForGraphic(t));if(!1===r.ok||null==r.value||!("whenGraphicBounds"in r.value))return void Z(e,t.geometry,a);const i=r.value,c=await o.result(i.whenGraphicBounds(t,{minDemResolution:n}));if(!1===c.ok)return void Z(e,t.geometry,a);const{screenSpaceObjects:l,boundingBox:s}=c.value;h.expandWithAABB(a.boundingBox,s),l&&l.forEach((e=>{a.screenSpaceObjects.push(e)})),isFinite(s[2])&&(a.hasZ=!0)}async function W(e,t,n,r){if(Array.isArray(t)&&2===t.length){const n=t[0],a=t[1];if("number"==typeof n&&"number"==typeof a)return ue.x=n,ue.y=a,ue.z=void 0,ue.spatialReference=e.spatialReference?.isGeographic?e.spatialReference:G.WGS84,void Z(e,ue,r)}t&&"map"in t&&"function"==typeof t.map?await s.eachAlways(t.map((t=>W(e,t,n,r)))):t instanceof A?Z(e,t,r):t instanceof a&&await I(e,t,n,r)}async function J(e,t,n,a,r){if(null!=t.camera)return K(e,t.camera,r);r.scale=t.scale,r.rotation=t.rotation,r.targetGeometry=null!=t.targetGeometry?t.targetGeometry.clone():null,r.camera=null,null!=n.heading?r.rotation=C(n.heading):null!=n.rotation&&(r.rotation=n.rotation);const o=V(e,n);null!=o&&(r.scale=o);const i=new T.AsyncContext(a);return B(e,r,n.tilt,i),r.camera=await i.resolver.promise,r}function K(e,t,n){const a=e.spatialReference,r=v.project(t.position,a);return null==r?null:((t=t.clone()).fov=e.camera.fov,t.position=r,U(e,null,t,n))}function L(e,t,n,a,r,o){const i=e.renderSpatialReference;return d.projectPointToVector(n,ce,i),d.projectPointToVector(t,le,i),o.targetGeometry=new S(t),r.position=new S(n),p.subtract(ie,le,ce),T.directionToHeadingTilt(e,ce,ie,a.up,r),o.scale=T.distanceToScale(e,p.distance(ce,le),o.targetGeometry.latitude),o.rotation=C(r.heading),o.camera=r,o}async function N(e,t,n,a,r,o){if(null==n)throw new l("createfromcenter","invalid point");o.targetGeometry=n.clone();const i=b.cameraOnContentAlongViewDirection(e);if(t.position)return L(e,o.targetGeometry,t.position,i,a,o);if(t.zoomFactor){const a=i.distance/t.zoomFactor,r=p.scale(te,i.viewForward,-a);i.eye=p.add(te,i.center,r),o.scale=T.distanceToScale(e,a,n.latitude)}T.internalToExternal(e,i,a);const c=F(a,t)?T.OrientationMode.LOCKED:T.OrientationMode.ADJUST;if(!t.zoomFactor){const l=V(e,t);null==l?(d.projectPointToVector(n,te,e.renderSpatialReference),x.intersectsPoint(i.frustum,te)?o.scale=T.distanceToScale(e,p.distance(i.eye,te),n.latitude):o.scale=T.computeScale(e,i)):o.scale=l;const s=new T.AsyncContext(r);T.fromCenterScale(e,o.targetGeometry,o.scale,a,c,s),o.camera=await s.resolver.promise}return o}function H(e,t,n,a){const r=b.cameraOnContentAlongViewDirection(e);return p.copy(ie,r.viewForward),T.directionToHeadingTilt(e,r.eye,ie,r.up,se),n.position=new S(t.position),n.heading=null!=t.heading?t.heading:se.heading,n.tilt=null!=t.tilt?t.tilt:se.tilt,U(e,null,n,a)}async function Y(e,t,n,a,r){const o=b.cameraOnContentAlongViewDirection(e);return N(e,t,d.projectVectorToPoint(o.center,e.renderSpatialReference,e.spatialReference),n,a,r)}async function $(e,t,n,a,r,o){o.targetGeometry=n.clone();const i=b.cameraOnContentAlongViewDirection(e);T.internalToExternal(e,i,a);const c=F(a,t)?T.OrientationMode.LOCKED:T.OrientationMode.ADJUST,l=new T.AsyncContext(r);return T.fromExtent(e,n,a.heading,a.tilt,c,l),o.camera=await l.resolver.promise,o}function q(e,t,n,a,r){let o=0;null!=n.z?o=n.z:e.basemapTerrain&&e.elevationProvider&&(o=R.getElevationAtPoint(e.elevationProvider,n)),p.set(te,n.x,n.y,o),d.computeTranslationToOriginAndRotation(e.spatialReference,te,ne,e.renderSpatialReference),u.fromMat4(ae,ne),u.transpose(ae,ae),h.empty(re);const i=[[0,1,2],[3,1,2],[0,4,2],[3,4,2],[0,1,5],[3,1,5],[0,4,5],[3,4,5]];for(let u=0;u<i.length;u++){const t=i[u];let n=a[t[2]];isFinite(n)||(n=o),p.set(te,a[t[0]],a[t[1]],n),d.projectVectorToVector(te,e.spatialReference,te,e.renderSpatialReference),h.expandWithVec3(re,p.transformMat3(te,te,ae))}const c=h.width(re),l=h.height(re),s=h.depth(re),m=1/Math.tan(t.fovX/2),f=1/Math.tan(t.fovY/2),g=.5*Math.sqrt(c*c+s*s)*Math.max(f,m)+.5*l,y=.5*l*f+.5*Math.max(c,s);return Math.max(g,y)/r}async function X(e,t,n,a,r,o,i,c){c.targetGeometry=n.clone();const l=b.cameraOnContentAlongViewDirection(e),s=q(e,l,n,a,r);T.internalToExternal(e,l,o);const u=F(o,t)?T.OrientationMode.LOCKED:T.OrientationMode.ADJUST;c.scale=T.distanceToScale(e,s,c.targetGeometry.latitude);const m=new T.AsyncContext(i);return T.fromCenterScale(e,c.targetGeometry,c.scale,o,u,m),c.camera=await m.resolver.promise,c}function _(e,t){if(!t||!e.spatialReference)return null;const n={target:void 0};return"declaredClass"in t||Array.isArray(t)?n.target=t:(Object.assign(n,t),t.center&&!n.target&&(n.target=t.center)),n}function Q(e){return e&&null!=e.camera&&(e.rotation=C(e.camera.heading)),e}function ee(e,t){const n=M;if(!t.length)return n;let a=Number.NEGATIVE_INFINITY;for(let r=0;r<t.length;r++){const e=t[r].screenSpaceBoundingRect;a=Math.max(a,Math.abs(e[0]),Math.abs(e[1]),Math.abs(e[2]),Math.abs(e[3]))}return n-a/Math.min(e.width,e.height)*2}const te=g.create(),ne=f.create(),ae=m.create(),re=h.create(),oe=y.create(),ie=g.create(),ce=g.create(),le=g.create(),se={heading:0,tilt:0},ue=new S,me={point(e,t,n){n[0]=e.x,n[1]=e.y,null!=e.z&&(n[2]=e.z),t(n)},polygon(e,t,n){const a=e.hasZ;for(let r=0;r<e.rings.length;r++){const o=e.rings[r];for(let e=0;e<o.length;e++)n[0]=o[e][0],n[1]=o[e][1],a&&(n[2]=o[e][2]),t(n)}},polyline(e,t,n){const a=e.hasZ;for(let r=0;r<e.paths.length;r++){const o=e.paths[r];for(let e=0;e<o.length;e++)n[0]=o[e][0],n[1]=o[e][1],a&&(n[2]=o[e][2]),t(n)}},multipoint(e,t,n){const a=e.points,r=e.hasZ;for(let o=0;o<a.length;o++)n[0]=a[o][0],n[1]=a[o][1],r&&(n[2]=a[o][2]),t(n)},extent(e,t,n){null!=e.zmin&&null!=e.zmax?(t(p.set(n,e.xmin,e.ymin,e.zmin)),t(p.set(n,e.xmax,e.ymin,e.zmin)),t(p.set(n,e.xmin,e.ymax,e.zmin)),t(p.set(n,e.xmax,e.ymax,e.zmin)),t(p.set(n,e.xmin,e.ymin,e.zmax)),t(p.set(n,e.xmax,e.ymin,e.zmax)),t(p.set(n,e.xmin,e.ymax,e.zmax)),t(p.set(n,e.xmax,e.ymax,e.zmax))):(t(p.set(n,e.xmin,e.ymin,n[2])),t(p.set(n,e.xmax,e.ymin,n[2])),t(p.set(n,e.xmin,e.ymax,n[2])),t(p.set(n,e.xmax,e.ymax,n[2])))},mesh(e,t,n){const a=e.vertexAttributes&&e.vertexAttributes.position;if(a)for(let r=0;r<a.length;r+=3)t(p.set(n,a[r],a[r+1],a[r+2]))}};e.create=E,e.fromCamera=D,e.headingToRotation=C,e.rotationToHeading=O,e.toCamera=B,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
