/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../chunks/vec2","../../../../chunks/vec2f64"],(function(e,t,i,n){"use strict";let r=function(){function e(){}return e.prototype.rebuildConnectingProfileGeometry=function(e,t,i){for(let n=0;n<t.vertices.length;++n)i(e.frame,t.vertices[n],t.normals[n],0,0)},t._createClass(e)}(),s=function(e){function i(){var t;return(t=e.call(this)||this).numVertices=0,t.numIndices=0,t}t._inherits(i,e);var n=i.prototype;return n.rebuildCapGeometry=function(){},n.buildTopology=function(){},t._createClass(i)}(r),o=function(e){function n(t,i=0,n=!1){var r;return(r=e.call(this)||this).profile=t,r.profilePlaneOffset=i,r.flip=n,r}t._inherits(n,e);var r=n.prototype;return r.rebuildConnectingProfileGeometry=function(e,t,i){const n=this.profilePlaneOffset;for(let r=0;r<t.vertices.length;++r)i(e.frame,t.vertices[r],t.normals[r],n,0)},r.rebuildCapGeometry=function(e,t){const n=this.profile,r=this.flip?1:-1,s=this.profilePlaneOffset,o=c;i.set(o,0,0);for(let i=0;i<n.vertices.length;++i)t(e.frame,n.vertices[i],o,s,r)},r.buildTopology=function(e,t){const i=this.profile,n=this.vertexBufferStart+i.indices[0];for(let r=1;r<i.numSegments;++r){const e=i.indices[2*r],s=i.indices[2*r+1],o=this.vertexBufferStart+e,l=this.vertexBufferStart+s;this.flip?t(l,o,n):t(n,o,l)}},t._createClass(n,[{key:"numVertices",get:function(){return this.profile.vertices.length}},{key:"numIndices",get:function(){return 3*this.profile.numSegments}}]),n}(r),l=function(e){function n(t){var i;return(i=e.call(this)||this).flip=!1,i.sign=0,i.breakNormals=!1,i.numSegments=3,i.profile=t.profile,i.flip=t.flip,i.sign=i.flip?1:-1,i.breakNormals=t.breakNormals,i.numSegments=t.subdivisions,i}t._inherits(n,e);var r=n.prototype;return r.rebuildCapGeometry=function(e,t){const n=this.profile,r=e.frame,s=.5*this.sign,o=f,l=c;i.set(l,0,0);for(const i of n.poles)i.normal?t(r,i.position,i.normal,s,0):t(r,i.position,l,s,this.sign);if(this.breakNormals)for(let i=0;i<n.vertices.length;++i)t(r,n.vertices[i],n.normals[i],0,0);for(let f=0;f<this.numSegments-1;++f){const e=(1-(f+1)/this.numSegments)*Math.PI*.5,c=Math.sin(e),u=Math.cos(e);for(let f=0;f<n.vertices.length;++f){const e=n.poles[n.poleIndices[f]];i.subtract(o,n.vertices[f],e.position),i.scale(o,o,c),e.normal?(i.add(o,o,e.position),t(r,o,e.normal,s*u,0)):(i.normalize(l,o),i.scale(l,l,c),i.add(o,o,e.position),t(r,o,l,s*u,this.sign*u))}}},r.buildTopology=function(e,t){const i=this.profile,n=this.breakNormals?this.vertexBufferStart+i.poles.length:this.firstProfileVertexIndex,r=this.breakNormals?this.vertexBufferStart+i.poles.length+i.vertices.length:this.vertexBufferStart+i.poles.length;for(let s=0;s<i.numSegments;++s){const e=i.indices[2*s],o=i.indices[2*s+1],l=this.vertexBufferStart+i.poleIndices[e],f=this.vertexBufferStart+i.poleIndices[o];let c=n+e,u=n+o;for(let n=0;n<this.numSegments-1;++n){const s=r+n*i.vertices.length+e,l=r+n*i.vertices.length+o;this.flip?(t(s,u,c),t(u,s,l)):(t(c,u,s),t(l,s,u)),c=s,u=l}this.flip?(t(l,u,c),l!==f&&t(l,f,u)):(t(c,u,l),l!==f&&t(u,f,l))}},t._createClass(n,[{key:"numVertices",get:function(){let e=this.profile.vertices.length*(this.numSegments-1)+this.profile.poles.length;return this.breakNormals&&(e+=this.profile.vertices.length),e}},{key:"numIndices",get:function(){let e=0;const t=this.profile;e+=2*t.numSegments*(this.numSegments-1);for(let i=0;i<t.numSegments;++i){const n=t.indices[2*i],r=t.indices[2*i+1];t.poleIndices[n]===t.poleIndices[r]?e+=1:e+=2}return 3*e}}]),n}(r);const f=n.create(),c=n.create();e.NoCapBuilder=s,e.PathCapBuilder=r,e.RoundCapBuilder=l,e.TriangulationCapBuilder=o,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
