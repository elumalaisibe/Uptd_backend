/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../chunks/tslib.es6","../../../../geometry","../../../../analysis/featureReferenceUtils","../../../../core/Accessor","../../../../core/asyncUtils","../../../../core/Evented","../../../../core/Handles","../../../../core/handleUtils","../../../../core/Logger","../../../../core/maybe","../../../../core/promiseUtils","../../../../core/reactiveUtils","../../../../core/accessorSupport/decorators/property","../../../../core/accessorSupport/ensureType","../../../../core/arrayUtils","../../../../core/has","../../../../core/accessorSupport/decorators/subclass","../../../../chunks/vec3","../../../../chunks/vec3f64","../../../../core/support/WatchUpdatingTracking","../../../../geometry/projection","../../../../geometry/support/aaBoundingRect","../../../../geometry/support/ray","../../../../support/elevationInfoUtils","../LineOfSightAnalysisResult","./LineOfSightComputation","./LineOfSightRayIntersector","../support/projectionUtils","../../webgl-engine/lib/IntersectorInterfaces","../../webgl-engine/lib/intersectorUtilsConversions","../../../support/Scheduler","../../../../geometry/Point"],(function(e,t,n,o,i,r,s,a,l,c,u,d,p,g,h,f,v,_,m,y,b,C,O,I,T,S,P,R,L,w,A,E,F,H){"use strict";const k="esri.views.3d.analysis.LineOfSight.LineOfSightController",j=u.getLogger(k);e.LineOfSightController=function(e){function n(t){var n;return(n=e.call(this,t)||this).updateOnCameraChange=!0,n._observerGroundOffsetRenderSpace=0,n._effectiveObserverElevationMode="absolute-height",n._observerFeatureId=null,n._updatingHandles=new C.WatchUpdatingTracking,n._frameTask=F.ImmediateTask,n._handles=new l,n._computationHandles=new l,n._externalObserverUpdate=!0,n}t._inherits(n,e);var o=n.prototype;return o.initialize=function(){const e=this.view.resourceController?.scheduler;this._frameTask=e?e.registerTask(F.TaskPriority.LINE_OF_SIGHT_TOOL):F.ImmediateTask,this._intersector=new L.LineOfSightRayIntersector({view:this.view}),this._handles.add([this._connectObserver(),this._connectComputations(),this._connectTargets()])},o.destroy=function(){this._handles.destroy(),this._computationHandles.destroy(),this._computations.removeAll(),this._updatingHandles.destroy()},o._computeResult=function(e){const t=e.computation,{inputPoints:n,computationResult:o}=t,{observerAdjusted:i,targetAdjusted:r}=n,{start:s,end:a}=o;y.copy(s,i),y.copy(a,r);this._canCompute(t)?this._computeIntersection(e):this._interpolateIntersection(e),t.notifyResultChanged(),this.emit("result-changed",{target:e.computation.target,result:t.result})},o._updateAdjustedPointsFromFeatures=function(e){const t=this.view,{sceneIntersectionHelper:n}=t,{inputPoints:o}=e,{observerAdjusted:r,observerFeatureId:s,targetFeatureId:a,targetAdjusted:l}=o;if(null==s&&null==a)return;const c=y.distance(r,l),u=this._intersector.intersector,d=T.fromPoints(o.observer,o.target,D);u.options.store=A.StoreResults.ALL,n.intersectToolIntersectorRay(d,u);let p=null,g=null,h=null,f=null;for(const v of u.results.all){const e=E.toGraphic(v,this.view);if(null==e||null==v.distanceInRenderSpace)continue;const n=i.getFeatureId(e);null!=n&&(null!=s&&n===s&&(null==p&&(p=this._getFeatureDistanceThreshold(v,t,c)),v.distanceInRenderSpace<p&&(h=v)),null!=a&&n===a&&(null==g&&(g=this._getFeatureDistanceThreshold(v,t,c)),null==f&&v.distanceInRenderSpace<c&&c-v.distanceInRenderSpace<g&&(f=v)))}null!=h&&h.getIntersectionPoint(r)&&(o.observerSurfaceNormal=h.getTransformedNormal(b.create())),null!=f&&f.getIntersectionPoint(l)&&(o.targetSurfaceNormal=f.getTransformedNormal(b.create()))},o._getFeatureDistanceThreshold=function(e,t,n){if(E.hasLod(e)){const o=E.getIntersectedFeatureBSRadius(e,t);if(null!=o)return Math.min(o*x,n)}return 1e-5*n},o._adjustStartEndPositions=function(e){const t=this._screenPixelSize,n=this.view,{inputPoints:o}=e,{observer:i,observerSurfaceNormal:r,target:s,targetSurfaceNormal:a,observerAdjusted:l,targetAdjusted:c}=o,u=G;y.copy(l,i),y.copy(c,s),this._updateAdjustedPointsFromFeatures(e),null!=r?y.copy(u,r):y.subtract(u,c,l);const d=t;y.normalize(u,u),y.scale(u,u,Math.min(d,1)),y.add(l,l,u),null!=a?y.copy(u,a):y.subtract(u,l,c);const p=n.state.camera.computeScreenPixelSizeAt(c);y.normalize(u,u),y.scale(u,u,Math.min(p,1)),y.add(c,c,u)},o._computeIntersection=function({computation:e,interpolationInfo:t}){const{view:n}=this,{sceneIntersectionHelper:o,renderCoordsHelper:i}=n;if(null==o)return;const r=this._intersector.intersector,{computationResult:s,inputPoints:a}=e,{observer:l,target:c}=a,{start:u,end:d}=s,p=T.fromPoints(u,d,D);r.options.store=A.StoreResults.MIN,o.intersectToolIntersectorRay(p,r);const g=r.results.min,h=s.intersection,f=G;let v=!0;if(null!=g&&g.getIntersectionPoint(h)){y.copy(t.originalIntersection,h),y.copy(t.originalObserver,u),y.copy(t.originalTarget,d),i.fromRenderCoords(h,f,n.spatialReference);const e=1-y.dist(d,c)/y.dist(u,c);v=y.dist(l,h)>=e*y.dist(l,c)}const _=new H(f,n.spatialReference);{const{result:t,target:o}=e;null!=t?(t.target=o,t.intersectedGraphic=v?null:E.toGraphic(g,n),t.intersectedLocation=v?null:_,t.visible=v):e.result=new P.LineOfSightAnalysisResult({target:o,elevationAlignedTargetLocation:e.elevationAlignedTargetLocation,intersectedGraphic:v?null:E.toGraphic(g,n),intersectedLocation:v?null:_,visible:v})}s.isValid=a.isValid=!0,s.isTargetVisible=v},o._interpolateIntersection=function({computation:e,interpolationInfo:t}){const{computationResult:n,inputPoints:o}=e,{start:i,end:r,intersection:s}=n,{originalIntersection:a,originalObserver:l,originalTarget:c}=t;if(y.copy(s,a),o.isValid){const e=G,t=y.dist(l,a)/y.dist(l,c);y.sub(e,i,l),y.scale(e,e,1-t),y.add(s,s,e),y.sub(e,r,c),y.scale(e,e,t),y.add(s,s,e),n.isValid=!0}else e.result=null,n.isValid=!1,n.isTargetVisible=!1},o._canCompute=function(e){const t=this.analysisViewData.elevationAlignedObserver,n=this.view.frustum;if(null==t||null==e.elevationAlignedTargetLocation||null==n)return!1;const{observerAdjusted:o,targetAdjusted:i}=e.inputPoints,r=n.intersectsPoint(o),s=n.intersectsPoint(i);return r&&s},o._onObserverPositionChange=function(e,t,n,o,r){if(this._externalObserverUpdate=r,null==e)return this.analysisViewData.elevationAlignedObserver=null,void(this._observerFeatureId=null);if(null==t)return w.logFailedGeometryProjectionError(this.analysis,e.spatialReference,j),void(this.analysisViewData.elevationAlignedObserver=null);const s=this._getEffectiveElevationInfo(t,n),{absoluteZ:a,elevation:l}=S.zValueInAbsoluteHeightMode(t.x,t.y,t.z,this.view.spatialReference,this.view,s),c=t.clone();c.z=a,this._effectiveObserverElevationMode=s.mode,this.analysisViewData.elevationAlignedObserver=c;const u=b.create();this.view.renderCoordsHelper.toRenderCoords(c,u),this._elevationAlignedObserverPositionRenderSpace=u,this._observerGroundOffsetRenderSpace=a-l,this._observerFeatureId=i.getFeatureId(o),this.priority=F.TaskPriority.LINE_OF_SIGHT_TOOL_INTERACTIVE},o._onObserverRenderSpacePositionChangeForComputation=function(e,t,n,o,i){const{inputPoints:r}=e;switch(y.copy(r.observer,t),r.observerFeatureId=i,r.observerSurfaceNormal=null,o){case"on-the-ground":case"relative-to-ground":{const e=this._intersector.updateFromGroundIntersection(r.observer,n,r.observer);null==r.observerFeatureId&&(r.observerSurfaceNormal=e)}}this._adjustStartEndPositions(e),e.notifyInputPointsChanged(),this.priority=F.TaskPriority.LINE_OF_SIGHT_TOOL_INTERACTIVE},o._onTargetPositionChange=function(e,t,n,o,r,s=!0){const a=e.inputPoints;if(s&&(a.isValid=!1),null==n)return null!=t&&w.logFailedGeometryProjectionError(this.analysis,t.spatialReference,j),e.elevationAlignedTargetLocation=null,void e.notifyInputPointsChanged();const l=this._getEffectiveElevationInfo(n,o),{absoluteZ:c,elevation:u}=S.zValueInAbsoluteHeightMode(n.x,n.y,n.z,this.view.spatialReference,this.view,l),d=n.clone();switch(d.z=c,e.elevationAlignedTargetLocation=d,this.view.renderCoordsHelper.toRenderCoords(e.elevationAlignedTargetLocation,a.target),a.targetFeatureId=i.getFeatureId(r),a.targetSurfaceNormal=null,l.mode){case"on-the-ground":case"relative-to-ground":{const e=this._intersector.updateFromGroundIntersection(a.target,c-u,a.target);null==a.targetFeatureId&&(a.targetSurfaceNormal=e)}}this._adjustStartEndPositions(e),e.notifyInputPointsChanged(),this.priority=F.TaskPriority.LINE_OF_SIGHT_TOOL_INTERACTIVE},o._connectComputationToTarget=function(e){return c.handlesGroup([this._updatingHandles.add((()=>({computation:e,targetPosition:e.target.position,targetElevationInfo:e.target.elevationInfo,targetFeatureInfo:e.target.feature,projectedTargetPosition:O.projectOrLoad(e.target.position,this.view.spatialReference)})),(({computation:e,targetPosition:t,targetElevationInfo:n,targetFeatureInfo:o,projectedTargetPosition:i})=>{null==i.pending?this._onTargetPositionChange(e,t,i.geometry,n,o):this._updatingHandles.addPromise(i.pending)}),g.initial)])},o._connectComputationToObserver=function(e){return this._updatingHandles.add((()=>({computation:e,observer:this.analysisViewData.elevationAlignedObserver})),(({computation:e})=>{this._externalObserverUpdate&&(e.inputPoints.isValid=!1,e.notifyInputPointsChanged())}),g.initial)},o._connectComputationToRenderSpaceObserver=function(e){return this._updatingHandles.add((()=>({computation:e,observer:this._elevationAlignedObserverPositionRenderSpace,observerGroundOffset:this._observerGroundOffsetRenderSpace,observerElevationMode:this._effectiveObserverElevationMode,observerFeatureId:this._observerFeatureId})),(({computation:e,observer:t,observerGroundOffset:n,observerElevationMode:o,observerFeatureId:i})=>{this._onObserverRenderSpacePositionChangeForComputation(e,t,n,o,i)}),g.initial)},o._connectComputationToCamera=function(e){return this._updatingHandles.add((()=>({camera:this.view.state.camera,isDirty:this._isCameraDirty})),(({isDirty:t})=>{!this.updateOnCameraChange||e.inputPoints.isValid&&!t||e.notifyInputPointsChanged()}))},o._connectComputationToSlicePlane=function(e){return this._updatingHandles.add((()=>this.view.slicePlane),(()=>{e.inputPoints.isValid=!1,e.notifyInputPointsChanged()}))},o._connectComputationToElevation=function(e){const t=(n,o)=>{const i=this.analysis.observer,r=e.target;let s=null,a=null,l=null,c=null,u=null,d=null;if(null!=i&&null!=i.position){const e=O.projectOrLoad(i.position,this.view.spatialReference);if(null!=e.pending)return this._updatingHandles.addPromise(e.pending),void e.pending.finally((()=>t(n,o)));s=e.geometry,a=i.elevationInfo,l=i.feature}if(null!=r.position){const e=O.projectOrLoad(r.position,this.view.spatialReference);if(null!=e.pending)return this._updatingHandles.addPromise(e.pending),void e.pending.finally((()=>t(n,o)));c=e.geometry,u=r.elevationInfo,d=r.feature}null==s&&null==c||(O.projectBoundingRect(n,o,N,this.view.spatialReference),null!=s&&I.containsPointObject(N,s)&&this._onObserverPositionChange(null!=i?i.position:null,s,a,l,!1),null!=c&&I.containsPointObject(N,c)&&this._onTargetPositionChange(e,r.position,c,u,d,!1),null!=s&&null!=c&&I.intersectsSegment(N,s,c)&&e.notifyInputPointsChanged())};return this.view.elevationProvider.on("elevation-change",(e=>t(e.extent,e.spatialReference)))},o._connectComputationToTask=function(e){let t=null;const n={computation:e,interpolationInfo:{originalIntersection:b.create(),originalObserver:b.create(),originalTarget:b.create()}};return c.handlesGroup([this._updatingHandles.add((()=>e.inputPoints),(()=>{t=d.abortMaybe(t),t=s.createTask((async e=>{await p.ignoreAbortErrors(this._frameTask.schedule((()=>this._computeResult(n)),e))}))}),{initial:!0,equals:()=>!1}),c.makeHandle((()=>t=d.abortMaybe(t)))])},o._connectComputation=function(e){const t=this._computationHandles;t.has(e)||t.add([this._connectComputationToTarget(e),this._connectComputationToObserver(e),this._connectComputationToRenderSpaceObserver(e),this._connectComputationToCamera(e),this._connectComputationToSlicePlane(e),this._connectComputationToElevation(e),this._connectComputationToTask(e)],e)},o._disconnectComputation=function(e){this._computationHandles.remove(e)},o._onComputationCollectionChange=function({added:e,removed:t}){for(const n of t)this._disconnectComputation(n);for(const n of e)this._connectComputation(n)},o._onTargetCollectionChange=function({added:e,removed:t}){for(const n of t)this._removeTarget(n);for(const n of e)this._addTarget(n)},o._onCursorTargetChange=function(e,t){null!=t&&this._removeTarget(t),null!=e&&this._addTarget(e)},o._addTarget=function(e){this._computations.some((t=>t.target===e))||this._computations.add(new R.LineOfSightComputation({target:e}))},o._removeTarget=function(e){const t=this._computations.findIndex((t=>t.target===e));this._computations.removeAt(t)},o._connectObserver=function(){return c.handlesGroup([this._updatingHandles.add((()=>({observerPosition:null!=this.analysis.observer?this.analysis.observer.position:null,projectedObserverPosition:O.projectOrLoad(null!=this.analysis.observer?this.analysis.observer.position:null,this.view.spatialReference),observerElevationInfo:null!=this.analysis.observer?this.analysis.observer.elevationInfo:null,observerFeatureInfo:null!=this.analysis.observer?this.analysis.observer.feature:null})),(({observerPosition:e,projectedObserverPosition:t,observerElevationInfo:n,observerFeatureInfo:o})=>{null==t.pending?this._onObserverPositionChange(e,t.geometry,n,o,!0):this._updatingHandles.addPromise(t.pending)}),g.initial)])},o._connectComputations=function(){return this._updatingHandles.addOnCollectionChange((()=>this._computations),(e=>this._onComputationCollectionChange(e)),{initial:!0,final:!0})},o._connectTargets=function(){return c.handlesGroup([this._updatingHandles.addOnCollectionChange((()=>this.analysis.targets),(e=>this._onTargetCollectionChange(e)),{initial:!0,final:!0}),this._updatingHandles.add((()=>this.analysisViewData.cursorTarget),((e,t)=>{this._onCursorTargetChange(e,t)}))])},o._getEffectiveElevationInfo=function(e,t){return e.hasZ?t??{mode:"absolute-height",offset:0}:{mode:"on-the-ground",offset:0}},t._createClass(n,[{key:"updating",get:function(){return this._frameTask.updating||this._updatingHandles.updating}},{key:"priority",get:function(){return this._frameTask.priority},set:function(e){this._frameTask.priority=e}},{key:"_computations",get:function(){return this.analysisViewData.computations}},{key:"_elevationAlignedObserverPositionRenderSpace",get:function(){return this.analysisViewData.observerEngineLocation},set:function(e){this.analysisViewData.observerEngineLocation=e}},{key:"_screenPixelSize",get:function(){return this.view.state.camera.computeScreenPixelSizeAt(this._elevationAlignedObserverPositionRenderSpace)}},{key:"_isCameraDirty",get:function(){const e=this.analysisViewData.elevationAlignedObserver,{view:t}=this,{renderCoordsHelper:n}=t;if(null==e||null==n)return!1;const o=G;n.toRenderCoords(e,o);const i=t.state.camera.computeScreenPixelSizeAt(o);return Math.abs((i-this._screenPixelSize)/this._screenPixelSize)>V}}]),n}(a.EventedMixin(r)),n.__decorate([h.property({constructOnly:!0})],e.LineOfSightController.prototype,"analysis",void 0),n.__decorate([h.property({constructOnly:!0})],e.LineOfSightController.prototype,"analysisViewData",void 0),n.__decorate([h.property({constructOnly:!0})],e.LineOfSightController.prototype,"view",void 0),n.__decorate([h.property()],e.LineOfSightController.prototype,"updating",null),n.__decorate([h.property()],e.LineOfSightController.prototype,"priority",null),n.__decorate([h.property()],e.LineOfSightController.prototype,"updateOnCameraChange",void 0),n.__decorate([h.property()],e.LineOfSightController.prototype,"_computations",null),n.__decorate([h.property()],e.LineOfSightController.prototype,"_elevationAlignedObserverPositionRenderSpace",null),n.__decorate([h.property()],e.LineOfSightController.prototype,"_observerGroundOffsetRenderSpace",void 0),n.__decorate([h.property()],e.LineOfSightController.prototype,"_effectiveObserverElevationMode",void 0),n.__decorate([h.property()],e.LineOfSightController.prototype,"_observerFeatureId",void 0),n.__decorate([h.property()],e.LineOfSightController.prototype,"_screenPixelSize",null),n.__decorate([h.property({readOnly:!0})],e.LineOfSightController.prototype,"_updatingHandles",void 0),n.__decorate([h.property()],e.LineOfSightController.prototype,"_frameTask",void 0),n.__decorate([h.property()],e.LineOfSightController.prototype,"_isCameraDirty",null),e.LineOfSightController=n.__decorate([m.subclass(k)],e.LineOfSightController);const V=.1,G=b.create(),D=T.create(),N=I.empty(),x=.05;Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
