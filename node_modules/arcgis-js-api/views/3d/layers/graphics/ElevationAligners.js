/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/mat4","../../../../chunks/mat4f64","../../../../chunks/vec3","../../../../chunks/vec3f64","../../../../geometry/projection","./elevationAlignmentUtils","./graphicUtils","../../support/debugFlags","../../support/ElevationProvider","../../webgl-engine/lib/GeometryWithMapPositions","../../webgl-engine/lib/VertexAttribute"],(function(e,t,n,o,a,r,i,s,l,c,u,f){"use strict";function p(e,t,n,o,a){const r=e.stageObject,i=r.geometries;let s=0;for(const l of i){if(!u.isGeometryWithMapPositions(l))continue;const{update:e,averageGeometrySampledElevation:i}=y(l,t,n,o,a);s+=i,e&&r.geometryVertexAttrsUpdated(l)}return s/i.length}function m(e,n,a,i,c,u){const f=e.stageObject,p=n.centerPointInElevationSR;let m=0;if(f.usesVerticalDistanceToGround)i(p,E),s.updateVertexAttributeAuxpos1w(f,E.verticalDistanceToGround),m=E.sampledElevation;else{i(p,E);"absolute-height"!==n.mode&&(m=E.sampledElevation)}const g=t.copy(d,u??f.transformation),b=o.set(A,g[12],g[13],g[14]);l.TESTS_DISABLE_OPTIMIZATIONS?(I[0]=p.x,I[1]=p.y,I[2]=E.z,r.computeTranslationToOriginAndRotation(p.spatialReference,I,g,c.spatialReference)&&(u?t.copy(u,g):f.transformation=g)):c.setAltitudeOfTransformation(E.z,g);const S=T/c.unitInMeters;return(Math.abs(g[12]-b[0])>=S||Math.abs(g[13]-b[1])>=S||Math.abs(g[14]-b[2])>=S)&&(u?t.copy(u,g):f.transformation=g),m}const d=n.create();function g(e,t,n,a,i){const s=e.graphics3DSymbolLayer.lodRenderer;if(null==s)return 0;const c=t.centerPointInElevationSR;a(c,E);const u="absolute-height"!==t.mode?E.sampledElevation:0,f=s.instanceData,p=e.instanceIndex,m=v;f.getGlobalTransform(p,m);const d=o.set(A,m[12],m[13],m[14]);l.TESTS_DISABLE_OPTIMIZATIONS?(I[0]=c.x,I[1]=c.y,I[2]=E.z,r.computeTranslationToOriginAndRotation(c.spatialReference,I,m,i.spatialReference)&&f.setGlobalTransform(p,m)):i.setAltitudeOfTransformation(E.z,m);const g=T/i.unitInMeters;return(l.TESTS_DISABLE_OPTIMIZATIONS||Math.abs(m[12]-d[0])>=g||Math.abs(m[13]-d[1])>=g||Math.abs(m[14]-d[2])>=g)&&f.setGlobalTransform(p,m),u}function b(e,t,n,o,a){const r=e.stageObject,i=r.geometries;if(0===i.length)return 0;let s=0,l=null,c=0,p=!1;for(const m of i){if(!u.isGeometryWithMapPositions(m))continue;const e=m.vertexAttributes.get(f.VertexAttribute.POSITION);if(e!==l){const{update:r,averageGeometrySampledElevation:i}=y(m,t,n,o,a);c=i,l=e,p=r}p&&r.geometryVertexAttrsUpdated(m),s+=c}return s/i.length}const T=.01,I=a.create(),S=a.create(),h=a.create(),v=n.create(),A=a.create(),E=new i.SampleElevationInfo;function y(e,t,n,o,a){let i=!1;const s=e.shaderTransformation,u=t.requiresSampledElevationInfo;S[0]=s[12],S[1]=s[13],S[2]=s[14],e.invalidateBoundingInfo();const p=e.getMutableAttribute(f.VertexAttribute.POSITION),m=p.data,d=p.size,g=m.length/d,b=new c.SamplePosition(e.mapPositions,n);let v=0,A=0;for(let c=0;c<g;c++){if(h[0]=m[v],h[1]=m[v+1],h[2]=m[v+2],o(b,E),u&&(A+=E.sampledElevation),l.TESTS_DISABLE_OPTIMIZATIONS)m[v]=b.array[b.offset],m[v+1]=b.array[b.offset+1],m[v+2]=E.z,r.projectBuffer(m,n,v,m,a.spatialReference,v,1),m[v]-=S[0],m[v+1]-=S[1],m[v+2]-=S[2],i=!0;else{I[0]=m[v]+S[0],I[1]=m[v+1]+S[1],I[2]=m[v+2]+S[2],a.setAltitude(I,E.z),m[v]=I[0]-S[0],m[v+1]=I[1]-S[1],m[v+2]=I[2]-S[2];const e=T/a.unitInMeters;(Math.abs(h[0]-m[v])>=e||Math.abs(h[1]-m[v+1])>=e||Math.abs(h[2]-m[v+2])>=e)&&(i=!0)}v+=d,b.offset+=3}return A/=g,{update:i,averageGeometrySampledElevation:A}}e.perLodInstanceElevationAligner=g,e.perObjectElevationAligner=m,e.perVertexElevationAligner=p,e.sharedGeometryElevationAligner=b,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
