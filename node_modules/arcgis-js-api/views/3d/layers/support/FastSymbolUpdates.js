/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../core/has","../../../../core/mathUtils","../../../../chunks/mat3","../../../../chunks/mat3f64","../../../../chunks/mat4","../../../../chunks/mat4f64","../../../../chunks/vec3","../../../../chunks/vec3f64","../../../../renderers/support/lengthUtils","../../support/debugFlags","../../webgl-engine/core/shaderModules/interfaces"],(function(e,t,i,n,o,s,r,a,l,u,f,c,p){"use strict";var d,z;e.FastSizeType=void 0,(d=e.FastSizeType||(e.FastSizeType={}))[d.Undefined=0]="Undefined",d[d.DefinedSize=1]="DefinedSize",d[d.DefinedScale=2]="DefinedScale",e.FastRotationType=void 0,(z=e.FastRotationType||(e.FastRotationType={}))[z.Undefined=0]="Undefined",z[z.DefinedAngle=1]="DefinedAngle";let v=t._createClass((function(e){this.field=e})),S=function(i){function n(t){var n;return(n=i.call(this,t)||this).minSize=[0,0,0],n.maxSize=[0,0,0],n.offset=[0,0,0],n.factor=[0,0,0],n.type=[e.FastSizeType.Undefined,e.FastSizeType.Undefined,e.FastSizeType.Undefined],n}return t._inherits(n,i),t._createClass(n)}(v),y=function(e){function i(t){var i;return(i=e.call(this,t)||this).colors=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],i.values=[0,0,0,0,0,0,0,0],i}return t._inherits(i,e),t._createClass(i)}(v),m=function(e){function i(t){var i;return(i=e.call(this,t)||this).values=[0,0,0,0,0,0,0,0],i.opacityValues=[0,0,0,0,0,0,0,0],i}return t._inherits(i,e),t._createClass(i)}(v),h=function(e){function i(t){var i;return(i=e.call(this,t)||this).offset=[0,0,0],i.factor=[1,1,1],i.type=[0,0,0],i}return t._inherits(i,e),t._createClass(i)}(v),F=t._createClass((function(){}));function C(e){return null!=e}function b(e){return"number"==typeof e}function x(e){return"string"==typeof e}function T(e){return null==e||x(e)}function g(e,t){e&&e.push(t)}function V(e,t,i,n=a.create()){const o=e||0,s=t||0,l=i||0;return 0!==o&&r.rotateZ(n,n,-o/180*Math.PI),0!==s&&r.rotateX(n,n,s/180*Math.PI),0!==l&&r.rotateY(n,n,l/180*Math.PI),n}function D(t,i,n,o,s){const r=t.minSize,a=t.maxSize;if(t.expression)return g(s,"Could not convert size info: expression not supported"),!1;if(t.useSymbolValue){const t=o.symbolSize[n];return i.minSize[n]=t,i.maxSize[n]=t,i.offset[n]=i.minSize[n],i.factor[n]=0,i.type[n]=e.FastSizeType.DefinedSize,!0}if(C(t.field))return C(t.stops)?2===t.stops.length&&b(t.stops[0].size)&&b(t.stops[1].size)?(U(t.stops[0].size,t.stops[1].size,t.stops[0].value,t.stops[1].value,i,n),i.type[n]=e.FastSizeType.DefinedSize,!0):(g(s,"Could not convert size info: stops only supported with 2 elements"),!1):b(r)&&b(a)&&C(t.minDataValue)&&C(t.maxDataValue)?(U(r,a,t.minDataValue,t.maxDataValue,i,n),i.type[n]=e.FastSizeType.DefinedSize,!0):"unknown"===t.valueUnit?(g(s,"Could not convert size info: proportional size not supported"),!1):null!=f.meterIn[t.valueUnit]?(i.minSize[n]=-1/0,i.maxSize[n]=1/0,i.offset[n]=0,i.factor[n]=1/f.meterIn[t.valueUnit],i.type[n]=e.FastSizeType.DefinedSize,!0):(g(s,"Could not convert size info: scale-dependent size not supported"),!1);if(!C(t.field)){if(t.stops&&t.stops[0]&&b(t.stops[0].size))return i.minSize[n]=t.stops[0].size,i.maxSize[n]=t.stops[0].size,i.offset[n]=i.minSize[n],i.factor[n]=0,i.type[n]=e.FastSizeType.DefinedSize,!0;if(b(r))return i.minSize[n]=r,i.maxSize[n]=r,i.offset[n]=r,i.factor[n]=0,i.type[n]=e.FastSizeType.DefinedSize,!0}return g(s,"Could not convert size info: unsupported variant of sizeInfo"),!1}function U(e,t,i,n,o,s){const r=Math.abs(n-i)>0?(t-e)/(n-i):0;o.minSize[s]=r>0?e:t,o.maxSize[s]=r>0?t:e,o.offset[s]=e-i*r,o.factor[s]=r}function M(e,t,i,n){if(e.normalizationField||e.valueRepresentation)return g(n,"Could not convert size info: unsupported property"),null;if(!T(e.field))return g(n,"Could not convert size info: field is not a string"),null;if(t.size){if(e.field)if(t.size.field){if(e.field!==t.size.field)return g(n,"Could not convert size info: multiple fields in use"),null}else t.size.field=e.field}else t.size=new S(e.field);let o;switch(e.axis){case"width":return o=D(e,t.size,0,i,n),o?t:null;case"height":return o=D(e,t.size,2,i,n),o?t:null;case"depth":return o=D(e,t.size,1,i,n),o?t:null;case"width-and-depth":return o=D(e,t.size,0,i,n),o&&D(e,t.size,1,i,n),o?t:null;case null:case void 0:case"all":return o=D(e,t.size,0,i,n),o=o&&D(e,t.size,1,i,n),o=o&&D(e,t.size,2,i,n),o?t:null;default:return g(n,`Could not convert size info: unknown axis "${e.axis}""`),null}}function _(t,i,n){for(let s=0;s<3;++s){let n=i.unitInMeters;t.type[s]===e.FastSizeType.DefinedSize&&(n*=i.modelSize[s],t.type[s]=e.FastSizeType.DefinedScale),t.minSize[s]=t.minSize[s]/n,t.maxSize[s]=t.maxSize[s]/n,t.offset[s]=t.offset[s]/n,t.factor[s]=t.factor[s]/n}let o;if(t.type[0]!==e.FastSizeType.Undefined)o=0;else if(t.type[1]!==e.FastSizeType.Undefined)o=1;else{if(t.type[2]===e.FastSizeType.Undefined)return g(n,"No size axis contains a valid size or scale"),!1;o=2}for(let s=0;s<3;++s)t.type[s]===e.FastSizeType.Undefined&&(t.minSize[s]=t.minSize[o],t.maxSize[s]=t.maxSize[o],t.offset[s]=t.offset[o],t.factor[s]=t.factor[o],t.type[s]=t.type[o]);return!0}function w(e,t,i){e[4*t]=i.r/255,e[4*t+1]=i.g/255,e[4*t+2]=i.b/255,e[4*t+3]=i.a}function I(e,t,i){if(e.normalizationField)return g(i,"Could not convert color info: unsupported property"),null;if(x(e.field)){if(!e.stops)return g(i,"Could not convert color info: missing stops or colors"),null;{if(e.stops.length>8)return g(i,"Could not convert color info: too many color stops"),null;t.color=new y(e.field);const n=e.stops;for(let e=0;e<8;++e){const i=n[Math.min(e,n.length-1)];t.color.values[e]=i.value,w(t.color.colors,e,i.color)}}}else{if(!(e.stops&&e.stops.length>=0))return g(i,"Could not convert color info: no field and no colors/stops"),null;{const i=e.stops&&e.stops.length>=0&&e.stops[0].color;t.color={field:null,values:[0,0,0,0,0,0,0,0],colors:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]};for(let e=0;e<8;e++)t.color.values[e]=1/0,w(t.color.colors,e,i)}}return t}function P(e,t,i){if(e.normalizationField)return g(i,"Could not convert opacity info: unsupported property"),null;if(x(e.field)){if(!e.stops)return g(i,"Could not convert opacity info: missing stops or opacities"),null;{if(e.stops.length>8)return g(i,"Could not convert opacity info: too many opacity stops"),null;t.opacity=new m(e.field);const n=e.stops;for(let e=0;e<8;++e){const i=n[Math.min(e,n.length-1)];t.opacity.values[e]=i.value,t.opacity.opacityValues[e]=i.opacity}}}else{if(!(e.stops&&e.stops.length>=0))return g(i,"Could not convert opacity info: no field and no opacities/stops"),null;{const i=e.stops&&e.stops.length>=0?e.stops[0].opacity:0;t.opacity={field:null,values:[0,0,0,0,0,0,0,0],opacityValues:[0,0,0,0,0,0,0,0]};for(let e=0;e<8;e++)t.opacity.values[e]=1/0,t.opacity.opacityValues[e]=i}}return t}function k(e,t,i){const n=2===i&&"arithmetic"===e.rotationType;t.offset[i]=n?90:0,t.factor[i]=n?-1:1,t.type[i]=1}function R(e,t,i){if(!x(e.field))return g(i,"Could not convert rotation info: field is not a string"),null;if(t.rotation){if(e.field)if(t.rotation.field){if(e.field!==t.rotation.field)return g(i,"Could not convert rotation info: multiple fields in use"),null}else t.rotation.field=e.field}else t.rotation={field:e.field,offset:[0,0,0],factor:[1,1,1],type:[0,0,0]};switch(e.axis){case"tilt":return k(e,t.rotation,0),t;case"roll":return k(e,t.rotation,1),t;case null:case void 0:case"heading":return k(e,t.rotation,2),t;default:return g(i,`Could not convert rotation info: unknown axis "${e.axis}""`),null}}let A=t._createClass((function(e,t=[1,1,1],i=[1,1,1],n=1,o=[0,0,0],s=[1,1,1],r=[0,0,0]){this.supports=e,this.modelSize=t,this.symbolSize=i,this.unitInMeters=n,this.anchor=o,this.scale=s,this.rotation=r}));function E(e,t,i){if(!e)return null;const n=e.reduce(((e,n)=>{if(!e)return e;if(n.valueExpression)return g(i,"Could not convert visual variables: arcade expressions not supported"),null;switch(n.type){case"size":return t.supports.size?M(n,e,t,i):e;case"color":return t.supports.color?I(n,e,i):e;case"opacity":return t.supports.opacity?P(n,e,i):null;case"rotation":return t.supports.rotation?R(n,e,i):e;default:return null}}),new F);return!(e.length>0&&n)||n.size||n.color||n.opacity||n.rotation?n&&n.size&&!_(n.size,t,i)?null:n:null}let O=t._createClass((function(e,t,i){this.visualVariables=e,this.materialParameters=t,this.requiresShaderTransformation=i}));function q(e,t){if(!e)return null;if(c.TESTS_DISABLE_FAST_UPDATES)return null;const i=E(e.visualVariables,t);return i?new O(i,j(i,t),!!i.size):null}function B(e,t,i){if(!t||!e)return!1;const n=e.visualVariables,o=E(t.visualVariables,i);return!!o&&(!!(N(n.size,o.size,"size")&&N(n.color,o.color,"color")&&N(n.rotation,o.rotation,"rotation")&&N(n.opacity,o.opacity,"opacity"))&&(e.visualVariables=o,e.materialParameters=j(o,i),e.requiresShaderTransformation=!!o.size,!0))}function N(e,t,i){if(!!e!=!!t)return!1;if(e&&e.field!==t?.field)return!1;if(e&&"rotation"===i){const i=e,n=t;for(let e=0;e<3;e++)if(i.type[e]!==n.type[e]||i.offset[e]!==n.offset[e]||i.factor[e]!==n.factor[e])return!1}return!0}let $=function(e){function i(t){var i;return(i=e.call(this)||this).vvSize=t?.size??null,i.vvColor=t?.color??null,i.vvOpacity=t?.opacity??null,i}return t._inherits(i,e),t._createClass(i)}(p.NoParameters);function j(e,t){const i=new $(e);return i.vvSize&&(i.vvSymbolAnchor=t.anchor,r.identity(G),V(t.rotation[2],t.rotation[0],t.rotation[1],G),i.vvSymbolRotationMatrix=i.vvSymbolRotationMatrix||s.create(),o.fromMat4(i.vvSymbolRotationMatrix,G)),i}function H(e,t,i){if(!e.vvSize)return i;r.copy(Y,i);const o=e.vvSymbolRotationMatrix;r.set(G,o[0],o[1],o[2],0,o[3],o[4],o[5],0,o[6],o[7],o[8],0,0,0,0,1),r.multiply(Y,Y,G);for(let s=0;s<3;++s){const i=e.vvSize.offset[s]+t[0]*e.vvSize.factor[s];Z[s]=n.clamp(i,e.vvSize.minSize[s],e.vvSize.maxSize[s])}return r.scale(Y,Y,Z),r.translate(Y,Y,e.vvSymbolAnchor),Y}function L(e,t,i){if(t.vvSize)for(let o=0;o<3;++o){const s=t.vvSize.offset[o]+i[0]*t.vvSize.factor[o];e[o]=n.clamp(s,t.vvSize.minSize[o],t.vvSize.maxSize[o])}else l.set(e,1,1,1)}function X(e,t){const i=null==e?0:t.attributes[e];return"number"==typeof i&&isFinite(i)?i:0}const Y=a.create(),Z=u.create(),G=a.create();e.ConvertOptions=A,e.FastColorInfo=y,e.FastOpacityInfo=m,e.FastRotationInfo=h,e.FastSizeInfo=S,e.FastSymbolUpdatesState=O,e.FastVisualVariables=F,e.VisualVariablesParameters=$,e.convertVisualVariables=E,e.evaluateModelTransform=H,e.evaluateModelTransformScale=L,e.getAttributeValue=X,e.getMaterialParameters=j,e.initFastSymbolUpdatesState=q,e.updateFastSymbolUpdatesState=B,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
