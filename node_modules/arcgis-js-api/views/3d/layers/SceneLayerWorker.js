/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["require","exports","../../../geometry/SpatialReference","../../../geometry/support/DoubleArray","../../../geometry/support/MeshGeoreferencedRelativeVertexSpace","../../../geometry/support/MeshGeoreferencedVertexSpace","../../../geometry/support/MeshLocalVertexSpace","../../../chunks/vec32","../../../libs/i3s/enums","../../../libs/i3s/I3SModule","./i3s/I3SNode"],(function(e,t,r,o,n,i,s,a,f,c,l){"use strict";async function u(e){await x();const t=[e.geometryBuffer];return{result:I(e,t),transferList:t}}async function d(e){await x();const t=[e.geometryBuffer],{geometryBuffer:r}=e,o=r.byteLength,n=w._malloc(o),i=new Uint8Array(w.HEAPU8.buffer,n,o);i.set(new Uint8Array(r));const s=w.dracoDecompressPointCloudData(n,i.byteLength);if(w._free(n),s.error.length>0)throw new Error(`i3s.wasm: ${s.error}`);const a=s.featureIds?.length>0?s.featureIds.slice():null,f=s.positions.slice();return a&&t.push(a.buffer),t.push(f.buffer),{result:{positions:f,featureIds:a},transferList:t}}async function y(e){await x(),S(e);const t={buffer:e.buffer};return{result:t,transferList:[t.buffer]}}async function m(e){await x(),M(e)}async function p(e){await x(),w.setLegacySchema(e.context,e.jsonSchema)}async function b(t){const{localMatrix:a,origin:f,positions:c,vertexSpace:l,local:u}=t,d=r.fromJSON(t.inSpatialReference),y=r.fromJSON(t.outSpatialReference),m={georeferenced:i,georeferencedRelative:n,local:s}[l.type].fromJSON(l);let p;if("georeferenced"===m.type){const{projectBuffer:t,initializeProjection:r}=await new Promise(((t,r)=>e(["../../../geometry/projection"],t,r)));await r(d,y),p=new Float64Array(c.length),t(c,d,0,p,y,0,p.length/3)}else{const{project:t}=await new Promise(((t,r)=>e(["../../../geometry/support/meshUtils/georeference"],t,r)));p=o.toFloat64Array(t({positions:c,transform:a?{localMatrix:a}:void 0,vertexSpace:m,inSpatialReference:d,outSpatialReference:y,local:u}))}const b=p.length,[h,g,E]=f;for(let e=0;e<b;e+=3)p[e]-=h,p[e+1]-=g,p[e+2]-=E;return{result:{projected:p,original:c},transferList:[p.buffer,c.buffer]}}async function h({normalMatrix:e,normals:t}){const r=new Float32Array(t.length);return a.transformMat3(r,t,e),a.normalize(r,r),{result:{transformed:r,original:t},transferList:[r.buffer,t.buffer]}}function g(e){L(e)}let E,w;function M(e){const t=e.modifications,r=w._malloc(8*t.length),o=new Float64Array(w.HEAPU8.buffer,r,t.length);for(let n=0;n<t.length;++n)o[n]=t[n];w.setModifications(e.context,r,t.length,e.isGeodetic),w._free(r)}function I(e,t){if(!w)return null;const{context:r,localOrigin:o,globalTrafo:n,mbs:i,obb:s,elevationOffset:a,geometryBuffer:c,geometryDescriptor:l,indexToVertexProjector:u,vertexToRenderProjector:d}=e,y=w._malloc(c.byteLength),m=33,p=w._malloc(m*Float64Array.BYTES_PER_ELEMENT),b=new Uint8Array(w.HEAPU8.buffer,y,c.byteLength);b.set(new Uint8Array(c));const h=new Float64Array(w.HEAPU8.buffer,p,m);_(h,o);let g=h.byteOffset+3*h.BYTES_PER_ELEMENT,E=new Float64Array(h.buffer,g);_(E,n),g+=16*h.BYTES_PER_ELEMENT,E=new Float64Array(h.buffer,g),_(E,i),g+=4*h.BYTES_PER_ELEMENT,null!=s&&(E=new Float64Array(h.buffer,g),_(E,s.center),g+=3*h.BYTES_PER_ELEMENT,E=new Float64Array(h.buffer,g),_(E,s.halfSize),g+=3*h.BYTES_PER_ELEMENT,E=new Float64Array(h.buffer,g),_(E,s.quaternion));const M=l,I={isDraco:!1,isLegacy:!1,color:e.layouts.some((e=>e.some((e=>"color"===e.name)))),normal:e.needNormals&&e.layouts.some((e=>e.some((e=>"normalCompressed"===e.name)))),uv0:e.layouts.some((e=>e.some((e=>"uv0"===e.name)))),uvRegion:e.layouts.some((e=>e.some((e=>"uvRegion"===e.name)))),featureIndex:M.featureIndex},A=w.process(r,!!e.obb,y,b.byteLength,M,I,p,a,u,d,e.normalReferenceFrame);if(w._free(p),w._free(y),A.error.length>0)throw new Error(`i3s.wasm: ${A.error}`);if(A.discarded)return null;const S=A.componentOffsets.length>0?A.componentOffsets.slice():null,L=A.featureIds.length>0?A.featureIds.slice():null,x=A.anchorIds.length>0?Array.from(A.anchorIds):null,P=A.anchors.length>0?Array.from(A.anchors):null,T=A.interleavedVertedData.slice().buffer,R=A.indicesType===f.IndexType.Int16?new Uint16Array(A.indices.buffer,A.indices.byteOffset,A.indices.byteLength/2).slice():new Uint32Array(A.indices.buffer,A.indices.byteOffset,A.indices.byteLength/4).slice(),O=A.positions.slice(),F=A.positionIndicesType===f.IndexType.Int16?new Uint16Array(A.positionIndices.buffer,A.positionIndices.byteOffset,A.positionIndices.byteLength/2).slice():new Uint32Array(A.positionIndices.buffer,A.positionIndices.byteOffset,A.positionIndices.byteLength/4).slice(),N={layout:e.layouts[0],interleavedVertexData:T,indices:R,hasColors:A.hasColors,hasModifications:A.hasModifications,positionData:{data:O,indices:F}};return L&&t.push(L.buffer),S&&t.push(S.buffer),t.push(T),t.push(R.buffer),t.push(O.buffer),t.push(F.buffer),{componentOffsets:S,featureIds:L,anchorIds:x,anchors:P,transformedGeometry:N,obb:A.obb}}function A(e){return 0===e?l.NodeIMModificationImpact.Unmodified:1===e?l.NodeIMModificationImpact.PotentiallyModified:2===e?l.NodeIMModificationImpact.Culled:l.NodeIMModificationImpact.Unknown}function S(e){const{context:t,buffer:r}=e,o=w._malloc(r.byteLength),n=r.byteLength/Float64Array.BYTES_PER_ELEMENT,i=new Float64Array(w.HEAPU8.buffer,o,n),s=new Float64Array(r);i.set(s),w.filterOBBs(t,o,n),s.set(i),w._free(o)}function L(e){w&&(w.destroy(e),w=null)}function _(e,t){for(let r=0;r<t.length;++r)e[r]=t[r]}function x(){return w?Promise.resolve():(E||(E=c.get().then((e=>{w=e,E=null}))),E)}const P={transform:I,destroy:L};t.destroyContext=g,t.dracoDecompressPointCloudData=d,t.filterObbsForModifications=y,t.filterObbsForModificationsSync=S,t.initialize=x,t.interpretObbModificationResults=A,t.process=u,t.project=b,t.setLegacySchema=p,t.setModifications=m,t.setModificationsSync=M,t.test=P,t.transformNormals=h,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
