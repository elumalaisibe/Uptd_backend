/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["exports","../../chunks/_rollupPluginBabelHelpers","../../core/Error","../../core/has","../../core/mathUtils","./checkWebGLError","./contextUtils","./enums","./GLObjectType","./TextureDescriptor","./ValidatedTextureDescriptor"],(function(t,e,i,r,o,s,n,a,p,l,c){"use strict";const d=4;let h=function(){function t(t,e=null,r=null){if(this.type=p.GLObjectType.Texture,this._glName=null,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._wasImmutablyAllocated=!1,"context"in t)this._descriptor=t,r=e;else{const r=c.ValidatedTextureDescriptor.validate(t,e);if(!r)throw new i("Texture descriptor invalid");this._descriptor=r}if(this._descriptor.context.instanceCounter.increment(a.ResourceType.Texture,this),this._descriptor.context.type!==n.ContextType.WEBGL2&&(this._descriptor.isImmutable&&(this._descriptor.isImmutable=!1),w(this._descriptor.target)))throw new i("3D and array textures are not supported in WebGL1");this._descriptor.target===a.TextureType.TEXTURE_CUBE_MAP?this._setDataCubeMap(r):this.setData(r)}var r=t.prototype;return r.dispose=function(){this._descriptor.context.gl&&this._glName&&(this._descriptor.context.unbindTexture(this),this._descriptor.context.gl.deleteTexture(this._glName),this._glName=null,this._descriptor.context.instanceCounter.decrement(a.ResourceType.Texture,this))},r.release=function(){this.dispose()},r.resize=function(t,e){const r=this._descriptor;if(r.width!==t||r.height!==e){if(this._wasImmutablyAllocated)throw new i("Immutable textures can't be resized!");r.width=t,r.height=e,this._descriptor.target===a.TextureType.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}},r._setDataCubeMap=function(t=null){for(let e=a.TextureType.TEXTURE_CUBE_MAP_POSITIVE_X;e<=a.TextureType.TEXTURE_CUBE_MAP_NEGATIVE_Z;e++)this._setData(t,e)},r.setData=function(t){this._setData(t)},r._setData=function(e,r){if(!this._descriptor.context||!this._descriptor.context.gl)return;const o=this._descriptor.context.gl;s.checkWebGLError(o),this._glName||(this._glName=o.createTexture()),void 0===e&&(e=null);const n=this._descriptor,a=r??n.target,p=w(a);null===e&&(n.width=n.width||d,n.height=n.height||d,p&&(n.depth=n.depth??1));const l=this._descriptor.context.bindTexture(this,t.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(t.TEXTURE_UNIT_FOR_UPDATES),u(this._descriptor.context,n),this._configurePixelStorage(),s.checkWebGLError(o);const c=this._deriveInternalFormat();if(M(e)){let t=e.width,i=e.height;const r=1;e instanceof HTMLVideoElement&&(t=e.videoWidth,i=e.videoHeight),n.width&&n.height,p&&n.depth,n.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(a,c,n.hasMipmap,t,i,r),this._texImage(a,0,c,t,i,r,e),s.checkWebGLError(o),n.hasMipmap&&this.generateMipmap(),n.width||(n.width=t),n.height||(n.height=i),p&&!n.depth&&(n.depth=r)}else{const{width:t,height:r,depth:l}=n;if(null==t||null==r)throw new i("Width and height must be specified!");if(p&&null==l)throw new i("Depth must be specified!");if(n.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(a,c,n.hasMipmap,t,r,l),E(e)){const s=e.levels,p=A(a,t,r,l),d=Math.min(p-1,s.length-1);null!=this._descriptor.context.gl2?o.texParameteri(n.target,this._descriptor.context.gl2.TEXTURE_MAX_LEVEL,d):n.hasMipmap=n.hasMipmap&&p===s.length;const h=c;if(!g(h))throw new i("Attempting to use compressed data with an uncompressed format!");this._forEachMipmapLevel(((t,e,i,r)=>{const o=s[Math.min(t,s.length-1)];this._compressedTexImage(a,t,h,e,i,r,o)}),d)}else this._texImage(a,0,c,t,r,l,e),s.checkWebGLError(o),n.hasMipmap&&this.generateMipmap()}_(o,this._descriptor),m(o,this._descriptor),T(this._descriptor.context,this._descriptor),s.checkWebGLError(o),this._descriptor.context.bindTexture(l,t.TEXTURE_UNIT_FOR_UPDATES)},r.updateData=function(e,r,o,s,n,a,p=0){a||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const l=this._descriptor.context.gl,c=this._descriptor.context.gl2,d=this._descriptor,h=this._deriveInternalFormat(),{pixelFormat:u,dataType:_,target:m,isImmutable:T}=d;if(T&&!this._wasImmutablyAllocated)throw new i("Cannot update immutable texture before allocation!");const x=this._descriptor.context.bindTexture(this,t.TEXTURE_UNIT_FOR_UPDATES,!0);if((r<0||o<0||s>d.width||n>d.height||r+s>d.width||o+n>d.height)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage(),p){if(!c)return void console.error("Webgl2 must be enabled to use dataRowOffset!");l.pixelStorei(c.UNPACK_SKIP_ROWS,p)}if(M(a)?c?c.texSubImage2D(m,e,r,o,s,n,u,_,a):l.texSubImage2D(m,e,r,o,u,_,a):E(a)?l.compressedTexSubImage2D(m,e,r,o,s,n,h,a.levels[e]):l.texSubImage2D(m,e,r,o,s,n,u,_,a),p){if(!c)return void console.error("Webgl2 must be enabled to use dataRowOffset!");l.pixelStorei(c.UNPACK_SKIP_ROWS,0)}this._descriptor.context.bindTexture(x,t.TEXTURE_UNIT_FOR_UPDATES)},r.updateData3D=function(e,r,o,s,n,a,p,l){l||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const c=this._descriptor.context.gl2;if(null==c)throw new i("3D textures are not supported in WebGL1");const d=this._descriptor,h=this._deriveInternalFormat(),{pixelFormat:u,dataType:_,isImmutable:m,target:T}=d;if(m&&!this._wasImmutablyAllocated)throw new i("Cannot update immutable texture before allocation!");w(T)||console.warn("Attempting to set 3D texture data on a non-3D texture");const x=this._descriptor.context.bindTexture(this,t.TEXTURE_UNIT_FOR_UPDATES);if(this._descriptor.context.setActiveTexture(t.TEXTURE_UNIT_FOR_UPDATES),(r<0||o<0||s<0||n>d.width||a>d.height||p>d.depth||r+n>d.width||o+a>d.height||s+p>d.depth)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage(),E(l))l=l.levels[e],c.compressedTexSubImage3D(T,e,r,o,s,n,a,p,h,l);else{const t=l;c.texSubImage3D(T,e,r,o,s,n,a,p,u,_,t)}this._descriptor.context.bindTexture(x,t.TEXTURE_UNIT_FOR_UPDATES)},r.generateMipmap=function(){const e=this._descriptor;if(!e.hasMipmap){if(this._wasImmutablyAllocated)throw new i("Cannot add mipmaps to immutable texture after allocation");e.hasMipmap=!0,this._samplingModeDirty=!0,u(this._descriptor.context,e)}e.samplingMode===a.TextureSamplingMode.LINEAR?(this._samplingModeDirty=!0,e.samplingMode=a.TextureSamplingMode.LINEAR_MIPMAP_NEAREST):e.samplingMode===a.TextureSamplingMode.NEAREST&&(this._samplingModeDirty=!0,e.samplingMode=a.TextureSamplingMode.NEAREST_MIPMAP_NEAREST);const r=this._descriptor.context.bindTexture(this,t.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(t.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.gl.generateMipmap(e.target),this._descriptor.context.bindTexture(r,t.TEXTURE_UNIT_FOR_UPDATES)},r.setSamplingMode=function(t){t!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=t,this._samplingModeDirty=!0)},r.setWrapMode=function(t){t!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=t,u(this._descriptor.context,this._descriptor),this._wrapModeDirty=!0)},r.applyChanges=function(){const t=this._descriptor.context.gl,e=this._descriptor;this._samplingModeDirty&&(_(t,e),this._samplingModeDirty=!1),this._wrapModeDirty&&(m(t,e),this._wrapModeDirty=!1)},r._deriveInternalFormat=function(){if(this._descriptor.context.type===n.ContextType.WEBGL1)return this._descriptor.internalFormat=this._descriptor.pixelFormat;if(null!=this._descriptor.internalFormat)return this._descriptor.internalFormat===a.PixelFormat.DEPTH_STENCIL&&(this._descriptor.internalFormat=a.PixelFormat.DEPTH24_STENCIL8),this._descriptor.internalFormat;switch(this._descriptor.dataType){case a.PixelType.FLOAT:switch(this._descriptor.pixelFormat){case a.PixelFormat.RGBA:return this._descriptor.internalFormat=a.SizedPixelFormat.RGBA32F;case a.PixelFormat.RGB:return this._descriptor.internalFormat=a.SizedPixelFormat.RGB32F;default:throw new i("Unable to derive format")}case a.PixelType.UNSIGNED_BYTE:switch(this._descriptor.pixelFormat){case a.PixelFormat.RGBA:return this._descriptor.internalFormat=a.SizedPixelFormat.RGBA8;case a.PixelFormat.RGB:return this._descriptor.internalFormat=a.SizedPixelFormat.RGB8}}return this._descriptor.internalFormat=this._descriptor.pixelFormat===a.PixelFormat.DEPTH_STENCIL?a.PixelFormat.DEPTH24_STENCIL8:this._descriptor.pixelFormat},r._configurePixelStorage=function(){const t=this._descriptor.context.gl,{unpackAlignment:e,flipped:i,preMultiplyAlpha:r}=this._descriptor;t.pixelStorei(t.UNPACK_ALIGNMENT,e),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,i?1:0),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,r?1:0)},r._texStorage=function(t,e,r,o,s,n){const a=this._descriptor.context.gl2;if(null==a)throw new i("Immutable textures are not supported in WebGL1");if(!x(e))throw new i("Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;const p=r?A(t,o,s,n):1;if(w(t)){if(null==n)throw new i("Missing depth dimension for 3D texture upload");a.texStorage3D(t,p,e,o,s,n)}else a.texStorage2D(t,p,e,o,s);this._wasImmutablyAllocated=!0},r._texImage=function(t,e,r,o,s,a,p){const l=this._descriptor.context.gl,c=w(t),{isImmutable:d,pixelFormat:h,dataType:u}=this._descriptor,_=this._descriptor.context.type===n.ContextType.WEBGL2,m=_?l:null;if(_||!M(p))if(d){if(null!=p){const r=p;if(c){if(null==a)throw new i("Missing depth dimension for 3D texture upload");m.texSubImage3D(t,e,0,0,0,o,s,a,h,u,r)}else l.texSubImage2D(t,e,0,0,o,s,h,u,r)}}else{const n=p;if(c){if(null==a)throw new i("Missing depth dimension for 3D texture upload");m.texImage3D(t,e,r,o,s,a,0,h,u,n)}else l.texImage2D(t,e,r,o,s,0,h,u,n)}else l.texImage2D(t,0,r,h,u,p)},r._compressedTexImage=function(t,e,r,o,s,a,p){const l=this._descriptor.context.gl;let c=null;const d=w(t),h=this._descriptor.isImmutable;if(d){if(this._descriptor.context.type!==n.ContextType.WEBGL2)throw new i("3D textures are not supported in WebGL1");c=l}if(h){if(null!=p)if(d){if(null==a)throw new i("Missing depth dimension for 3D texture upload");c.compressedTexSubImage3D(t,e,0,0,0,o,s,a,r,p)}else l.compressedTexSubImage2D(t,e,0,0,o,s,r,p)}else if(d){if(null==a)throw new i("Missing depth dimension for 3D texture upload");c.compressedTexImage3D(t,e,r,o,s,a,0,p)}else l.compressedTexImage2D(t,e,r,o,s,0,p)},r._forEachMipmapLevel=function(t,e=1/0){let{width:r,height:o,depth:s,hasMipmap:n,target:p}=this._descriptor;const l=p===a.TextureType.TEXTURE_3D;if(null==r||null==o||l&&null==s)throw new i("Missing texture dimensions for mipmap calculation");for(let i=0;t(i,r,o,s),n&&(1!==r||1!==o||l&&1!==s)&&!(i>=e);++i)r=Math.max(1,r>>1),o=Math.max(1,o>>1),l&&(s=Math.max(1,s>>1))},e._createClass(t,[{key:"glName",get:function(){return this._glName}},{key:"descriptor",get:function(){return this._descriptor}},{key:"gpuMemoryUsage",get:function(){return P.delete(this),l.estimateMemory(this._descriptor)}},{key:"isDirty",get:function(){return this._samplingModeDirty||this._wrapModeDirty}}]),t}();function u(t,e){(null!=e.width&&e.width<0||null!=e.height&&e.height<0||null!=e.depth&&e.depth<0)&&console.error("Negative dimension parameters are not allowed!");const i=t.type===n.ContextType.WEBGL2;if(i||!e.isImmutable&&!w(e.target)||console.error("Immutable and 3D-like textures are not supported in WebGL1!"),i)return;null!=e.width&&o.isPowerOfTwo(e.width)&&null!=e.height&&o.isPowerOfTwo(e.height)||("number"==typeof e.wrapMode?e.wrapMode!==a.TextureWrapMode.CLAMP_TO_EDGE&&console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"):e.wrapMode.s===a.TextureWrapMode.CLAMP_TO_EDGE&&e.wrapMode.t===a.TextureWrapMode.CLAMP_TO_EDGE||console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"),e.hasMipmap&&console.error("Mipmapping requires power-of-two textures!"))}function _(t,e){let i=e.samplingMode,r=e.samplingMode;i===a.TextureSamplingMode.LINEAR_MIPMAP_NEAREST||i===a.TextureSamplingMode.LINEAR_MIPMAP_LINEAR?(i=a.TextureSamplingMode.LINEAR,e.hasMipmap||(r=a.TextureSamplingMode.LINEAR)):i!==a.TextureSamplingMode.NEAREST_MIPMAP_NEAREST&&i!==a.TextureSamplingMode.NEAREST_MIPMAP_LINEAR||(i=a.TextureSamplingMode.NEAREST,e.hasMipmap||(r=a.TextureSamplingMode.NEAREST)),t.texParameteri(e.target,t.TEXTURE_MAG_FILTER,i),t.texParameteri(e.target,t.TEXTURE_MIN_FILTER,r)}function m(t,e){"number"==typeof e.wrapMode?(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode)):(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode.s),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode.t))}function T(t,e){const i=t.capabilities.textureFilterAnisotropic;if(!i)return;t.gl.texParameterf(e.target,i.TEXTURE_MAX_ANISOTROPY,e.maxAnisotropy??1)}function x(t){return t in a.SizedPixelFormat}function g(t){return t in a.CompressedTextureFormat}function E(t){return null!=t&&"type"in t&&"compressed"===t.type}function f(t){return null!=t&&"byteLength"in t}function M(t){return null!=t&&!E(t)&&!f(t)}function w(t){return t===a.TextureType.TEXTURE_3D||t===a.TextureType.TEXTURE_2D_ARRAY}function A(t,e,i,r=1){let o=Math.max(e,i);return t===a.TextureType.TEXTURE_3D&&(o=Math.max(o,r)),Math.round(Math.log(o)/Math.LN2)+1}function I(){const t=new Array;return P.forEach(((e,i)=>t.push([i.gpuMemoryUsage,e]))),P.clear(),t.sort(((t,e)=>e[0]-t[0])),t.reduce(((t,e)=>`${t}\n\n${Math.round(e[0]/1024)}KB: ${e[1]}`),"")}h.TEXTURE_UNIT_FOR_UPDATES=0;const P=new Map;t.Texture=h,t.clearUnestimatedTextures=I,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
