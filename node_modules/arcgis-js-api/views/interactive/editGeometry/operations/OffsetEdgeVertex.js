/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["exports","../../../../chunks/_rollupPluginBabelHelpers","../../../../core/mathUtils","../../../../chunks/vec2","../../../../chunks/vec2f64","../../../../chunks/vec3","../../../../chunks/vec3f64","../../../../geometry/support/plane","../../../../geometry/support/vector","../../../support/geometry2dUtils"],(function(t,e,i,n,s,r,o,c,a,h){"use strict";let l=function(){function i(t,e,i,n=0,s=p.IMMEDIATE){this._helper=t,this._planeType=e,this._edge=i,this.distance=n,this._plane=c.create(),this._offsetPlane=c.create(),this._minDistance=-1/0,this._maxDistance=1/0,this._selectedArrow=1,s===p.IMMEDIATE&&this._initialize()}var l=i.prototype;return l._initialize=function(){this._initializeNeighbors(),this._initializePlane(),this._initializeDistanceConstraints()},l._initializeNeighbors=function(){const t=this._toXYZ(this._edge.leftVertex.pos),e=this._toXYZ(this._edge.leftVertex.leftEdge?.leftVertex?.pos),i=this._toXYZ(this._edge.rightVertex.pos),n=this._toXYZ(this._edge.rightVertex.rightEdge?.rightVertex?.pos);this._edgeDirection=r.direction(o.create(),t,i),this._left=this._computeNeighbor(t,e,this._edgeDirection),this._right=this._computeNeighbor(i,n,this._edgeDirection)},l._toXYZ=function(t){return null!=t?this._helper.toXYZ(t):null},l._pointToXYZ=function(t){return this._toXYZ(this._helper.pointToVector(t))},l._computeNeighbor=function(t,e,i){if(null==e)return{start:t,end:e,direction:o.fromValues(-i[1],i[0],0),isOriginalDirection:!0};const n=r.direction(o.create(),t,e),s=!this._passesBisectingAngleThreshold(n,i);return{start:t,end:e,direction:s?this._bisectVectorsPerpendicular(i,n):n,isOriginalDirection:!s}},l._passesBisectingAngleThreshold=function(t,e){const i=Math.abs(a.angle(e,t));return i>=_&&i<=Math.PI-_},l._bisectVectorsPerpendicular=function(t,e){const i=r.dot(t,e)<0?t:r.negate(o.create(),t),n=Math.abs(r.dot(i,e));if(!(n<u||n>1-u))return this._bisectDirection(i,e);const s=r.cross(o.create(),i,[0,0,1]);return r.normalize(s,s)},l._bisectDirection=function(t,e){const i=r.add(o.create(),t,e);return r.normalize(i,i)},l._initializePlane=function(){const t=this._computeNormalDirection(this._left),e=this._computeNormalDirection(this._right);r.dot(t,e)<0&&r.negate(e,e),c.fromPositionAndNormal(this._left.start,this._bisectDirection(t,e),this._plane)},l._computeNormalDirection=function(e){const i=r.cross(o.create(),e.direction,this._edgeDirection);r.normalize(i,i);const n=r.cross(o.create(),this._edgeDirection,i);return this._planeType===t.PlaneType.XY&&(n[2]=0),r.normalize(n,n)},l._initializeDistanceConstraints=function(){null==this._left.end||this.requiresSplitEdgeLeft||this._updateDistanceConstraint(c.signedDistance(this._plane,this._left.end)),null==this._right.end||this.requiresSplitEdgeRight||this._updateDistanceConstraint(c.signedDistance(this._plane,this._right.end)),this._updateIntersectDistanceConstraint(this._plane)},l._updateDistanceConstraint=function(t){t<=0&&(this._minDistance=Math.max(this._minDistance,t)),t>=0&&(this._maxDistance=Math.min(this._maxDistance,t))},l._updateIntersectDistanceConstraint=function(t){const e=c.normal(t),i=this._edgeDirection,a=r.add(o.create(),this._left.start,this._left.direction),l=r.add(o.create(),this._right.start,this._right.direction),_=this._pointInBasis2D(s.create(),e,i,this._left.start),u=this._pointInBasis2D(s.create(),e,i,a),d=this._pointInBasis2D(s.create(),e,i,this._right.start),p=this._pointInBasis2D(s.create(),e,i,l),[g]=h.intersectLineAndRay({start:u,end:_,type:h.LineType.LINE},{start:p,end:d,type:h.LineType.LINE});if(!g)return;const f=n.subtract(s.create(),_,u);n.normalize(f,f);const D=n.subtract(s.create(),g,u),m=n.dot(f,D),y=r.add(o.create(),a,r.scale(o.create(),this._left.direction,-m)),E=c.signedDistance(t,y);this._updateDistanceConstraint(E)},l._pointInBasis2D=function(t,e,i,n){return t[0]=a.projectPointSignedLength(e,n),t[1]=a.projectPointSignedLength(i,n),t},l._offset=function(t,e){Number.isFinite(this._minDistance)&&(e=Math.max(this._minDistance,e)),Number.isFinite(this._maxDistance)&&(e=Math.min(this._maxDistance,e)),c.copy(this._offsetPlane,this._plane),this._offsetPlane[3]-=e;const i=(t,e,i)=>null!=e&&c.intersectLine(this._offsetPlane,t,r.add(o.create(),t,e),i),n=o.create();(t===this._edge.leftVertex?i(this._left.start,this._left.direction,n):i(this._right.start,this._right.direction,n))&&this._helper.copy(this._helper.fromXYZ(n,void 0,this._helper.getM(t.pos)),t.pos)},l.selectArrowFromStartPoint=function(t){this._selectedArrow=c.isPointInside(this.plane,this._pointToXYZ(t))?1:-1},l.signedDistanceToPoint=function(t){return c.signedDistance(this.plane,this._pointToXYZ(t))},l.apply=function(t){this._offset(t,this.distance)},l.undo=function(t){this._offset(t,0)},l.canAccumulate=function(t){return t instanceof i&&this._edge.leftVertex.index===t._edge.leftVertex.index&&this._edge.rightVertex.index===t._edge.rightVertex.index&&this._edge.component===t._edge.component&&this._maybeEqualsVec3(this._left.direction,t._left.direction)&&this._maybeEqualsVec3(this._right.direction,t._right.direction)&&r.equals(c.normal(this._plane),c.normal(t._plane))},l.accumulate=function(t,e){const i=this._plane[3]-e._plane[3]+e.distance;this._offset(t,i)},l.accumulateParams=function(t){const e=t.distance-t._plane[3];this.distance=e+this._plane[3]},l.clone=function(){const t=new i(this._helper,this._planeType,this._edge,this.distance,p.DEFERRED);return c.copy(t._plane,this._plane),c.copy(t._offsetPlane,this._offsetPlane),t._maxDistance=this._maxDistance,t._minDistance=this._minDistance,t._left=this._cloneNeighbor(this._left),t._right=this._cloneNeighbor(this._right),t._edgeDirection=r.copy(o.create(),this._edgeDirection),t},l._maybeEqualsVec3=function(t,e){return null==t&&null==e||null!=t&&null!=e&&r.equals(t,e)},l._cloneNeighbor=function({start:t,end:e,direction:i,isOriginalDirection:n}){return{start:r.copy(o.create(),t),end:null!=e?r.copy(o.create(),e):null,direction:r.copy(o.create(),i),isOriginalDirection:n}},e._createClass(i,[{key:"plane",get:function(){return this._plane}},{key:"requiresSplitEdgeLeft",get:function(){return!this._left.isOriginalDirection}},{key:"requiresSplitEdgeRight",get:function(){return!this._right.isOriginalDirection}},{key:"edgeDirection",get:function(){return this._edgeDirection}},{key:"selectedArrow",get:function(){return this._selectedArrow}}]),i}();const _=i.deg2rad(15),u=.001;var d,p;t.PlaneType=void 0,(d=t.PlaneType||(t.PlaneType={}))[d.XYZ=0]="XYZ",d[d.XY=1]="XY",function(t){t[t.IMMEDIATE=0]="IMMEDIATE",t[t.DEFERRED=1]="DEFERRED"}(p||(p={})),t.OffsetEdgeVertex=l,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
