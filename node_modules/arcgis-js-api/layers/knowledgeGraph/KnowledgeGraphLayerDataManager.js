/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["exports","../../chunks/_rollupPluginBabelHelpers","../../chunks/tslib.es6","../../core/Accessor","../../core/Error","../../core/Logger","../../core/sql","../../core/accessorSupport/decorators/property","../../core/accessorSupport/ensureType","../../core/arrayUtils","../../core/has","../../core/accessorSupport/decorators/subclass","../../geohash/geohashUtils","../../geometry/Polygon","../../geometry/projection","../../geometry/support/spatialReferenceUtils","./SessionMemoryStorage","../../rest/knowledgeGraphService","../../rest/knowledgeGraph/GraphQueryStreaming","../../rest/support/Query"],(function(e,t,n,i,a,o,r,s,p,l,d,c,h,m,y,u,g,f,b,w){"use strict";const T="ESRI__ID",D="ESRI__ORIGIN_ID",M="ESRI__DESTINATION_ID",I="ESRI__LAYOUT_GEOMETRY",E=12,_=o.getLogger("esri.rest.knowledgeGraph.knowledgeGraphLayer.KnowledgeGraphLayerDataManager");e.KnowledgeGraphLayerDataManager=function(e){function n(t){var n;(n=e.call(this,t)||this).inclusionModeDefinition={generateAllSublayers:!0,namedTypeDefinitions:new Map},n.entityTypeNames=new Set,n.relationshipTypeNames=new Set,n.geographicLookup=new Map,n.sublayerCaches=new Map,n._processingCacheUpdatesLookup=new Map,n._memberIdTypeLookup=new Map;const i=new Map;return t.knowledgeGraph.dataModel.entityTypes?.forEach((e=>{e.name&&(i.set(e.name,"entity"),n._processingCacheUpdatesLookup.set(e.name,[]),t.inclusionModeDefinition&&!t.inclusionModeDefinition?.generateAllSublayers||n.entityTypeNames.add(e.name),e.properties?.forEach((t=>{t.geometryType&&"esriGeometryNull"!==t.geometryType&&n.geographicLookup.set(e.name,{name:t.name??"",geometryType:t.geometryType})})))})),t.knowledgeGraph.dataModel.relationshipTypes?.forEach((e=>{e.name&&(i.set(e.name,"relationship"),n._processingCacheUpdatesLookup.set(e.name,[]),t.inclusionModeDefinition&&!t.inclusionModeDefinition?.generateAllSublayers||n.relationshipTypeNames.add(e.name),e.properties?.forEach((t=>{t.geometryType&&"esriGeometryNull"!==t.geometryType&&n.geographicLookup.set(e.name,{name:t.name??"",geometryType:t.geometryType})})))})),t.inclusionModeDefinition?.namedTypeDefinitions.forEach(((e,a)=>{if("entity"===i.get(a))n.entityTypeNames.add(a);else{if("relationship"!==i.get(a))return _.warn(`A named type, ${a}, was in the inclusion list that wasn't in the data model and will be removed`),void t.inclusionModeDefinition?.namedTypeDefinitions.delete(a);n.relationshipTypeNames.add(a)}const o=new Map;e.members?.forEach((e=>{n._memberIdTypeLookup.set(e.id,a);const t=n.getById(e.id);t&&o.set(e.id,t)})),n.sublayerCaches.set(a,o)})),n}t._inherits(n,e);var i=n.prototype;return i.addToLayerInclusionSet=function(e){e.forEach((({typeName:e,id:t})=>{if(!this.inclusionModeDefinition)throw new a("knowledge-graph:layer-data-manager","You cannot add to a layer's exclusion list if it was not created with an exclusion list originally");if(this.inclusionModeDefinition.namedTypeDefinitions.has(e)){if(this.inclusionModeDefinition.namedTypeDefinitions.has(e)){const n=this.inclusionModeDefinition.namedTypeDefinitions.get(e);if(n.useAllData)throw new a("knowledge-graph:layer-data-manager","You cannot add members to an exclusion list for a sublayer where the sublayer is set to always retrieve its entire data set");n.members||(n.members=new Map),n.members.set(t,{id:t}),this._memberIdTypeLookup.set(t,e)}}else{const n=new Map;n.set(t,{id:t}),this.inclusionModeDefinition.namedTypeDefinitions.set(e,{useAllData:!1,members:n}),this._memberIdTypeLookup.set(t,e)}}))},i.getById=function(e){return g.getInstance().readFromStoreById(e)},i.getData=async function(e,t,n){if(t.objectType.name&&this.inclusionModeDefinition?.namedTypeDefinitions&&this.inclusionModeDefinition.namedTypeDefinitions.size>0&&!this.inclusionModeDefinition.namedTypeDefinitions.has(t.objectType.name))return[];let i;if(i=e||new w({where:"1=1",outFields:["*"]}),"link-chart"===t.parentCompositeLayer.type){const e=t.parentCompositeLayer,n=this._processingCacheUpdatesLookup.get(t.objectType.name??""),a=i.outFields,o=i.geometry;let r="",s="";o&&o.extent&&(r=h.encodeGeohash(o.extent.ymin,o.extent.xmin,E),s=h.encodeGeohash(o.extent.ymax,o.extent.xmax,E)),a&&1===a.length&&a[0]===T&&"1=1"===i.where||await Promise.all(n??[]);const p=this.sublayerCaches.has(t.objectType.name??"")?Array.from(this.sublayerCaches.get(t.objectType.name)?.values()):[],l=[];return p.forEach((n=>{if(n.geometry=e.linkChartDiagramLookup.get(n.attributes[t.objectIdField]),n.attributes[I]=n.geometry,r&&s){const i=e.linkChartGeohashLookup.get(n.attributes[t.objectIdField]);i?i>=r&&i<=s&&l.push(n):l.push(n)}else l.push(n)})),l}return this.retrieveDataFromService(i,t,n)},i.getConnectedRecordIds=async function(e){const t=[],n=[],i=new Map;return e.forEach((e=>{if(this._memberIdTypeLookup.has(e)){const t=this._memberIdTypeLookup.get(e);if(!this.entityTypeNames.has(t))return;i.has(t)?i.get(t)?.push(e):i.set(t,[e])}})),i.forEach(((e,i)=>{const a=`MATCH (n:${i})-[r]-(m) WHERE id(n) IN $ids RETURN id(r), type(r), id(m), labels(m)[0]`,o=new Promise((n=>{(async()=>{const n=(await f.executeQueryStreaming(this.knowledgeGraph,new b({openCypherQuery:a,bindParameters:{ids:e}}))).resultRowsStream.getReader();try{for(;;){const{done:e,value:i}=await n.read();if(e)break;for(let n=0;n<i.length;n++){const e=i[n];t.push({id:e[0],typeName:e[1]}),t.push({id:e[2],typeName:e[3]})}}}catch(i){if("AbortError"!==i.name)throw i;_.info("Request aborted as expected")}})().then((()=>{n()}))}));n.push(o)})),await Promise.all(n),t},i.refreshCacheContent=async function(e,t,n,i=!0){const o=g.getInstance(),r=[],s=new Map,p=new Map;this.knowledgeGraph.dataModel.entityTypes?.forEach((e=>{e.name&&p.set(e.name,e)})),this.knowledgeGraph.dataModel.relationshipTypes?.forEach((e=>{e.name&&p.set(e.name,e)})),e||this.inclusionModeDefinition?e?e.forEach((e=>{if(this._memberIdTypeLookup.has(e)){const t=this._memberIdTypeLookup.get(e);s.has(t)?s.get(t)?.push(e):s.set(t,[e])}})):this.inclusionModeDefinition?.namedTypeDefinitions?.forEach(((e,t)=>{e.useAllData?s.set(t,null):e.members&&e.members.forEach((e=>{s.has(t)&&null!==s.get(t)?s.get(t)?.push(e.id):s.set(t,[e.id])}))})):(this.knowledgeGraph.dataModel.entityTypes?.forEach((e=>{e.name&&s.set(e.name,null)})),this.knowledgeGraph.dataModel.entityTypes?.forEach((e=>{e.name&&s.set(e.name,null)})));for(const[l,d]of s){const e=new Promise((e=>{(async()=>{const e=new Set,r=[];let s,c="",h=!1;if(t||p.get(l)?.properties?.forEach((t=>{t.name&&e.add(t.name)})),n&&this.geographicLookup.has(l)){const t=this.geographicLookup.get(l)?.name;t&&e.add(t)}if(this.entityTypeNames.has(l))c=`MATCH (n:${l}) ${d?"WHERE id(n) IN $ids ":""}return ID(n)`,e.forEach((e=>{c+=`, n.${e}`,r.push(e)}));else{if(!this.relationshipTypeNames.has(l))throw new a("knowledge-graph:layer-data-manager",`The graph type of ${l} could not be determined. Was this type set in the KG data model and inclusion definition?`);h=!0,c=`MATCH ()-[n:${l}]->() ${d?"WHERE id(n) IN $ids ":""}return ID(n), id(startNode(n)), id(endNode(n))`,e.forEach((e=>{c+=`, n.${e}`,r.push(e)}))}s=new b(d?{openCypherQuery:c,bindParameters:{ids:d}}:{openCypherQuery:c});const m=(await f.executeQueryStreaming(this.knowledgeGraph,s)).resultRowsStream.getReader();for(;;){const{done:e,value:t}=await m.read();if(e)break;const n=[];for(let i=0;i<t.length;i++){const e=t[i];let a=0,o=0;const s={properties:{}};for(s.id=e[a],a++,o++,h&&(s.originId=e[a],a++,o++,s.destinationId=e[a],a++,o++);a<e.length;a++)s.properties[r[a-o]]=e[a];n.push(s)}const a=o.writeToStore(n,T,this.geographicLookup.get(l)?.name);this.sublayerCaches.has(l)||this.sublayerCaches.set(l,new Map),i&&!this.inclusionModeDefinition?.namedTypeDefinitions.has(l)&&this.inclusionModeDefinition?.namedTypeDefinitions.set(l,{useAllData:!1,members:new Map}),i&&!this.inclusionModeDefinition?.namedTypeDefinitions.get(l).members&&(this.inclusionModeDefinition.namedTypeDefinitions.get(l).members=new Map);const s=this.sublayerCaches.get(l);a.forEach((e=>{s?.set(e.attributes[T],e),i&&!this.inclusionModeDefinition?.namedTypeDefinitions.get(l).members.has(e.attributes[T])&&(this.inclusionModeDefinition?.namedTypeDefinitions.get(l).members.set(e.attributes[T],{id:e.attributes[T]}),this._memberIdTypeLookup.set(e.attributes[T],l))}))}})().then((()=>{e(null)}))}));r.push(e),this._processingCacheUpdatesLookup.get(l)?.push(e)}await Promise.all(r)},i.removeFromLayer=function(e){const t=new Set;e.forEach((e=>{this._memberIdTypeLookup.get(e)&&t.add(this._memberIdTypeLookup.get(e)),this._memberIdTypeLookup.delete(e),this.inclusionModeDefinition?.namedTypeDefinitions.forEach((t=>{t.members?.has(e)&&t.members.delete(e)}))})),t.forEach((t=>{this.sublayerCaches.get(t)?.forEach(((n,i)=>{e.includes(i)&&this.sublayerCaches.get(t)?.delete(i)}))}))},i.retrieveDataFromService=async function(e,t,n){const i=g.getInstance(),a=new Set,o=[];let s,p="",l=[];const d="relationship"===t.graphType,c=this.inclusionModeDefinition?.namedTypeDefinitions?.get(t.objectType.name)?.useAllData,h=t.parentCompositeLayer.sublayerIdsCache.get(t.objectType.name);let w=!c&&h?Array.from(h).sort():null;if(this.inclusionModeDefinition?.namedTypeDefinitions?.get(t.objectType.name)?.useAllData)this.inclusionModeDefinition?.namedTypeDefinitions?.get(t.objectType.name)?.useAllData&&null!=e.objectIds&&(w=e.objectIds);else if(null!=e.objectIds&&w&&w.length>0){const t=e.objectIds;e.objectIds=w.filter((e=>t.includes(e)))}else if(null!=e.objectIds)w=e.objectIds;else{if(this.inclusionModeDefinition?.namedTypeDefinitions.has(t.objectType.name)&&(!this.inclusionModeDefinition.namedTypeDefinitions.get(t.objectType.name)?.members||this.inclusionModeDefinition.namedTypeDefinitions.get(t.objectType.name)?.members?.size<1))return e.objectIds=[],[];e.objectIds=w}if(null!=e.outFields){const n=e.outFields;n.includes("*")?t.fields.forEach((e=>{a.add(e.name)})):n.forEach((e=>{e!==T&&e!==t.geometryFieldName&&a.add(e)}))}if(null!=e.geometry){const n=e.geometry;let i;if(n?.extent?.spatialReference&&!n.spatialReference?.isWGS84?(await y.initializeProjection(n.extent.spatialReference,u.WGS84),i=y.project(n.extent,u.WGS84)):i=n.extent,null!=e.where&&"1=1"!==e.where){const n=await r.parseWhereClause(e.where.toUpperCase(),t.fieldsIndex);t.fields.forEach((e=>{n.fieldNames.includes(e.name)&&a.add(e.name)}))}p=d?`Match ()-[n:${t.objectType.name}]->() WHERE esri.graph.ST_Intersects($param_filter_geom, n.${t.geometryFieldName}) return ID(n), id(startNode(r)), id(endNode(r))`:`Match (n:${t.objectType.name}) WHERE esri.graph.ST_Intersects($param_filter_geom, n.${t.geometryFieldName}) return ID(n)`,t.geometryFieldName&&a.add(t.geometryFieldName),a.forEach((e=>{p+=`, n.${e}`,o.push(e)})),s=new b({openCypherQuery:p,bindParameters:{param_filter_geom:new m({rings:[[[i.xmin,i.ymin],[i.xmin,i.ymax],[i.xmax,i.ymax],[i.xmax,i.ymin],[i.xmin,i.ymin]]]})}})}else{let n="";if(null!=e.where&&"1=1"!==e.where){const i=await r.parseWhereClause(e.where,t.fieldsIndex);t.fields.forEach((e=>{i.fieldNames.includes(e.name)&&a.add(e.name)}));const o=["column-reference","string","number","binary-expression"],s=["=","<","<=","<>",">",">=","AND","OR","LIKE"];let p=!1;const l=e=>{if("column-reference"===e.type)return`n.${e.column}`;if("string"===e.type)return`'${e.value}'`;if("number"===e.type)return`${e.value}`;if("binary-expression"===e.type&&o.includes(e.left.type)&&o.includes(e.right.type)&&s.includes(e.operator))return`${l(e.left)} ${e.operator} ${l(e.right)}`;if("binary-expression"===e.type&&"LIKE"===e.operator){let t="";if("function"===e.left.type&&"column-reference"===e.left.args.value[0].type)t+=`lower(n.${e.left.args.value[0].column})`;else{if("column-reference"!==e.left.type)return p=!0,"";t+=`lower(n.${e.left.column})`}if(t+=" CONTAINS (","string"!==e.right.type)return p=!0,"";{let n=e.right.value;"%"===n.charAt(0)&&(n=n.slice(1)),"%"===n.charAt(n.length-1)&&(n=n.slice(0,-1)),t+=`'${n.toLowerCase()}')`}return t}return p=!0,""};n=l(i.parseTree),p&&(n="")}let i="";i=d?`Match ()-[n:${t.objectType.name}]->()`:`Match (n:${t.objectType.name})`;let p=!1;w&&(p=!0,i+=" WHERE ID(n) IN $ids"),n&&(i+=p?" AND":" WHERE",i+=` ${n}`),i+=" return ID(n)",d&&(i+=", id(startNode(n)), id(endNode(n))"),e.returnGeometry&&t.geometryFieldName&&a.add(t.geometryFieldName),a.forEach((e=>{i+=`, n.${e}`,o.push(e)})),s=new b(w?{openCypherQuery:i,bindParameters:{ids:w}}:{openCypherQuery:i})}const D=(await f.executeQueryStreaming(t.parentCompositeLayer.dataManager.knowledgeGraph,s,n)).resultRowsStream.getReader();for(;;){const{done:e,value:n}=await D.read();if(e)break;const a=[];for(let t=0;t<n.length;t++){const e=n[t];let i=0,r=0;const s={properties:{}};for(s.id=e[i],i++,r++,d&&(s.originId=e[i],i++,r++,s.destinationId=e[i],i++,r++);i<e.length;i++)s.properties[o[i-r]]=e[i];a.push(s)}l=l.concat(i.writeToStore(a,T,t.parentCompositeLayer.dataManager.geographicLookup.get(t.objectType.name)?.name))}return l},t._createClass(n)}(i),n.__decorate([s.property()],e.KnowledgeGraphLayerDataManager.prototype,"knowledgeGraph",void 0),n.__decorate([s.property()],e.KnowledgeGraphLayerDataManager.prototype,"inclusionModeDefinition",void 0),n.__decorate([s.property()],e.KnowledgeGraphLayerDataManager.prototype,"entityTypeNames",void 0),n.__decorate([s.property()],e.KnowledgeGraphLayerDataManager.prototype,"relationshipTypeNames",void 0),n.__decorate([s.property()],e.KnowledgeGraphLayerDataManager.prototype,"geographicLookup",void 0),n.__decorate([s.property()],e.KnowledgeGraphLayerDataManager.prototype,"sublayerCaches",void 0),e.KnowledgeGraphLayerDataManager=n.__decorate([c.subclass("esri.rest.knowledgeGraph.knowledgeGraphLayer.KnowledgeGraphLayerDataManager")],e.KnowledgeGraphLayerDataManager),e.GEOHASH_ENCODING_PRECISION=E,e.MOCK_DESTINATION_ID_FIELD_NAME=M,e.MOCK_LAYOUT_GEOMETRY_FIELD_NAME=I,e.MOCK_OID_FIELD_NAME=T,e.MOCK_ORIGIN_ID_FIELD_NAME=D,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
