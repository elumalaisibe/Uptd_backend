/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["exports","../../../core/Error","../../../core/jsonMap","../../../core/sql/WhereClauseCache"],(function(e,i,s,n){"use strict";const r=new n.WhereClauseCache(50,500),t="feature-store:unsupported-query",a=" as ",o=new s.JSONMap({esriFieldTypeString:"string"}),l=new s.JSONMap({esriFieldTypeOID:"oid",esriFieldTypeSmallInteger:"small-integer",esriFieldTypeInteger:"integer",esriFieldTypeSingle:"single",esriFieldTypeDouble:"double",esriFieldTypeLong:"long"}),d=new s.JSONMap({esriFieldTypeDate:"date"}),p=new s.JSONMap({esriFieldTypeGUID:"guid",esriFieldTypeGlobalId:"global-id"}),u=new Set([...l.jsonValues,...d.jsonValues,...o.jsonValues,...p.jsonValues]),g=new Intl.ListFormat("en-US",{type:"conjunction"}).format([...l.apiValues,...d.apiValues,...o.apiValues,...p.apiValues]);function c(e,s,n={}){const r=v(e,s);if(!r)throw new i(t,"invalid SQL expression",{expression:e});const a=n.expressionName||"expression";if(n.validateStandardized&&!r.isStandardized)throw new i(t,`${a} is not standard`,{expression:e});if(n.validateAggregate&&!r.isAggregate)throw new i(t,`${a} does not contain a valid aggregate function`,{expression:e});return r.fieldNames}function y(e,i,s){if(!i)return!0;const n="where clause",r=c(i,e,{validateStandardized:!0,expressionName:n});return m(e,r,{expressionName:n,query:s}),h(e,r,{expressionName:n,query:s}),!0}function f(e,s,n,a){if(!s)return!0;const o="having",l=c(s,e,{validateAggregate:!0,expressionName:o});m(e,l,{expressionName:o,query:a}),h(e,l,{expressionName:o,query:a});const d=r.get(s,e),p=d?.getExpressions().every((i=>{const{aggregateType:s,field:r}=i,t=e.get(r)?.name;return n.some((i=>{const{onStatisticField:n,statisticType:r}=i,a=e.get(n)?.name;return a===t&&r.toLowerCase().trim()===s}))}));if(!p)throw new i(t,"expressions in having should also exist in outStatistics",{having:s});return!0}function v(e,i){return e?r.get(e,i):null}function m(e,i,s={}){s.errorMessage||(s.errorMessage=s.expressionName?`${s.expressionName} contains invalid fields`:"Fields are invalid"),x(e,i,((e,i)=>i.has(e)),s)}function h(e,i,s={}){s.errorMessage||(s.errorMessage=s.expressionName?`${s.expressionName} only supports ${g} field types`:`Only ${g} field types are supported`),x(e,i,((e,i)=>!N(e,i)),s)}function x(e,s,n,r={}){const a=r.verifyExpression??!0,o=[];for(const i of s){const s=n(i,e);if("*"!==i&&!s)if(a){const s=F(i);try{x(e,c(s,e,{validateStandardized:!0}),n,r)}catch(l){const e=l?.details;if(e?.expression)throw l;e?.invalidFields?o.push(...e.invalidFields):o.push(i)}}else o.push(i)}if(o.length)throw new i(t,r.errorMessage,{invalidFields:o,query:r.query})}function F(e){return e.split(a)[0]}function w(e){return e.split(a)[1]}function N(e,i,s=u){const n=i.get(e);return!!n&&!s.has(n.type)}e.getAliasFromFieldName=w,e.getExpressionFromFieldName=F,e.getWhereClause=v,e.hasInvalidFieldType=N,e.validDateTypesKebabDict=d,e.validGuidTypesKebabDict=p,e.validNumericTypesKebabDict=l,e.validStringTypesKebabDict=o,e.validateFieldTypes=h,e.validateFields=m,e.validateHaving=f,e.validateWhere=y,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
