/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["exports","../../../chunks/_rollupPluginBabelHelpers","../../../core/arrayUtils","../../../core/Error","../../../core/lang","../../../core/maybe","../../../core/MemCache","../../../core/promiseUtils","../../../core/unitUtils","../../../geometry/support/aaBoundingBox","../../../geometry/support/aaBoundingRect","../../../geometry/support/boundsUtils","../../../geometry/support/jsonUtils","../../../geometry/support/normalizeUtils","../../../geometry/support/spatialReferenceUtils","../featureConversionUtils","./attributeSupport","./projectionSupport","./QueryEngineCapabilities","./QueryEngineResult","./spatialQuerySupport","./timeSupport","./utils","../../support/FieldsIndex","../../../support/arcadeOnDemand","../../../views/support/Scheduler"],(function(e,t,i,s,r,a,n,u,o,l,c,h,y,d,p,f,m,g,_,x,S,w,R,F,Q,E){"use strict";function I(e){return null!=e&&e.every((e=>"exceedslimit"!==e.statisticType))}const b="feature-store:unsupported-query";let T=t._createClass((function(e,t=null,i,s,r){this.attributes=e,this.geometry=i,this.centroid=s,this.filterFlags=r,this.groupId=-1,this.displayId=t}));const A=new n.MemCacheStorage(2e6);let P=0,v=function(){function e(e){this._geometryQueryCache=null,this._changeHandle=null,this.capabilities={query:_.queryCapabilities},this.geometryType=e.geometryType,this.hasM=!!e.hasM,this.hasZ=!!e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",(()=>this.clearCache())),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new n.MemCache(P+++"$$",A)),this.fieldsIndex=new F(e.fields),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}var T=e.prototype;return T.destroy=function(){this._frameTask=a.removeMaybe(this._frameTask),this.clearCache(),a.destroyMaybe(this._geometryQueryCache),this._changeHandle=a.removeMaybe(this._changeHandle),a.destroyMaybe(this.fieldsIndex)},T.clearCache=function(){this._geometryQueryCache?.clear(),this._allFeaturesPromise=null,this._timeExtentPromise=null},T.executeQuery=async function(e,t){try{return(await this._executeQuery(e,{},t)).createQueryResponse()}catch(i){if(i!==R.QUERY_ENGINE_EMPTY_RESULT)throw i;return new x.QueryEngineResult([],e,this).createQueryResponse()}},T.executeQueryForCount=async function(e={},t){try{return(await this._executeQuery(e,{returnGeometry:!1,returnCentroid:!1,outSR:null},t)).createQueryResponseForCount()}catch(i){if(i!==R.QUERY_ENGINE_EMPTY_RESULT)throw i;return 0}},T.executeQueryForExtent=async function(e,t){const i=e.outSR;try{const s=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},t),r=s.size;if(!r)return{count:0,extent:null};return{count:r,extent:await this._getBounds(s.items,s.spatialReference,i||this.spatialReference)}}catch(s){if(s===R.QUERY_ENGINE_EMPTY_RESULT)return{count:0,extent:null};throw s}},T.executeQueryForIds=async function(e,t){return this.executeQueryForIdSet(e,t).then((e=>Array.from(e)))},T.executeQueryForIdSet=async function(e,t){try{const i=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},t),s=i.items,r=new Set;return await this._reschedule((()=>{for(const e of s)r.add(i.featureAdapter.getObjectId(e))}),t),r}catch(i){if(i===R.QUERY_ENGINE_EMPTY_RESULT)return new Set;throw i}},T.executeQueryForSnapping=async function(e,t){const{point:i,distance:s,returnEdge:r,returnVertex:a}=e;if(!r&&!a)return{candidates:[]};const n=await this._reschedule((()=>this._checkQuerySupport(e.query)),t),u=!p.equals(i.spatialReference,this.spatialReference);u&&await g.checkProjectionSupport(i.spatialReference,this.spatialReference);const o="number"==typeof s?s:s.x,l="number"==typeof s?s:s.y,c={xmin:i.x-o,xmax:i.x+o,ymin:i.y-l,ymax:i.y+l,spatialReference:i.spatialReference},h=u?g.project(c,this.spatialReference):c;if(!h)return{candidates:[]};const f=(await d.normalizeCentralMeridian(y.fromJSON(i),null,{signal:t}))[0],m=(await d.normalizeCentralMeridian(y.fromJSON(h),null,{signal:t}))[0];if(null==f||null==m)return{candidates:[]};const _=new x.QueryEngineResult(await this._reschedule((()=>this._searchFeatures(this._getQueryBBoxes(m.toJSON()))),t),n,this);await this._reschedule((()=>this._executeObjectIdsQuery(_)),t),await this._reschedule((()=>this._executeTimeQuery(_)),t),await this._reschedule((()=>this._executeAttributesQuery(_)),t);const S=f.toJSON(),w=u?g.project(S,this.spatialReference):S,R=u?Math.max(h.xmax-h.xmin,h.ymax-h.ymin)/2:s;return _.createSnappingResponse({...e,point:w,distance:R},i.spatialReference)},T.executeQueryForLatestObservations=async function(e,t){if(!this.timeInfo||!this.timeInfo.trackIdField)throw new s(b,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});try{const i=await this._executeQuery(e,{},t);return await this._reschedule((()=>this._filterLatest(i)),t),i.createQueryResponse()}catch(i){if(i!==R.QUERY_ENGINE_EMPTY_RESULT)throw i;return new x.QueryEngineResult([],e,this).createQueryResponse()}},T.executeQueryForSummaryStatistics=async function(e={},t,i){const{field:s,normalizationField:r,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:s,normalizationField:r,valueExpression:a},i)).createSummaryStatisticsResponse(t)},T.executeQueryForUniqueValues=async function(e={},t,i){const{field:s,field2:r,field3:a,valueExpression:n}=t;return(await this._getQueryEngineResultForStats(e,{field:s,field2:r,field3:a,valueExpression:n},i)).createUniqueValuesResponse(t)},T.executeQueryForClassBreaks=async function(e={},t,i){const{field:s,normalizationField:r,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:s,normalizationField:r,valueExpression:a},i)).createClassBreaksResponse(t)},T.executeQueryForHistogram=async function(e={},t,i){const{field:s,normalizationField:r,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:s,normalizationField:r,valueExpression:a},i)).createHistogramResponse(t)},T.fetchRecomputedExtents=async function(e){const[t,i]=await Promise.all(["getFullExtent"in this.featureStore&&this.featureStore.getFullExtent?Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)):this._getBounds(await this._getAllFeatures(),this.spatialReference,this.spatialReference),null!=this._timeExtentPromise?this._timeExtentPromise:this._timeExtentPromise=w.getTimeExtent(this.timeInfo,this.featureStore)]);return u.throwIfAborted(e),{fullExtent:t,timeExtent:i}},T._getBounds=async function(e,t,i){const s=l.set(l.create(),l.NEGATIVE_INFINITY);await this.featureStore.forEachBounds(e,(e=>l.expandWithAABB(s,e)));const r={xmin:s[0],ymin:s[1],xmax:s[3],ymax:s[4],spatialReference:R.cleanFromGeometryEngine(this.spatialReference)};this.hasZ&&isFinite(s[2])&&isFinite(s[5])&&(r.zmin=s[2],r.zmax=s[5]);const a=g.project(r,t,i);if(a.spatialReference=R.cleanFromGeometryEngine(i),a.xmax-a.xmin==0){const e=o.getMetersPerUnitForSR(a.spatialReference);a.xmin-=e,a.xmax+=e}if(a.ymax-a.ymin==0){const e=o.getMetersPerUnitForSR(a.spatialReference);a.ymin-=e,a.ymax+=e}if(this.hasZ&&null!=a.zmin&&null!=a.zmax&&a.zmax-a.zmin==0){const e=o.getMetersPerUnitForSR(a.spatialReference);a.zmin-=e,a.zmax+=e}return a},T._schedule=async function(e,t){return null!=this._frameTask?this._frameTask.schedule(e,t):e(E.noBudget)},T._reschedule=async function(e,t){return null!=this._frameTask?this._frameTask.reschedule(e,t):e(E.noBudget)},T._getAllFeaturesQueryEngineResult=async function(e){return new x.QueryEngineResult(await this._getAllFeatures(),e,this)},T._getAllFeatures=async function(){if(null==this._allFeaturesPromise){const e=[];this._allFeaturesPromise=(async()=>{await this.featureStore.forEach((t=>e.push(t)))})().then((()=>e))}const e=this._allFeaturesPromise,t=await e;return e===this._allFeaturesPromise?t.slice():this._getAllFeatures()},T._executeQuery=async function(e,t,i){e=r.clone(e),e=await this._schedule((()=>R.normalizeQuery(e,this.definitionExpression,this.spatialReference)),i),e=await this._reschedule((()=>this._checkQuerySupport(e)),i),e={...e,...t};const s=await this._reschedule((()=>this._executeSceneFilterQuery(e,i)),i),a=await this._reschedule((()=>this._executeGeometryQuery(e,s,i)),i);return await this._reschedule((()=>this._executeAggregateIdsQuery(a)),i),await this._reschedule((()=>this._executeObjectIdsQuery(a)),i),await this._reschedule((()=>this._executeTimeQuery(a)),i),await this._reschedule((()=>this._executeAttributesQuery(a)),i),a},T._executeSceneFilterQuery=async function(e,t){if(null==e.sceneFilter)return null;const{outSR:i,returnGeometry:s,returnCentroid:r}=e,a=this.featureStore.featureSpatialReference,n=e.sceneFilter.geometry,u=null==a||p.equals(a,n.spatialReference)?n:g.project(n,a);if(!u)return null;const o=s||r,l=p.isValid(i)&&!p.equals(this.spatialReference,i)&&o?async e=>this._project(e,i):e=>e,c=this.featureAdapter,h=await this._reschedule((()=>this._searchFeatures(this._getQueryBBoxes(u))),t);if("disjoint"===e.sceneFilter.spatialRelationship){if(!h.length)return null;const i=new Set;for(const e of h)i.add(c.getObjectId(e));const s=await this._reschedule((()=>this._getAllFeatures()),t),r=await this._reschedule((async()=>{const r=await S.getSpatialQueryOperator("esriSpatialRelDisjoint",u,this.geometryType,this.hasZ,this.hasM),a=e=>!i.has(c.getObjectId(e))||r(c.getGeometry(e)),n=await this._runSpatialFilter(s,a,t);return new x.QueryEngineResult(n,e,this)}),t);return l(r)}if(!h.length)return new x.QueryEngineResult([],e,this);if(this._canExecuteSinglePass(u,e))return l(new x.QueryEngineResult(h,e,this));const y=await S.getSpatialQueryOperator("esriSpatialRelContains",u,this.geometryType,this.hasZ,this.hasM),d=await this._runSpatialFilter(h,(e=>y(c.getGeometry(e))),t);return l(new x.QueryEngineResult(d,e,this))},T._executeGeometryQuery=async function(e,t,s){if(null!=t&&0===t.items.length)return t;e=null!=t?t.query:e;const{geometry:r,outSR:a,spatialRel:n,returnGeometry:u,returnCentroid:o}=e,l=this.featureStore.featureSpatialReference,c=!r||null==l||p.equals(l,r.spatialReference)?r:g.project(r,l),h=u||o,y=p.isValid(a)&&!p.equals(this.spatialReference,a),d=this._geometryQueryCache&&null==t?y&&h?JSON.stringify({originalFilterGeometry:r,spatialRelationship:n,outSpatialReference:a}):JSON.stringify({originalFilterGeometry:r,spatialRelationship:n}):null,f=d?this._geometryQueryCache.get(d):null;if(null!=f)return new x.QueryEngineResult(f,e,this);const m=async e=>(y&&h&&await this._project(e,a),d&&this._geometryQueryCache.put(d,e.items,e.items.length+1),e);if(!c)return m(null!=t?t:await this._getAllFeaturesQueryEngineResult(e));const _=this.featureAdapter;let w=await this._reschedule((()=>this._searchFeatures(this._getQueryBBoxes(r))),s);if("esriSpatialRelDisjoint"===n){if(!w.length)return m(null!=t?t:await this._getAllFeaturesQueryEngineResult(e));const i=new Set;for(const e of w)i.add(_.getObjectId(e));const r=null!=t?t.items:await this._reschedule((()=>this._getAllFeatures()),s),a=await this._reschedule((async()=>{const t=await S.getSpatialQueryOperator(n,c,this.geometryType,this.hasZ,this.hasM),a=e=>!i.has(_.getObjectId(e))||t(_.getGeometry(e)),u=await this._runSpatialFilter(r,a,s);return new x.QueryEngineResult(u,e,this)}),s);return m(a)}if(null!=t){const e=new i.PositionHint;w=w.filter((s=>i.indexOf(t.items,s,t.items.length,e)>=0))}if(!w.length){const t=new x.QueryEngineResult([],e,this);return d&&this._geometryQueryCache.put(d,t.items,1),t}if(this._canExecuteSinglePass(c,e))return m(new x.QueryEngineResult(w,e,this));const R=await S.getSpatialQueryOperator(n,c,this.geometryType,this.hasZ,this.hasM),F=await this._runSpatialFilter(w,(e=>R(_.getGeometry(e))),s);return m(new x.QueryEngineResult(F,e,this))},T._executeAggregateIdsQuery=function(e){if(0===e.items.length||!e.query.aggregateIds||!e.query.aggregateIds.length||null==this.aggregateAdapter)return;const t=new Set;for(const s of e.query.aggregateIds){this.aggregateAdapter.getFeatureObjectIds(s).forEach((e=>t.add(e)))}const i=this.featureAdapter.getObjectId;e.items=e.items.filter((e=>t.has(i(e))))},T._executeObjectIdsQuery=function(e){if(0===e.items.length||!e.query.objectIds||!e.query.objectIds.length)return;const t=new Set(e.query.objectIds),i=this.featureAdapter.getObjectId;e.items=e.items.filter((e=>t.has(i(e))))},T._executeTimeQuery=function(e){if(0===e.items.length)return;const t=w.getTimeOperator(this.timeInfo,e.query.timeExtent,this.featureAdapter);null!=t&&(e.items=e.items.filter(t))},T._executeAttributesQuery=function(e){if(0===e.items.length)return;const t=m.getWhereClause(e.query.where,this.fieldsIndex);if(t){if(!t.isStandardized)throw new TypeError("Where clause is not standardized");e.items=e.items.filter((e=>t.testFeature(e,this.featureAdapter)))}},T._runSpatialFilter=async function(e,t,i){if(!t)return e;if(null==this._frameTask)return e.filter((e=>t(e)));let s=0;const r=new Array,a=async n=>{for(;s<e.length;){const u=e[s++];t(u)&&(r.push(u),n.madeProgress()),n.done&&await this._reschedule((e=>a(e)),i)}};return this._reschedule((e=>a(e)),i).then((()=>r))},T._filterLatest=function(e){const{trackIdField:t,startTimeField:i,endTimeField:s}=this.timeInfo,r=s||i,a=new Map,n=this.featureAdapter.getAttribute;for(const u of e.items){const e=n(u,t),i=n(u,r),s=a.get(e);(!s||i>n(s,r))&&a.set(e,u)}e.items=Array.from(a.values())},T._canExecuteSinglePass=function(e,t){const{spatialRel:i}=t;return S.canQueryWithRBush(e)&&("esriSpatialRelEnvelopeIntersects"===i||"esriGeometryPoint"===this.geometryType&&("esriSpatialRelIntersects"===i||"esriSpatialRelContains"===i||"esriSpatialRelWithin"===i))},T._project=async function(e,t){if(!t||p.equals(this.spatialReference,t))return e;const i=this.featureAdapter,s=await g.projectMany(e.items.map((e=>R.getGeometry(this.geometryType,this.hasZ,this.hasM,i.getGeometry(e)))),this.spatialReference,t);return e.items=s.map(((t,s)=>i.cloneWithGeometry(e.items[s],f.convertFromGeometry(t,this.hasZ,this.hasM)))),e},T._getQueryBBoxes=function(e){if(S.canQueryWithRBush(e)){if(y.isExtent(e))return[c.fromValues(e.xmin,e.ymin,e.xmax,e.ymax)];if(y.isPolygon(e))return e.rings.map((e=>c.fromValues(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1]))))}return[h.getBoundsXY(c.create(),e)]},T._searchFeatures=async function(e){const t=new Set;await Promise.all(e.map((e=>this.featureStore.forEachInBounds(e,(e=>t.add(e))))));const i=Array.from(t.values());return t.clear(),i},T._checkStatisticsSupport=async function(e,t){if((e.distance??0)<0||null!=e.geometryPrecision||e.multipatchOption||e.pixelSize||e.relationParam||e.text||e.outStatistics||e.groupByFieldsForStatistics||e.having||e.orderByFields)throw new s(b,"Unsupported query options",{query:e});return this._checkAttributesQuerySupport(e),Promise.all([this._checkStatisticsParamsSupport(t,e),S.checkSpatialQuerySupport(e,this.geometryType,this.spatialReference),g.checkProjectionSupport(this.spatialReference,e.outSR)]).then((()=>e))},T._checkStatisticsParamsSupport=async function(e,t){let i=[];if(e.valueExpression){const{arcadeUtils:t}=await Q.loadArcade();i=t.extractFieldNames(e.valueExpression)}if(e.field&&i.push(e.field),e.field2&&i.push(e.field2),e.field3&&i.push(e.field3),e.normalizationField&&i.push(e.normalizationField),!i.length&&!e.valueExpression)throw new s(b,"field or valueExpression is required",{params:e});m.validateFields(this.fieldsIndex,i,{errorMessage:"Cannot calculate statistics for missing fields",query:t}),m.validateFieldTypes(this.fieldsIndex,i,{expressionName:"statistics",query:t})},T._checkQuerySupport=async function(e){if((e.distance??0)<0||null!=e.geometryPrecision||e.multipatchOption||e.pixelSize||e.relationParam||e.text)throw new s(b,"Unsupported query options",{query:e});return this._checkAttributesQuerySupport(e),this._checkStatisticsQuerySupport(e),Promise.all([S.checkSpatialQuerySupport(e,this.geometryType,this.spatialReference),g.checkProjectionSupport(this.spatialReference,e.outSR)]).then((()=>e))},T._checkAttributesQuerySupport=function(e){const{outFields:t,orderByFields:i,returnDistinctValues:r,outStatistics:a}=e,n=a?a.map((e=>e.outStatisticFieldName&&e.outStatisticFieldName.toLowerCase())).filter(Boolean):[];if(i&&i.length>0){const t=" asc",s=" desc",r=i.map((e=>{const i=e.toLowerCase();return i.includes(t)?i.split(t)[0]:i.includes(s)?i.split(s)[0]:e})).filter((e=>!n.includes(e)));m.validateFields(this.fieldsIndex,r,{expressionName:"orderByFields",query:e})}if(t&&t.length>0)m.validateFields(this.fieldsIndex,t,{expressionName:"outFields",query:e});else if(r)throw new s(b,"outFields should be specified for returnDistinctValues",{query:e});m.validateWhere(this.fieldsIndex,e.where,e)},T._checkStatisticsQuerySupport=function(e){const{outStatistics:t,groupByFieldsForStatistics:i,having:r}=e,a=i&&i.length,n=t&&t.length;if(r){if(!a||!n)throw new s(b,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:e});m.validateHaving(this.fieldsIndex,r,t,e)}if(n){if(!I(t))return;const r=t.map((e=>e.onStatisticField)).filter(Boolean);m.validateFields(this.fieldsIndex,r,{expressionName:"onStatisticFields",query:e}),a&&m.validateFields(this.fieldsIndex,i,{expressionName:"groupByFieldsForStatistics",query:e});const n=new Set([...m.validNumericTypesKebabDict.jsonValues,...m.validDateTypesKebabDict.jsonValues]),u=new Intl.ListFormat("en-US",{type:"conjunction"}).format([...m.validNumericTypesKebabDict.apiValues,...m.validDateTypesKebabDict.apiValues]);for(const i of t){const{onStatisticField:t,statisticType:r}=i;if(("percentile_disc"===r||"percentile_cont"===r)&&"statisticParameters"in i){const{statisticParameters:t}=i;if(!t)throw new s(b,"statisticParameters should be set for percentile type",{definition:i,query:e})}else if("count"!==r&&"min"!==r&&"max"!==r&&t&&m.hasInvalidFieldType(t,this.fieldsIndex,n))throw new s(b,`outStatistics with '${r}' statistic type, only supports ${u} field types`,{definition:i,query:e})}}},T._getQueryEngineResultForStats=async function(e,t,i){e=r.clone(e);try{e=await this._schedule((()=>R.normalizeQuery(e,this.definitionExpression,this.spatialReference)),i),e=await this._reschedule((()=>this._checkStatisticsSupport(e,t)),i);const s=await this._reschedule((()=>this._executeSceneFilterQuery(e,i)),i),r=await this._reschedule((()=>this._executeGeometryQuery(e,s,i)),i);return await this._reschedule((()=>this._executeAggregateIdsQuery(r)),i),await this._reschedule((()=>this._executeObjectIdsQuery(r)),i),await this._reschedule((()=>this._executeTimeQuery(r)),i),await this._reschedule((()=>this._executeAttributesQuery(r)),i),r}catch(s){if(s!==R.QUERY_ENGINE_EMPTY_RESULT)throw s;return new x.QueryEngineResult([],e,this)}},t._createClass(e,[{key:"featureAdapter",get:function(){return this.featureStore.featureAdapter}}]),e}();e.Feature=T,e.QueryEngine=v,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
