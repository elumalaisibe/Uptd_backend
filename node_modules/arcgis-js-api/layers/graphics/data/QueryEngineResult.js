/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["require","exports","../../../chunks/_rollupPluginBabelHelpers","../../../geometry/support/centroid","../../../geometry/support/extentUtils","../../../geometry/support/quantizationUtils","../../../geometry/support/spatialReferenceUtils","./AttributesBuilder","./projectionSupport","./SnappingCandidate","./utils","../../support/fieldUtils","../../../statistics/utils"],(function(e,t,i,s,a,n,r,o,l,u,c,d,m){"use strict";let f=function(){function t(e,t,i){this.items=e,this.query=t,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.fieldsIndex=i.fieldsIndex,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.featureAdapter=i.featureAdapter}var f=t.prototype;return f.createQueryResponseForCount=function(){const e=new o(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:t,having:i,outStatistics:s}=this.query,a=t?.length;if(!!!a)return 1;const n=new Map,r=new Map,l=new Set;for(const o of s){const{statisticType:s}=o,a="exceedslimit"!==s?o.onStatisticField:void 0;if(!r.has(a)){const i=[];for(const s of t){const t=this._getAttributeValues(e,s,n);i.push(t)}r.set(a,this._calculateUniqueValues(i,e.returnDistinctValues))}const u=r.get(a);for(const t in u){const{data:s,items:a}=u[t],n=s.join(",");i&&!e.validateItems(a,i)||l.add(n)}}return l.size},f.createQueryResponse=async function(){let e;if(this.query.outStatistics){e=this.query.outStatistics.some((e=>"exceedslimit"===e.statisticType))?this._createExceedsLimitQueryResponse(this.query):await this._createStatisticsQueryResponse(this.query)}else e=this._createFeatureQueryResponse(this.query);if(this.query.returnQueryGeometry){const t=this.query.geometry;r.isValid(this.query.outSR)&&!r.equals(t.spatialReference,this.query.outSR)?e.queryGeometry=c.cleanFromGeometryEngine({spatialReference:this.query.outSR,...l.project(t,t.spatialReference,this.query.outSR)}):e.queryGeometry=c.cleanFromGeometryEngine({spatialReference:this.query.outSR,...t})}return e},f.createSnappingResponse=function(e,t){const i=this.featureAdapter,s=h(this.hasZ,this.hasM),{point:a,mode:n}=e,r="number"==typeof e.distance?e.distance:e.distance.x,o="number"==typeof e.distance?e.distance:e.distance.y,l={candidates:[]},c="esriGeometryPolygon"===this.geometryType,d=this._getPointCreator(n,this.spatialReference,t),m=new y(null,0),f=new y(null,0),p={x:0,y:0,z:0};for(const h of this.items){const t=i.getGeometry(h);if(null==t)continue;const{coords:n,lengths:y}=t;if(m.coords=n,f.coords=n,e.returnEdge){let e=0;for(let t=0;t<y.length;t++){const n=y[t];for(let t=0;t<n;t++,e+=s){const c=m;if(c.coordsIndex=e,t!==n-1){const t=f;t.coordsIndex=e+s;const n=p;g(p,a,c,t);const m=(a.x-n.x)/r,y=(a.y-n.y)/o,x=m*m+y*y;x<=1&&l.candidates.push(u.makeEdgeCandidate(i.getObjectId(h),d(n),Math.sqrt(x),d(c),d(t)))}}}}if(e.returnVertex){const e=c?n.length-s:n.length;for(let t=0;t<e;t+=s){const e=m;e.coordsIndex=t;const s=(a.x-e.x)/r,n=(a.y-e.y)/o,c=s*s+n*n;c<=1&&l.candidates.push(u.makeVertexCandidate(i.getObjectId(h),d(e),Math.sqrt(c)))}}}return l.candidates.sort(((e,t)=>e.distance-t.distance)),l},f._getPointCreator=function(e,t,i){const s=null==i||r.equals(t,i)?e=>e:e=>l.project(e,t,i),{hasZ:a}=this,n=0;return"3d"===e?a?({x:e,y:t,z:i})=>s({x:e,y:t,z:i}):({x:e,y:t})=>s({x:e,y:t,z:n}):({x:e,y:t})=>s({x:e,y:t})},f.createSummaryStatisticsResponse=async function(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:n,minValue:r,maxValue:o,scale:l}=e,u=this.fieldsIndex.isDateField(t),c=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:n,scale:l}),f=m.isNullCountSupported({normalizationType:a,normalizationField:s,minValue:r,maxValue:o}),g=this.fieldsIndex.get(t),h={value:.5,fieldType:g?.type},y=d.isStringField(g)?m.calculateStringStatistics({values:c,supportsNullCount:f,percentileParams:h}):m.calculateStatistics({values:c,minValue:r,maxValue:o,useSampleStdDev:!a,supportsNullCount:f,percentileParams:h});return m.processSummaryStatisticsResult(y,u)},f.createUniqueValuesResponse=async function(e){const{field:t,valueExpression:i,domains:s,returnAllCodedValues:a,scale:n}=e,r=await this._getDataValues({field:t,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,valueExpression:i,scale:n}),o=m.calculateUniqueValuesCount(r);return m.createUVResult(o,s,a,e.fieldDelimiter)},f.createClassBreaksResponse=async function(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:n,classificationMethod:r,standardDeviationInterval:o,minValue:l,maxValue:u,numClasses:c,scale:d}=e,f=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:n,scale:d}),g=m.calculateClassBreaks(f,{field:t,normalizationField:s,normalizationType:a,normalizationTotal:n,classificationMethod:r,standardDeviationInterval:o,minValue:l,maxValue:u,numClasses:c});return m.resolveCBResult(g,r)},f.createHistogramResponse=async function(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:n,classificationMethod:r,standardDeviationInterval:o,minValue:l,maxValue:u,numBins:c,scale:d}=e,f=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:n,scale:d});return m.calculateHistogram(f,{field:t,normalizationField:s,normalizationType:a,normalizationTotal:n,classificationMethod:r,standardDeviationInterval:o,minValue:l,maxValue:u,numBins:c})},f._sortFeatures=function(e,t,i){if(e.length>1&&t&&t.length)for(const s of t.reverse()){const t=s.split(" "),a=t[0],n=this.fieldsIndex.get(a),r=!!t[1]&&"desc"===t[1].toLowerCase(),o=m.getAttributeComparator(n?.type,r);e.sort(((e,t)=>{const s=i(e,a,n),r=i(t,a,n);return o(s,r)}))}},f._createFeatureQueryResponse=function(e){const t=this.items,{geometryType:i,hasM:s,hasZ:a,objectIdField:r,spatialReference:o}=this,{outFields:l,outSR:u,quantizationParameters:d,resultRecordCount:m,resultOffset:f,returnZ:g,returnM:h}=e,y=null!=m&&t.length>(f||0)+m,p=l&&(l.includes("*")?[...this.fieldsIndex.fields]:l.map((e=>this.fieldsIndex.get(e))));return{exceededTransferLimit:y,features:this._createFeatures(e,t),fields:p,geometryType:i,hasM:s&&h,hasZ:a&&g,objectIdFieldName:r,spatialReference:c.cleanFromGeometryEngine(u||o),transform:d&&n.toQuantizationTransform(d)||null}},f._createFeatures=function(e,t){const i=new o(e,this.featureAdapter,this.fieldsIndex),{hasM:s,hasZ:a}=this,{orderByFields:r,quantizationParameters:l,returnGeometry:u,returnCentroid:d,maxAllowableOffset:m,resultOffset:f,resultRecordCount:g,returnZ:h=!1,returnM:y=!1}=e,p=a&&h,x=s&&y;let I=[],S=0;const T=[...t];if(this._sortFeatures(T,r,((e,t,s)=>i.getFieldValue(e,t,s))),u||d){const e=n.toQuantizationTransform(l)??void 0;if(u&&!d)for(const t of T)I[S++]={attributes:i.getAttributes(t),geometry:c.getGeometry(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(t),m,e,p,x)};else if(!u&&d)for(const t of T)I[S++]={attributes:i.getAttributes(t),centroid:c.transformCentroid(this,this.featureAdapter.getCentroid(t,this),e)};else for(const t of T)I[S++]={attributes:i.getAttributes(t),centroid:c.transformCentroid(this,this.featureAdapter.getCentroid(t,this),e),geometry:c.getGeometry(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(t),m,e,p,x)}}else for(const n of T){const e=i.getAttributes(n);e&&(I[S++]={attributes:e})}const V=f||0;if(null!=g){const e=V+g;I=I.slice(V,Math.min(I.length,e))}return I},f._createExceedsLimitQueryResponse=function(e){let t=!1,i=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY;for(const n of e.outStatistics??[])if("exceedslimit"===n.statisticType){i=null!=n.maxPointCount?n.maxPointCount:Number.POSITIVE_INFINITY,s=null!=n.maxRecordCount?n.maxRecordCount:Number.POSITIVE_INFINITY,a=null!=n.maxVertexCount?n.maxVertexCount:Number.POSITIVE_INFINITY;break}if("esriGeometryPoint"===this.geometryType)t=this.items.length>i;else if(this.items.length>s)t=!0;else{const e=h(this.hasZ,this.hasM),i=this.featureAdapter;t=this.items.reduce(((e,t)=>{const s=i.getGeometry(t);return e+(null!=s&&s.coords.length||0)}),0)/e>a}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(t)}}]}},f._createStatisticsQueryResponse=async function(e){const t={attributes:{}},i=[],s=new Map,a=new Map,n=new Map,r=new Map,l=new o(e,this.featureAdapter,this.fieldsIndex),u=e.outStatistics,{groupByFieldsForStatistics:c,having:d,orderByFields:m}=e,f=c&&c.length,g=!!f,h=g?c[0]:null,y=g&&!this.fieldsIndex.get(h);for(const o of u??[]){const{outStatisticFieldName:e,statisticType:u}=o,m=o,p="exceedslimit"!==u?o.onStatisticField:void 0,x="percentile_disc"===u||"percentile_cont"===u,I="EnvelopeAggregate"===u||"CentroidAggregate"===u||"ConvexHullAggregate"===u,S=g&&1===f&&(p===h||y)&&"count"===u;if(g){if(!n.has(p)){const e=[];for(const t of c){const i=this._getAttributeValues(l,t,s);e.push(i)}n.set(p,this._calculateUniqueValues(e,!I&&l.returnDistinctValues))}const t=n.get(p);for(const i in t){const{count:a,data:n,items:o,itemPositions:u}=t[i],f=n.join(",");if(!d||l.validateItems(o,d)){const t=r.get(f)||{attributes:{}};if(I){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:i}=await this._getAggregateGeometry(m,o);t.aggregateGeometries[i]=e}else{let i=null;if(S)i=a;else{const e=this._getAttributeValues(l,p,s),t=u.map((t=>e[t]));i=x&&"statisticParameters"in m?this._getPercentileValue(m,t):this._getStatisticValue(m,t,null,l.returnDistinctValues)}t.attributes[e]=i}let i=0;c.forEach(((e,s)=>t.attributes[this.fieldsIndex.get(e)?e:"EXPR_"+ ++i]=n[s])),r.set(f,t)}}}else if(I){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:i}=await this._getAggregateGeometry(m,this.items);t.aggregateGeometries[i]=e}else{const i=this._getAttributeValues(l,p,s);t.attributes[e]=x&&"statisticParameters"in m?this._getPercentileValue(m,i):this._getStatisticValue(m,i,a,l.returnDistinctValues)}i.push({name:e,alias:e,type:"esriFieldTypeDouble"})}const p=g?Array.from(r.values()):[t];return this._sortFeatures(p,m,((e,t)=>e.attributes[t])),{fields:i,features:p}},f._getAggregateGeometry=async function(t,i){const{convexHull:n,union:r}=await new Promise(((t,i)=>e(["../../../geometry/geometryEngineJSON"],t,i))),{statisticType:o,outStatisticFieldName:l}=t,{featureAdapter:u,spatialReference:d,geometryType:m,hasZ:f,hasM:g}=this,h=i.map((e=>c.getGeometry(m,f,g,u.getGeometry(e)))),y=n(d,h,!0)[0],p={aggregateGeometries:null,outStatisticFieldName:null};if("EnvelopeAggregate"===o){const e=y?a.getPolygonExtent(y):a.getGeometryExtent(r(d,h));p.aggregateGeometries={...e,spatialReference:d},p.outStatisticFieldName=l||"extent"}else if("CentroidAggregate"===o){const e=y?s.polygonCentroid(y):s.extentCentroid(a.getGeometryExtent(r(d,h)));p.aggregateGeometries={x:e[0],y:e[1],spatialReference:d},p.outStatisticFieldName=l||"centroid"}else"ConvexHullAggregate"===o&&(p.aggregateGeometries=y,p.outStatisticFieldName=l||"convexHull");return p},f._getStatisticValue=function(e,t,i,s){const{onStatisticField:a,statisticType:n}=e;let r=null;r=i?.has(a)?i.get(a):d.isStringField(this.fieldsIndex.get(a))?m.calculateStringStatistics({values:t,returnDistinct:s}):m.calculateStatistics({values:s?[...new Set(t)]:t,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(a,r);return r["var"===n?"variance":n]},f._getPercentileValue=function(e,t){const{onStatisticField:i,statisticParameters:s,statisticType:a}=e,{value:n,orderBy:r}=s,o=this.fieldsIndex.get(i),l={value:n,orderBy:r,fieldType:o?.type,isDiscrete:"percentile_disc"===a};return m.calculatePercentile(t,l)},f._getAttributeValues=function(e,t,i){if(i.has(t))return i.get(t);const s=this.fieldsIndex.get(t),a=this.items.map((i=>e.getFieldValue(i,t,s)));return i.set(t,a),a},f._calculateUniqueValues=function(e,t){const i={},s=this.items,a=s.length;for(let n=0;n<a;n++){const a=s[n],r=[];for(const t of e)r.push(t[n]);const o=r.join(",");null==i[o]?i[o]={count:1,data:r,items:[a],itemPositions:[n]}:(t||i[o].count++,i[o].items.push(a),i[o].itemPositions.push(n))}return i},f._getDataValues=async function(e){const t=new o(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:i,scale:s}=e,a=i?{viewingMode:"map",scale:s,spatialReference:this.query.outSR||this.spatialReference}:null;return i?t.getExpressionValues(this.items,i,a,{geometryType:this.geometryType,hasZ:this.hasZ,hasM:this.hasM}):t.getDataValues(this.items,{field:e.field,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal})},i._createClass(t,[{key:"size",get:function(){return this.items.length}}]),t}();function g(e,t,i,s){const a=s.x-i.x,n=s.y-i.y,r=a*a+n*n,o=(t.x-i.x)*a+(t.y-i.y)*n,l=Math.min(1,Math.max(0,o/r));e.x=i.x+a*l,e.y=i.y+n*l}function h(e,t){return e?t?4:3:t?3:2}let y=function(){function e(e,t){this.coords=e,this.coordsIndex=t}return i._createClass(e,[{key:"x",get:function(){return this.coords[this.coordsIndex]}},{key:"y",get:function(){return this.coords[this.coordsIndex+1]}},{key:"z",get:function(){return this.coords[this.coordsIndex+2]}}]),e}();t.QueryEngineResult=f,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
