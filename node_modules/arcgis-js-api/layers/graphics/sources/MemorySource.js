/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["exports","../../../chunks/_rollupPluginBabelHelpers","../../../chunks/tslib.es6","../../../geometry","../../../Graphic","../../../core/Collection","../../../core/Error","../../../core/HandleOwner","../../../core/has","../../../core/Loadable","../../../core/Logger","../../../core/Promise","../../../core/workers/workers","../../../core/accessorSupport/decorators/property","../../../core/accessorSupport/ensureType","../../../core/arrayUtils","../../../core/accessorSupport/decorators/shared","../../../core/accessorSupport/decorators/subclass","../../../rest/query/operations/editsZScale","../../../rest/query/operations/queryZScale","../../../rest/support/FeatureSet","../../../geometry/Extent","../../../geometry/Polygon","../../../geometry/support/typeUtils"],(function(e,t,r,i,o,n,s,a,u,l,c,p,d,y,h,f,g,m,_,S,b,T,F,G){"use strict";let M=0;const O="esri.layers.graphics.sources.MemorySource",R=c.getLogger(O);e.MemorySource=function(e){function r(t){var r;return(r=e.call(this,t)||this)._idToClientGraphic=null,r.type="memory",r}t._inherits(r,e);var i=r.prototype;return i.load=function(e){const t=null!=e?e.signal:null;return this.addResolvingPromise(this._startWorker(t)),Promise.resolve(this)},i.destroy=function(){this._connection?.close(),this._connection=null},i.applyEdits=function(e){return this.load().then((()=>this._applyEdits(e)))},i.openPorts=function(){return this.load().then((()=>this._connection.openPorts()))},i.queryFeatures=async function(e,t={}){await this.load(t);const r=await this._connection.invoke("queryFeatures",e?e.toJSON():null,t);S.applyFeatureSetZUnitScaling(e,this.layer.spatialReference,r);const i=b.fromJSON(r);if(!this._requiresClientGraphicMapping())return i;const o=this.layer.objectIdField;for(const n of i.features){const e=n.attributes[o],t=this._idToClientGraphic.get(e);t&&(n.geometry=t.geometry)}return i.geometryType=this.layer.geometryType,i},i.queryFeaturesJSON=async function(e,t={}){if(this._requiresClientGraphicMapping())throw new s("query-features-json:unsupported","Cannot query in JSON format for client only geometry types (mesh and extent)");await this.load(t);const r=await this._connection.invoke("queryFeatures",e?e.toJSON():null,t);return S.applyFeatureSetZUnitScaling(e,this.layer.spatialReference,r),r},i.queryFeatureCount=function(e,t={}){return this.load(t).then((()=>this._connection.invoke("queryFeatureCount",e?e.toJSON():null,t)))},i.queryObjectIds=function(e,t={}){return this.load(t).then((()=>this._connection.invoke("queryObjectIds",e?e.toJSON():null,t)))},i.queryExtent=function(e,t={}){return this.load(t).then((()=>this._connection.invoke("queryExtent",e?e.toJSON():null,t))).then((e=>({count:e.count,extent:T.fromJSON(e.extent)})))},i.querySnapping=function(e,t={}){return this.load(t).then((()=>this._connection.invoke("querySnapping",e,t)))},i._applyEdits=async function(e){if(!this._connection)throw new s("feature-layer-source:edit-failure","Memory source not loaded");const t=this.layer.objectIdField;let r=null;const i=[],o=[];await Promise.all([this._prepareClientMapping(e.addFeatures,null),this._prepareClientMapping(e.updateFeatures,null)]);const n=e=>"objectId"in e&&null!=e.objectId?e.objectId:"attributes"in e&&null!=e.attributes[t]?e.attributes[t]:null;if(e.addFeatures&&(r=this._prepareAddFeatures(e.addFeatures)),e.deleteFeatures)for(const s of e.deleteFeatures){const e=n(s);null!=e&&i.push(e)}const a=e.updateFeatures&&this._idToClientGraphic?new Map:null;if(e.updateFeatures)for(const s of e.updateFeatures)if(o.push(this._serializeFeature(s)),a){const e=n(s);null!=e&&a.set(e,s)}_.unapplyEditsZUnitScaling(r?r.features:null,o,this.layer.spatialReference);const{fullExtent:u,featureEditResults:l}=await this._connection.invoke("applyEdits",{adds:r?r.features:[],updates:o,deletes:i});return this.fullExtent=u,r&&r.finish(l.uidToObjectId),this._updateClientGraphicIds(a,l),this._createEditsResult(l)},i._prepareClientMapping=async function(e,t){if("mesh"!==this._layerOrSourceGeometryType||null==e)return;const r=[];for(const{geometry:i}of e)null==i||"mesh"!==i.type||i.hasExtent||i.loaded||r.push(i.load({signal:t}));r.length&&await Promise.all(r)},i._updateClientGraphicIds=function(e,t){if(this._idToClientGraphic){if(e)for(const r of t.updateResults){if(!r.success)continue;const t=e.get(r.objectId);null!=t&&this._addIdToClientGraphic(t)}for(const e of t.deleteResults)e.success&&this._idToClientGraphic.delete(e.objectId)}},i._createEditsResult=function(e){return{addFeatureResults:e.addResults?e.addResults.map(this._createFeatureEditResult,this):[],updateFeatureResults:e.updateResults?e.updateResults.map(this._createFeatureEditResult,this):[],deleteFeatureResults:e.deleteResults?e.deleteResults.map(this._createFeatureEditResult,this):[],addAttachmentResults:[],updateAttachmentResults:[],deleteAttachmentResults:[]}},i._createFeatureEditResult=function(e){const t=!0===e.success?null:e.error||{code:void 0,description:void 0};return{objectId:e.objectId,globalId:e.globalId,error:t?new s("feature-layer-source:edit-failure",t.description,{code:t.code}):null}},i._prepareAddFeatures=function(e){const t=new Map,r=new Array(e.length);let i=null;for(let n=0;n<e.length;n++){const o=e[n],s=this._serializeFeature(o);i||null==o.geometry||(i=o.geometry.type),r[n]=s,t.set(`${s.uid}`,o)}const o=this;return{features:r,inferredGeometryType:i,finish(e){const r=o.sourceJSON.objectIdField;for(const i in e){const n=e[i],s=t.get(i);s&&(s.attributes||(s.attributes={}),-1===n?delete s.attributes[r]:s.attributes[r]=n,o._addIdToClientGraphic(s))}}}},i._addIdToClientGraphic=function(e){if(!this._idToClientGraphic)return;const t=this.sourceJSON.objectIdField,r=e.attributes&&e.attributes[t];null!=r&&this._idToClientGraphic.set(r,e)},i._requiresClientGraphicMapping=function(){return this._geometryTypeRequiresClientGraphicMapping(this._layerOrSourceGeometryType)},i._geometryRequiresClientGraphicMapping=function(e){return this._geometryTypeRequiresClientGraphicMapping(e.type)},i._geometryTypeRequiresClientGraphicMapping=function(e){return"mesh"===e||"multipatch"===e||"extent"===e},i._serializeFeature=function(e){const{attributes:t}=e,r=this._geometryForSerialization(e),i=(M++).toString();return r?{uid:i,geometry:r.toJSON(),attributes:t}:{uid:i,attributes:t}},i._geometryForSerialization=function(e){const{geometry:t}=e;if(null==t)return null;if(this._geometryRequiresClientGraphicMapping(t)){return t.extent?F.fromExtent(t.extent):null}return t},i._startWorker=async function(e){this._connection=await d.open("MemorySourceWorker",{strategy:u("feature-layers-workers")?"dedicated":"local",signal:e});const{fields:t,spatialReference:r,objectIdField:i,hasM:o,hasZ:n,timeInfo:s}=this.layer,a="defaults"===this.layer.originOf("spatialReference");await this._prepareClientMapping(this.items,e);const l=this._prepareAddFeatures(this.items);this.handles.add(this.on("before-changes",(e=>{R.error("Source modifications will not propagate after layer has been loaded. Please use .applyEdits() instead"),e.preventDefault()})));const c={features:l.features,fields:t&&t.map((e=>e.toJSON())),geometryType:G.typeKebabDictionary.toJSON(this._workerGeometryType),hasM:"mesh"!==this._layerOrSourceGeometryType&&o,hasZ:"mesh"===this._layerOrSourceGeometryType||n,objectIdField:i,spatialReference:a?null:r&&r.toJSON(),timeInfo:s?s.toJSON():null},p=await this._connection.invoke("load",c,{signal:e});for(const u of p.warnings)R.warn(u.message,{layer:this.layer,warning:u});p.featureErrors.length&&R.warn(`Encountered ${p.featureErrors.length} validation errors while loading features`,p.featureErrors);const y=p.layerDefinition;this._geometryTypeRequiresClientGraphicMapping(l.inferredGeometryType)&&(y.geometryType=G.typeKebabDictionary.toJSON(l.inferredGeometryType)),this.sourceJSON=y,this._requiresClientGraphicMapping()&&(this._idToClientGraphic=new Map),l.finish(p.assignedObjectIds)},t._createClass(r,[{key:"_workerGeometryType",get:function(){const e=this.layer?.geometryType;return e?this._geometryTypeRequiresClientGraphicMapping(e)?"polygon":e:null}},{key:"_layerOrSourceGeometryType",get:function(){return this.layer?.geometryType??this.sourceJSON?.geometryType}}]),r}(l.LoadableMixin(p.EsriPromiseMixin(a.HandleOwnerMixin(n)))),r.__decorate([g.shared({Type:o,ensureType:h.ensureType(o)})],e.MemorySource.prototype,"itemType",void 0),r.__decorate([y.property()],e.MemorySource.prototype,"type",void 0),r.__decorate([y.property({constructOnly:!0})],e.MemorySource.prototype,"layer",void 0),r.__decorate([y.property({readOnly:!0})],e.MemorySource.prototype,"_workerGeometryType",null),r.__decorate([y.property()],e.MemorySource.prototype,"sourceJSON",void 0),e.MemorySource=r.__decorate([m.subclass(O)],e.MemorySource),Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
