/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["../../chunks/_rollupPluginBabelHelpers","../../geometry","../../geometry/support/GeographicTransformation","./PixelBlock","./rasterFormats/RasterCodec","./rasterFunctions/pixelUtils","./rasterFunctions/rasterFunctionHelper","./rasterFunctions/rasterProjectionHelper","./rasterFunctions/stretchUtils","./rasterFunctions/vectorFieldUtils","./rasterTransforms/utils","../../renderers/support/RasterSymbolizer","../../views/2d/engine/flow/dataUtils","../../geometry/Extent","../../geometry/Point"],(function(e,t,r,s,o,i,n,a,c,l,m,u,f,p,d){"use strict";return function(){function t(){}var S=t.prototype;return S.convertVectorFieldData=function(e){const t=s.fromJSON(e.pixelBlock),r=l.convertVectorFieldData(t,e.type);return Promise.resolve(null!=r?r.toJSON():null)},S.computeStatisticsHistograms=function(e){const t=s.fromJSON(e.pixelBlock),r=c.computeStatisticsHistograms(t);return Promise.resolve(r)},S.decode=async function(e){const t=await o.decode(e.data,e.options);return t&&t.toJSON()},S.symbolize=function(e){e.pixelBlock=s.fromJSON(e.pixelBlock),e.extent=e.extent?p.fromJSON(e.extent):null;const t=this.symbolizer.symbolize(e);return Promise.resolve(null!=t?t.toJSON():null)},S.updateSymbolizer=async function(e){this.symbolizer=u.fromJSON(e.symbolizerJSON),e.histograms&&"rasterStretch"===this.symbolizer?.rendererJSON.type&&(this.symbolizer.rendererJSON.histograms=e.histograms)},S.updateRasterFunction=async function(e){this.rasterFunction=n.create(e.rasterFunctionJSON)},S.process=async function(e){const t=this.rasterFunction.process({extent:p.fromJSON(e.extent),primaryPixelBlocks:e.primaryPixelBlocks.map((e=>null!=e?s.fromJSON(e):null)),primaryPixelSizes:e.primaryPixelSizes?.map((e=>null!=e?d.fromJSON(e):null)),primaryRasterIds:e.primaryRasterIds});return null!=t?t.toJSON():null},S.stretch=function(e){const t=this.symbolizer.simpleStretch(s.fromJSON(e.srcPixelBlock),e.stretchParams);return Promise.resolve(null!=t&&t.toJSON())},S.estimateStatisticsHistograms=function(e){const t=c.estimateStatisticsHistograms(s.fromJSON(e.srcPixelBlock));return Promise.resolve(t)},S.split=function(e){const t=i.split(s.fromJSON(e.srcPixelBlock),e.tileSize,e.maximumPyramidLevel);return t&&t.forEach(((e,r)=>{t.set(r,e?.toJSON())})),Promise.resolve(t)},S.mosaicAndTransform=async function(e){const t=e.srcPixelBlocks.map((e=>e?new s(e):null)),r=i.mosaic(t,e.srcMosaicSize,{blockWidths:e.blockWidths,alignmentInfo:e.alignmentInfo,clipOffset:e.clipOffset,clipSize:e.clipSize});let o,n=r;return e.coefs&&(n=i.approximateTransform(r,e.destDimension,e.coefs,e.sampleSpacing,e.interpolation)),e.projectDirections&&e.gcsGrid&&(o=i.getLocalArithmeticNorthRotations(e.destDimension,e.gcsGrid),n=l.convertToLocalDirections(n,e.isUV?"vector-uv":"vector-magdir",o)),{pixelBlock:n?.toJSON(),localNorthDirections:o}},S.createFlowMesh=async function(e,t){const r={data:new Float32Array(e.flowData.buffer),mask:new Uint8Array(e.flowData.maskBuffer),width:e.flowData.width,height:e.flowData.height},{vertexData:s,indexData:o}=await f.createFlowMesh(e.meshType,e.simulationSettings,r,t.signal);return{result:{vertexBuffer:s.buffer,indexBuffer:o.buffer},transferList:[s.buffer,o.buffer]}},S.getProjectionOffsetGrid=async function(e){const t=p.fromJSON(e.projectedExtent),s=p.fromJSON(e.srcBufferExtent);let o=null;e.datumTransformationSteps&&(o=new r({steps:e.datumTransformationSteps})),(e.includeGCSGrid||a.requirePE(t.spatialReference,s.spatialReference,o))&&await a.load();const i=e.rasterTransform?m.readTransform(e.rasterTransform):null;return a.getProjectionOffsetGrid({...e,projectedExtent:t,srcBufferExtent:s,datumTransformation:o,rasterTransform:i})},e._createClass(t)}()}));
