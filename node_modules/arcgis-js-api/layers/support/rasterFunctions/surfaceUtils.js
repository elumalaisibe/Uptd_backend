/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["exports","../PixelBlock","./pixelUtils"],(function(t,e,i){"use strict";const s=1,l=1/111e3;function n(t){let{altitude:e,azimuth:i}=t;const{hillshadeType:s,pixelSizePower:n=1,pixelSizeFactor:a=1,scalingType:o,isGCS:r,resolution:c}=t,u="multi-directional"===s?2*t.zFactor:t.zFactor,{x:h,y:d}=c;let f=u/(8*h),x=u/(8*d);if(r&&u>.001&&(f/=l,x/=l),"adjusted"===o)if(r){const t=h*l,e=d*l;f=(u+t**n*a)/(8*t),x=(u+e**n*a)/(8*e)}else f=(u+h**n*a)/(8*h),x=(u+d**n*a)/(8*d);let p=(90-e)*Math.PI/180,y=Math.cos(p),w=(360-i+90)*Math.PI/180,M=Math.sin(p)*Math.cos(w),k=Math.sin(p)*Math.sin(w);const m=[315,270,225,360,180,0],A=[60,60,60,60,60,90],P=new Float32Array([3,5,3,2,1,4]),g=P.reduce(((t,e)=>t+e)),z=P.map((t=>t/g)),F="multi-directional"===s?m.length:1,C=new Float32Array(6),v=new Float32Array(6),S=new Float32Array(6);if("multi-directional"===s)for(let l=0;l<F;l++)e=A[l],i=m[l],p=(90-e)*Math.PI/180,y=Math.cos(p),w=(360-i+90)*Math.PI/180,M=Math.sin(p)*Math.cos(w),k=Math.sin(p)*Math.sin(w),C[l]=y,v[l]=M,S[l]=k;else C.fill(y),v.fill(M),S.fill(k);return{resolution:c,factor:[f,x],sinZcosA:M,sinZsinA:k,cosZ:y,sinZcosAs:v,sinZsinAs:S,cosZs:C,weights:z,hillshadeType:["traditional","multi-directional"].indexOf(s)}}function a(t,e){const{width:i,height:l}=t,n=i*l,a=new Uint8Array(n),o=null!=t.mask;let r;if(o){r=new Uint8Array(t.mask);for(let t=0;t<r.length;t++)r[t]&&(a[t]=1,r[t]=1)}const c=t.pixels[0],u=new Float32Array(n),h=new Float32Array(n);let d,f=0;if(e){const{resolution:t}=e,i=t?(t.x+t.y)/2:1;f=200*e.zFactor/(i*i),d=new Float32Array(n)}const x=e?.curvatureType;let p,y,w,M,k,m,A,P;for(let g=s;g<l-s;g++){const t=g*i;for(let e=s;e<i-s;e++){const s=t+e;if(!r||0!==r[s]){if(r){if(r[s-i-1]+r[s-i]+r[s-i+1]+r[s-1]+r[s+1]+r[s+i-1]+r[s+i]+r[s+i+1]<7){a[s]=0;continue}p=r[s-i-1]?c[s-i-1]:c[s],y=r[s-i]?c[s-i]:c[s],w=r[s-i+1]?c[s-i+1]:c[s],M=r[s-1]?c[s-1]:c[s],k=r[s+1]?c[s+1]:c[s],m=r[s+i-1]?c[s+i-1]:c[s],A=r[s+i]?c[s+i]:c[s],P=r[s+i+1]?c[s+i+1]:c[s]}else p=c[s-i-1],y=c[s-i],w=c[s-i+1],M=c[s-1],k=c[s+1],m=c[s+i-1],A=c[s+i],P=c[s+i+1];if(u[s]=w+k+k+P-(p+M+M+m),h[s]=m+A+A+P-(p+y+y+w),null!=d){const t=c[s],e=.5*(M+k)-t,i=.5*(y+A)-t;if("standard"===x)d[s]=-f*(e+i);else{const t=(-p+w+m-P)/4,l=(-M+k)/2,n=(y-A)/2,a=l*l,o=n*n,r=a+o;r&&(d[s]="profile"===x?f*(e*a+i*o+t*l*n)/r:-f*(e*o+i*a-t*l*n)/r)}}}}}return{outMask:o?a:null,dzxs:u,dzys:h,curvatures:d}}function o(t,e,i){for(let s=0;s<i;s++)t[s*e]=t[s*e+1],t[(s+1)*e-1]=t[(s+1)*e-2];for(let s=1;s<e-1;s++)t[s]=t[s+e],t[s+(i-1)*e]=t[s+(i-2)*e]}function r(t,l){if(!i.isValidPixelBlock(t))return t;const{factor:r,sinZcosA:c,sinZsinA:u,cosZ:h,sinZcosAs:d,sinZsinAs:f,cosZs:x,weights:p}=n(l),[y,w]=r,M="traditional"===l.hillshadeType,{width:k,height:m}=t,A=new Uint8Array(k*m),{dzxs:P,dzys:g,outMask:z}=a(t);for(let e=s;e<m-s;e++){const t=e*k;for(let e=s;e<k-s;e++){const i=t+e;if(!z||z[i]){const t=P[i]*y,e=g[i]*w,s=Math.sqrt(1+t*t+e*e);let l=0;if(M){let i=255*(h+u*e-c*t)/s;i<0&&(i=0),l=i}else{const i=f.length;for(let n=0;n<i;n++){let i=255*(x[n]+f[n]*e-d[n]*t)/s;i<0&&(i=0),l+=i*p[n]}}A[i]=255&l}}}o(A,k,m);return new e({width:k,height:m,pixels:[A],mask:z,pixelType:"u8",validPixelCount:t.validPixelCount,statistics:[{minValue:0,maxValue:255}]})}function c(t,e,s,l){if(!i.isValidPixelBlock(t)||!i.isValidPixelBlock(e))return;const{min:n,max:a}=l,o=t.pixels[0],{pixels:r,mask:c}=e,u=r[0],h=255.00001/(a-n),d=new Uint8ClampedArray(u.length),f=new Uint8ClampedArray(u.length),x=new Uint8ClampedArray(u.length),p=s.length-1;for(let i=0;i<u.length;i++){if(c&&0===c[i])continue;const t=Math.floor((u[i]-n)*h),[e,l]=s[t<0?0:t>p?p:t],a=o[i],r=a*l,y=r*(1-Math.abs(e%2-1)),w=a-r;switch(Math.floor(e)){case 0:d[i]=r+w,f[i]=y+w,x[i]=w;break;case 1:d[i]=y+w,f[i]=r+w,x[i]=w;break;case 2:d[i]=w,f[i]=r+w,x[i]=y+w;break;case 3:d[i]=w,f[i]=y+w,x[i]=r+w;break;case 4:d[i]=y+w,f[i]=w,x[i]=r+w;break;case 5:case 6:d[i]=r+w,f[i]=w,x[i]=y+w}}t.pixels=[d,f,x],t.updateStatistics()}function u(t,n){if(!i.isValidPixelBlock(t))return t;const r=n.zFactor,c=n.pixelSizePower??1,u=n.pixelSizeFactor??1,h=n.slopeType,d=n.isGCS,{x:f,y:x}=n.resolution;let p=r/(8*f),y=r/(8*x);d&&Math.abs(r-1)<1e-4&&(p/=l,y/=l),"adjusted"===h&&(p=(r+f**c*u)/(8*f),y=(r+x**c*u)/(8*x));const{dzxs:w,dzys:M,outMask:k}=a(t),{width:m,height:A}=t,P=new Float32Array(m*A);for(let e=s;e<A-s;e++){const t=e*m;for(let e=s;e<m-s;e++){const i=t+e;if(!k||k[i]){const s=w[i]*p,l=M[i]*y,n=Math.sqrt(s*s+l*l);P[t+e]="percent-rise"===h?100*n:57.2957795*Math.atan(n)}}}o(P,m,A);const g=new e({width:m,height:A,pixels:[P],mask:k,pixelType:"f32",validPixelCount:t.validPixelCount});return g.updateStatistics(),g}function h(t,l={}){if(!i.isValidPixelBlock(t))return t;const{resolution:n}=l,r=n?1/n.x:1,c=n?1/n.y:1,{dzxs:u,dzys:h,outMask:d}=a(t),{width:f,height:x}=t,p=new Float32Array(f*x);for(let e=s;e<x-s;e++){const t=e*f;for(let e=s;e<f-s;e++){const i=t+e;if(!d||d[i]){const s=u[i]*r,l=h[i]*c;let n=-1;0===s&&0===l||(n=90-57.29578*Math.atan2(l,-s),n<0&&(n+=360),360===n?n=0:n>360&&(n%=360)),p[t+e]=n}}}o(p,f,x);return new e({width:f,height:x,pixels:[p],mask:d,pixelType:"f32",validPixelCount:t.validPixelCount,statistics:[{minValue:-1,maxValue:360}]})}function d(t,s){if(!i.isValidPixelBlock(t))return t;const{curvatures:l,outMask:n}=a(t,s),{width:r,height:c}=t;o(l,r,c);const u=new e({width:r,height:c,pixels:[l],mask:n,pixelType:"f32",validPixelCount:t.validPixelCount});return u.updateStatistics(),u}t.GCS_FACTOR=l,t.aspect=h,t.calculateHillshadeParams=n,t.curvature=d,t.hillshade=r,t.slope=u,t.tintHillshade=c,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
