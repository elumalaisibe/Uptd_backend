/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["exports","../../../core/maybe","../PixelBlock","../rasterFormats/pixelRangeUtils","../../../renderers/support/stretchRendererUtils"],(function(t,n,e,s,i){"use strict";const a=1,o=[.299,.587,.114];function r(t,n=256){n=Math.min(n,256);const{size:e,counts:s}=t,i=new Uint8Array(e),a=s.reduce(((t,e)=>t+e/n),0);let o=0,r=0,l=0,u=a;for(let f=0;f<e;f++)if(l+=s[f],!(f<e-1&&l+s[f+1]<u)){for(;o<n-1&&u<l;)o++,u+=a;for(let t=r;t<=f;t++)i[t]=o;r=f+1}for(let f=r;f<e;f++)i[f]=n-1;return i}function l(t){const{minCutOff:n,maxCutOff:e,gamma:s,pixelType:i,rounding:a}=t,o=t.outMin||0,r=t.outMax||255;if(!["u8","u16","s8","s16"].includes(i))return null;const l=n.length;let f,c,m=0;"s8"===i?m=-127:"s16"===i&&(m=-32767);let h=256;["u16","s16"].includes(i)&&(h=65536);const g=[],d=[],p=r-o;for(f=0;f<l;f++)d[f]=e[f]-n[f],g[f]=0===d[f]?0:p/d[f];let x;const y=[];let b,v,C;if(s&&s.length>=l){const t=M(l,s);for(f=0;f<l;f++){for(C=[],c=0;c<h;c++)if(0!==d[f])if(b=c+m,x=(b-n[f])/d[f],v=1,s[f]>1&&(v-=(1/p)**(x*t[f])),b<e[f]&&b>n[f]){const t=v*p*x**(1/s[f])+o;C[c]="floor"===a?Math.floor(t):"round"===a?Math.round(t):t}else b>=e[f]?C[c]=r:C[c]=o;else C[c]=o;y[f]=C}}else for(f=0;f<l;f++){for(C=[],c=0;c<h;c++)if(b=c+m,b<=n[f])C[c]=o;else if(b>=e[f])C[c]=r;else{const t=(b-n[f])*g[f]+o;C[c]="floor"===a?Math.floor(t):"round"===a?Math.round(t):t}y[f]=C}if(null!=t.contrastOffset){const n=u(t.contrastOffset,t.brightnessOffset);for(f=0;f<l;f++)for(C=y[f],c=0;c<h;c++)C[c]=n[C[c]]}return{lut:y,offset:m}}function u(t,n){const e=Math.min(Math.max(t,-100),100),s=Math.min(Math.max(n??0,-100),100),i=255,a=128;let o=0,r=0;const l=new Uint8Array(256);for(o=0;o<256;o++)e>0&&e<100?r=(200*o-100*i+2*i*s)/(2*(100-e))+a:e<=0&&e>-100?r=(200*o-100*i+2*i*s)*(100+e)/2e4+a:100===e?(r=200*o-100*i+(i+1)*(100-e)+2*i*s,r=r>0?i:0):-100===e&&(r=a),l[o]=r>i?i:r<0?0:r;return l}function f(t,n,e){const s=[];for(let i=0;i<n.length;i++){let a=0,r=0,l=0;"min"in n[i]?({min:a,max:r,avg:l}=n[i]):[a,r,l]=n[i];let u=l??0;"u8"!==t&&(u=255*(u-a)/(r-a)),e&&(u*=o[i]),s.push(c(u))}return s}function c(t){if(t<=0||t>=255)return a;let n=0;150!==t&&(n=t<=150?45*Math.cos(.01047*t):17*Math.sin(.021*t));const e=255,s=t+n,i=Math.log(t/e),o=Math.log(s/e);if(0===o)return a;const r=i/o;return isNaN(r)?a:Math.min(9.9,Math.max(.01,r))}function m(t,n,e,s){let i=1/0,a=-1/0,o=0,r=0;const l=t.length;for(let x=0;x<l;x++){const e=t[x];n&&!n[x]||(i=e<i?e:i,a=e>a?e:a,o+=e,r++)}if(0===r)return{statistics:{min:0,max:0,avg:0,stddev:0},histogram:null};const u=o/r;let f=0;for(let x=0;x<l;x++)n&&!n[x]||(f+=(t[x]-u)**2);const c=n?n.filter((t=>t)).length:l,m={min:i,max:a,avg:u,stddev:c<=1?0:Math.sqrt(f/(c-1))};if(!s)return{statistics:m,histogram:null};if(["u8","s8","u4","u2","u1"].includes(e)){const e=a-i+1,s=new Uint32Array(e);for(let a=0;a<l;a++)n&&!n[a]||s[t[a]-i]++;return{statistics:m,histogram:{min:i-.5,max:a+.5,size:e,counts:s}}}const h=256,g=new Uint32Array(h),d=(a-i)/h;if(0===d)return{statistics:m,histogram:{min:i,max:a,size:1,counts:new Uint32Array(1).fill(r)}};const p=new Uint32Array(h+1);for(let x=0;x<l;x++)n&&!n[x]||p[Math.floor((t[x]-i)/d)]++;for(let x=0;x<h-1;x++)g[x]=p[x];return g[h-1]=p[h-1]+p[h],{statistics:m,histogram:{min:i,max:a,size:h,counts:g}}}function h(t){const{pixels:n,mask:e,pixelType:s,bandMasks:i}=t,a=n.map(((t,n)=>m(t,i?.[n]??e,s,!0)));return{statistics:a.map((({statistics:t})=>t)),histograms:a.map((({histogram:t})=>t))}}function g(t){if(null==t||!t.pixels?.length)return null;const{pixels:n,mask:e,bandMasks:s,pixelType:i}=t,a=t.width*t.height,o=n.length;let r,l,u,f,c;const m=[],h=[];let g,d,p,x,M,y,b,v,C,k;const w=256;for(f=0;f<o;f++){g=new Uint32Array(w),p=n[f];const o=s?.[f]??e;if("u8"===i)if(r=-.5,l=255.5,o)for(c=0;c<a;c++)o[c]&&g[p[c]]++;else for(c=0;c<a;c++)g[p[c]]++;else{let n=!1;t.statistics||(t.updateStatistics(),n=!0);const e=t.statistics;if(r=e[f].minValue,l=e[f].maxValue,u=(l-r)/w,0===u){!e||t.validPixelCount||n||t.updateStatistics();const s=(t.validPixelCount||t.width*t.height)/w;for(let t=0;t<w;t++)g[t]=Math.round(s*(t+1))-Math.round(s*t)}else{for(d=new Uint32Array(w+1),c=0;c<a;c++)o&&!o[c]||d[Math.floor((p[c]-r)/u)]++;for(c=0;c<w-1;c++)g[c]=d[c];g[w-1]=d[w-1]+d[w]}}for(m.push({min:r,max:l,size:w,counts:g}),x=0,M=0,v=0,c=0;c<w;c++)x+=g[c],M+=c*g[c];for(C=M/x,c=0;c<w;c++)v+=g[c]*(c-C)**2;k=Math.sqrt(v/(x-1)),u=(l-r)/w,y=(C+.5)*u+r,b=k*u,h.push({min:r,max:l,avg:y,stddev:b})}return{statistics:h,histograms:m}}function d(t){const n=[];for(let e=0;e<t.length;e++){const{min:s,max:i,size:a,counts:o}=t[e];let r=0,l=0;for(let t=0;t<a;t++)r+=o[t],l+=t*o[t];const u=l/r;let f=0;for(let t=0;t<a;t++)f+=o[t]*(t-u)**2;const c=(i-s)/a,m=(u+.5)*c+s,h=Math.sqrt(f/(r-1))*c;n.push({min:s,max:i,avg:m,stddev:h})}return n}function p(t,e){const{pixelBlock:a,bandIds:o,returnHistogramLut:l,rasterInfo:u}=e;let f=null,c=null,m=t.stretchType;if("number"==typeof m&&(m=i.stretchTypeFunctionEnum[m]),t.dra)if("minMax"===m&&null!=a&&a.statistics)f=a.statistics.map((t=>[t.minValue,t.maxValue,0,0]));else{const t=g(a);f=null!=t?t.statistics:null,c=null!=t?t.histograms:null}else f=t.statistics?.length>0?t.statistics:u.statistics,c="histograms"in t?t.histograms:void 0,c||(c=u.histograms);"percentClip"!==m&&"histogramEqualization"!==m||c?.length||(m="minMax");const h=f?.length||c?.length||u.bandCount,d=[],p=[];let M,y,b,v,C,k,w,z,O;f&&!Array.isArray(f[0])&&(f=f.map((t=>[t.min,t.max,t.avg,t.stddev])));const[S,U]=s.getPixelValueRange(u.pixelType);if(!f?.length){for(f=[],z=0;z<h;z++)f.push([S,U,1,1]);"standardDeviation"===m&&(m="minMax")}switch(m){case"none":for(z=0;z<h;z++)d[z]=S,p[z]=U;break;case"minMax":for(z=0;z<h;z++){const t=f[z];d[z]=t[0],p[z]=t[1]}break;case"standardDeviation":for(z=0;z<h;z++){const n=f[z];d[z]=n[2]-t.numberOfStandardDeviations*n[3],p[z]=n[2]+t.numberOfStandardDeviations*n[3],d[z]<n[0]&&(d[z]=n[0]),p[z]>n[1]&&(p[z]=n[1])}break;case"histogramEqualization":for(n.assertIsSome(c),z=0;z<h;z++)d[z]=c[z].min,p[z]=c[z].max;break;case"percentClip":for(n.assertIsSome(c),z=0;z<c.length;z++){for(M=c[z],C=new Uint32Array(M.size),v=[...M.counts],v.length>=20&&(v[0]=v[1]=v[2]=v[v.length-1]=v[v.length-2]=0),b=0,y=(M.max-M.min)/M.size,w=-.5===M.min&&1===y?.5:0,O=0;O<M.size;O++)b+=v[O],C[O]=b;for(k=(t.minPercent||0)*b/100,d[z]=M.min+w,O=0;O<M.size;O++)if(C[O]>k){d[z]=M.min+y*(O+w);break}for(k=(1-(t.maxPercent||0)/100)*b,p[z]=M.max+w,O=M.size-2;O>=0;O--)if(C[O]<k){p[z]=M.min+y*(O+2-w);break}if(p[z]<d[z]){const t=d[z];d[z]=p[z],p[z]=t}}break;default:for(z=0;z<h;z++){const t=f[z];d[z]=t[0],p[z]=t[1]}}let A,T,P;"histogramEqualization"===m?(n.assertIsSome(c),T=c[0].size||256,A=0,l&&(P=c.map((t=>r(t))))):(T=t.max||255,A=t.min||0);return x({minCutOff:d,maxCutOff:p,outMax:T,outMin:A,histogramLut:P},o)}function x(t,n){if(null==n||0===n.length)return t;const e=Math.max.apply(null,n),{minCutOff:s,maxCutOff:i,outMin:a,outMax:o,histogramLut:r}=t;return s.length===n.length||s.length<=e?t:{minCutOff:n.map((t=>s[t])),maxCutOff:n.map((t=>i[t])),histogramLut:r?n.map((t=>r[t])):null,outMin:a,outMax:o}}function M(t,n){const e=new Float32Array(t);for(let s=0;s<t;s++)n[s]>1?n[s]>2?e[s]=6.5+(n[s]-2)**2.5:e[s]=6.5+100*(2-n[s])**4:e[s]=1;return e}function y(t,n){if(null==t||!t.pixels?.length)return t;const{mask:s,bandMasks:i,width:a,height:o,pixels:r}=t,{minCutOff:l,maxCutOff:u,gamma:f}=n,c=n.outMin||0,m=n.outMax||255,h=a*o,g=n.outputPixelType||"u8",d=t.pixels.map((()=>e.createEmptyBand(g,h))),p=d.length,x=m-c,y=[],b=[];for(let e=0;e<p;e++)b[e]=u[e]-l[e],y[e]=0===b[e]?0:x/b[e];const v=g.startsWith("u")||g.startsWith("s"),C=f&&f.length>=p,k=!!n.isRenderer;if(C){const t=M(p,f);for(let n=0;n<p;n++){const e=i?.[n]??s;for(let s=0;s<h;s++)if(null==e||e[s]){if(0===b[n]){d[n][s]=c;continue}const e=r[n][s],i=(e-l[n])/b[n];let a=1;if(f[n]>1&&(a-=(1/x)**(i*t[n])),e<u[n]&&e>l[n]){const t=a*x*i**(1/f[n])+c;d[n][s]=k?Math.floor(t):v?Math.round(t):t}else e>=u[n]?d[n][s]=m:d[n][s]=c}}}else for(let e=0;e<p;e++){const t=i?.[e]??s;for(let n=0;n<h;n++)if(null==t||t[n]){const t=r[e][n];if(t<u[e]&&t>l[e]){const s=(t-l[e])*y[e]+c;d[e][n]=k?Math.floor(s):v?Math.round(s):s}else t>=u[e]?d[e][n]=m:d[e][n]=c}}const w=new e({width:a,height:o,mask:s,bandMasks:i,pixels:d,pixelType:g});return w.updateStatistics(),w}t.computeGammaCorrection=M,t.computeGammaValues=f,t.computeStatisticsHistograms=h,t.createContrastBrightnessLUT=u,t.createHistogramEqualizationLUT=r,t.createStretchLUT=l,t.estimateStatisticsFromHistograms=d,t.estimateStatisticsHistograms=g,t.getStretchCutoff=p,t.stretch=y,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
