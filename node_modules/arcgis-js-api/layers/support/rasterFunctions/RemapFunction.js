/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["../../../chunks/_rollupPluginBabelHelpers","../../../chunks/tslib.es6","../../../core/mathUtils","../../../core/accessorSupport/decorators/property","../../../core/accessorSupport/ensureType","../../../core/arrayUtils","../../../core/has","../../../core/accessorSupport/decorators/subclass","../rasterFormats/pixelRangeUtils","./BaseRasterFunction","./pixelUtils","./RemapFunctionArguments"],(function(t,e,n,s,a,o,u,r,l,i,p,c){"use strict";let m=function(e){function s(){var t;return(t=e.apply(this,arguments)||this).functionName="Remap",t.functionArguments=null,t.rasterArgumentNames=["raster"],t.lookup=null,t}t._inherits(s,e);var a=s.prototype;return a._bindSourceRasters=function(){const t=this.sourceRasterInfos[0].clone(),{pixelType:e}=t;this.outputPixelType=this._getOutputPixelType(e),t.pixelType=this.outputPixelType,t.colormap=null,t.histograms=null,t.bandCount=1,t.attributeTable=null;const{statistics:n}=t,{allowUnmatched:s,outputValues:a,inputRanges:o,noDataRanges:u,isLastInputRangeInclusive:r}=this.functionArguments;if(null!=n&&n.length&&a?.length)if(s){const e=Math.min.apply(null,[...a,n[0].min]),s=Math.max.apply(null,[...a,n[0].max]);t.statistics=[{...n[0],min:e,max:s}]}else{let e=a[0],s=e;for(let t=0;t<a.length;t++)e=e>a[t]?a[t]:e,s=s>a[t]?s:a[t];t.statistics=[{...n[0],min:e,max:s}]}this.rasterInfo=t,this.lookup=s?null:p.createRemapLUT({srcPixelType:e,inputRanges:o,outputValues:a,noDataRanges:u,allowUnmatched:s,isLastInputRangeInclusive:r,outputPixelType:this.outputPixelType});return{success:!0,supportsGPU:(!a||a.length<=p.MAX_MAP_SIZE_GPU)&&(!u||u.length<=p.MAX_MAP_SIZE_GPU)}},a._processPixels=function(t){const e=t.pixelBlocks?.[0];if(null==e)return null;const{lookup:n,outputPixelType:s}=this;if(n){const t=p.lookupPixels(e,{lut:[n.lut],offset:n.offset,outputPixelType:s});return null!=t&&n.mask&&(t.mask=p.lookupBandValues(e.pixels[0],e.mask,n.mask,n.offset,"u8")),t}const{inputRanges:a,outputValues:o,noDataRanges:u,allowUnmatched:r,isLastInputRangeInclusive:l}=this.functionArguments;return p.remap(e,{inputRanges:a,outputValues:o,noDataRanges:u,outputPixelType:s,allowUnmatched:r,isLastInputRangeInclusive:l})},a._getWebGLParameters=function(){const{allowUnmatched:t,noDataRanges:e,isLastInputRangeInclusive:s}=this.functionArguments,a=new Float32Array(3*p.MAX_MAP_SIZE_GPU),o=1e-5,u=this.functionArguments.inputRanges??[],r=this.functionArguments.outputValues??[],i=r.length;for(let l=0;l<p.MAX_MAP_SIZE_GPU;l++)a[3*l]=u[2*l]??n.NUMBER_MAX_FLOAT32-1,a[3*l+1]=u[2*l+1]??n.NUMBER_MAX_FLOAT32,a[3*l+2]=r[l]??0,l<i&&(l>0&&(a[3*l]-=o),(l<i-1||!s)&&(a[3*l+1]-=o));const c=new Float32Array(2*p.MAX_MAP_SIZE_GPU);c.fill(n.NUMBER_MAX_FLOAT32),e?.length&&c.set(e);return{allowUnmatched:t,rangeMaps:a,noDataRanges:c,clampRange:l.getPixelValueRange(this.outputPixelType)}},t._createClass(s)}(i);e.__decorate([s.property({json:{write:!0,name:"rasterFunction"}})],m.prototype,"functionName",void 0),e.__decorate([s.property({type:c,json:{write:!0,name:"rasterFunctionArguments"}})],m.prototype,"functionArguments",void 0),e.__decorate([s.property()],m.prototype,"rasterArgumentNames",void 0),e.__decorate([s.property({json:{write:!0}})],m.prototype,"lookup",void 0),m=e.__decorate([r.subclass("esri.layers.support.rasterFunctions.RemapFunction")],m);return m}));
