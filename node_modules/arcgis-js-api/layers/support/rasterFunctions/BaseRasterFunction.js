/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["../../../chunks/_rollupPluginBabelHelpers","../../../chunks/tslib.es6","../../../core/JSONSupport","../../../core/accessorSupport/decorators/property","../../../core/accessorSupport/decorators/cast","../../../core/arrayUtils","../../../core/has","../../../core/accessorSupport/decorators/subclass","../PixelBlock","../RasterInfo"],(function(t,e,s,r,n,o,i,a,u,p){"use strict";const c=new Set(["slope","aspect","curvature","hillshade","shadedrelief"]);let l=function(e){function s(){var t;return(t=e.apply(this,arguments)||this).functionArguments=null,t.readingBufferSize=0,t.id=-1,t.isNoopProcess=!1,t.rawInputBandIds=[],t.isInputBandIdsSwizzled=!1,t.swizzledBandSelection=[],t.isBranch=!1,t._bindingResult=null,t}t._inherits(s,e);var r=s.prototype;return r.bind=function(t,e=!1,s=-1){this.id=s+1;const r=this._getRasterValues();let n=!0;for(let o=0;o<r.length;o++){const s=r[o];if(null!=s&&this._isRasterFunctionValue(s)){const r=s.bind(t,e,this.id+o);if(!r.success)return this._bindingResult=r,r;n=n&&r.supportsGPU}}return!this.rasterInfo||e?(this.sourceRasterInfos=this._getSourceRasterInfos(t),this._bindingResult=this._bindSourceRasters(),this._bindingResult.success&&this._patchRasterInfo(),this._bindingResult.supportsGPU=n&&this._bindingResult.supportsGPU,this.processInputBandIds(),this._bindingResult):(this._bindingResult={success:!0,supportsGPU:!0},this.processInputBandIds(),this._bindingResult)},r.process=function(t){const e=this._getRasterValues(),s=0===e.length?t.pixelBlocks??t.primaryPixelBlocks:e.map((e=>this._readRasterValue(e,t)));return this._processPixels({...t,pixelBlocks:s})},r.processInputBandIds=function(){const t=this._getRasterValues().filter(this._isRasterFunctionValue);let e;if(t.length>1){const e=t.map((t=>t.processInputBandIds()[0]));this.rawInputBandIds=e,this.isInputBandIdsSwizzled=this.rawInputBandIds.some(((t,e)=>t!==e));const s=t.filter((t=>"ExtractBand"===t.functionName));return s.length&&s.forEach(((t,e)=>{t.isInputBandIdsSwizzled=!0,t.swizzledBandSelection=[e,e,e]})),this.rawInputBandIds}const s=t[0];if(s){if(e=s.processInputBandIds(),s.isInputBandIdsSwizzled)return this.rawInputBandIds=e,e}else{e=[];const{bandCount:t}=this.sourceRasterInfos[0];for(let s=0;s<t;s++)e.push(s)}const r=this._getInputBandIds(e);return this.isInputBandIdsSwizzled=r.some(((t,e)=>t!==e)),this.rawInputBandIds=r,this.rawInputBandIds},r.getPrimaryRasters=function(){const t=[],e=[];return this._getPrimaryRasters(this,t,e),{rasters:t,rasterIds:e}},r.getWebGLProcessorDefinition=function(){const t=this._getWebGLParameters(),{raster:e,rasters:s}=this.functionArguments;return s&&Array.isArray(s)&&s.length?(t.rasters=s.map((t=>this._isRasterFunctionValue(t)?t.getWebGLProcessorDefinition():"number"==typeof t?{name:"Constant",parameters:{value:t},pixelType:"f32",id:-1,isNoopProcess:!1}:{name:"Identity",parameters:{value:t},pixelType:"f32",id:-1,isNoopProcess:!1})),t.rasters.some((t=>null!=t))||(t.rasters=null)):this._isRasterFunctionValue(e)&&(t.raster=e.getWebGLProcessorDefinition()),{name:this.functionName,parameters:t,pixelType:this.outputPixelType,id:this.id,isNoopProcess:this.isNoopProcess}},r._getOutputPixelType=function(t){return"unknown"===this.outputPixelType?t:this.outputPixelType??t},r._getWebGLParameters=function(){return{}},r._getInputBandIds=function(t){return t},r._isOutputRoundingNeeded=function(){const{outputPixelType:t}=this;return(t?.startsWith("u")||t?.startsWith("s"))??!1},r._getRasterValues=function(){const{rasterArgumentNames:t}=this;return"rasters"===t[0]?this.functionArguments.rasters??[]:t.map((t=>this.functionArguments[t])).flat()},r._getSourceRasterInfos=function(t){const e=this._getRasterValues(),{rasterInfos:s,rasterIds:r}=t;if(0===e.length)return s;const n=e.map((t=>t&&"object"==typeof t&&"bind"in t&&t.rasterInfo?t.rasterInfo:"string"==typeof t&&r.includes(t)?s[r.indexOf(t)]:"number"!=typeof t?s[0]:void 0)),o=n.find((t=>t))??s[0];return n.forEach(((t,e)=>{void 0===t&&(n[e]=o)})),n},r._getPrimaryRasterId=function(t){return t?.url},r._getPrimaryRasters=function(t,e=[],s=[]){for(let r=0;r<t.sourceRasters.length;r++){const n=t.sourceRasters[r];if("number"!=typeof n)if("bind"in n)this._getPrimaryRasters(n,e,s);else{const t=n,r=this._getPrimaryRasterId(t);if(null==r)continue;s.includes(r)||(this.mainPrimaryRasterId===r?(e.unshift(t),s.unshift(r)):(e.push(t),s.push(r)))}}},r._isRasterFunctionValue=function(t){return null!=t&&"object"==typeof t&&"getWebGLProcessorDefinition"in t},r._readRasterValue=function(t,e){const{primaryPixelBlocks:s}=e;if(null==t||"$$"===t){const t=s[0];return null==t?null:t.clone()}if("string"==typeof t){const r=e.primaryRasterIds.indexOf(t);return-1===r?null:s[r]}if("number"==typeof t){const e=s[0];if(null==e)return null;const{width:r,height:n,pixelType:o,mask:i}=e,a=i?new Uint8Array(i):null,p=new Float32Array(r*n);p.fill(t);const c=this.sourceRasterInfos[0].bandCount,l=new Array(c).fill(p);return new u({width:r,height:n,pixelType:o,pixels:l,mask:a})}return t.process(e)},r._patchRasterInfo=function(){const{rasterInfo:t}=this;if(!t?.keyProperties)return;const{bandCount:e,keyProperties:s,statistics:r,histograms:n}=t,o=s.BandProperties;o&&o.length!==e&&(t.keyProperties={...s,BandProperties:void 0}),r&&r.length!==e&&(t.statistics=r.length>e?r.slice(0,e):null),n&&n.length!==e&&(t.histograms=n.length>e?n.slice(0,e):null),s.BAND_COUNT&&Number(s.BAND_COUNT)!==e&&(t.keyProperties={...s,BAND_COUNT:"string"==typeof s.BAND_COUNT?String(e):e})},t._createClass(s,[{key:"supportsGPU",get:function(){return this._bindingResult.supportsGPU}},{key:"flatWebGLFunctionChain",get:function(){const t=this.getWebGLProcessorDefinition();if(!t)return null;const e=[t],{parameters:s}=t;let r=s.rasters||s.raster&&[s.raster];for(;r?.length;){e.unshift(...r);const t=[];for(let e=0;e<r.length;e++){const{parameters:s}=r[e],n=s.rasters||s.raster&&[s.raster];n?.length&&t.push(...n)}r=t}for(let i=e.length-1;i>=0;i--)e[i].isNoopProcess&&e.splice(i,1);let n=!1;for(let i=0;i<e.length;i++){const t=e[i];t.id=e.length-i-1;const{rasters:s}=t.parameters;n=n||null!=s&&s.length>1}const o=e.some((({name:t})=>c.has(t.toLowerCase())));return{functions:e,hasBranches:n,hasSurfaceFunction:o}}}]),s}(s.JSONSupport);e.__decorate([r.property({json:{write:!0}})],l.prototype,"functionName",void 0),e.__decorate([r.property({json:{write:!0}})],l.prototype,"functionArguments",void 0),e.__decorate([r.property()],l.prototype,"rasterArgumentNames",void 0),e.__decorate([r.property({json:{write:!0}}),n.cast((t=>t?.toLowerCase()))],l.prototype,"outputPixelType",void 0),e.__decorate([r.property({json:{write:!0}})],l.prototype,"mainPrimaryRasterId",void 0),e.__decorate([r.property()],l.prototype,"sourceRasters",void 0),e.__decorate([r.property({type:[p],json:{write:!0}})],l.prototype,"sourceRasterInfos",void 0),e.__decorate([r.property({json:{write:!0}})],l.prototype,"rasterInfo",void 0),e.__decorate([r.property({json:{write:!0}})],l.prototype,"readingBufferSize",void 0),e.__decorate([r.property({json:{write:!0}})],l.prototype,"id",void 0),e.__decorate([r.property()],l.prototype,"isNoopProcess",void 0),e.__decorate([r.property()],l.prototype,"supportsGPU",null),e.__decorate([r.property()],l.prototype,"rawInputBandIds",void 0),e.__decorate([r.property()],l.prototype,"isInputBandIdsSwizzled",void 0),e.__decorate([r.property()],l.prototype,"swizzledBandSelection",void 0),e.__decorate([r.property()],l.prototype,"isBranch",void 0),e.__decorate([r.property()],l.prototype,"flatWebGLFunctionChain",null),e.__decorate([r.property()],l.prototype,"_bindingResult",void 0),l=e.__decorate([a.subclass("esri.layers.support.rasterFunctions.BaseRasterFunction")],l);return l}));
