/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["../../../chunks/_rollupPluginBabelHelpers","../../../chunks/tslib.es6","../../../geometry","../../../core/Error","../../../core/maybe","../../../core/urlUtils","../../../core/accessorSupport/decorators/property","../../../core/accessorSupport/ensureType","../../../core/arrayUtils","../../../core/has","../../../core/accessorSupport/decorators/subclass","../RasterInfo","../RasterStorageInfo","../TileInfo","../TilemapCache","./BaseRaster","../rasterFunctions/pixelUtils","../rasterTransforms/GCSShiftTransform","../../../rest/imageService/fetchRasterInfo","../../../geometry/SpatialReference","../../../geometry/Point","../../../geometry/Extent"],(function(e,t,i,s,a,l,n,r,o,c,u,h,f,m,p,d,y,x,g,v,S,I){"use strict";let w=function(t){function i(){var e;return(e=t.apply(this,arguments)||this)._levelOffset=0,e._tilemapCache=null,e._slices=null,e.datasetFormat="RasterTileServer",e.tileType=null,e}e._inherits(i,t);var n=i.prototype;return n.open=async function(e){await this.init();const t=e&&e.signal,i=this.sourceJSON?{data:this.sourceJSON}:await this.request(this.url,{query:{f:"json"},signal:t});i.ssl&&(this.url=this.url.replace(/^http:/i,"https:"));const n=i.data;if(this.sourceJSON=n,!n)throw new s("imageserverraster:open","cannot initialize tiled image service, missing service info");if(!n.tileInfo)throw new s("imageserverraster:open","use ImageryLayer to open non-tiled image services");this._fixScaleInServiceInfo();const r=["jpg","jpeg","png","png8","png24","png32","mixed"];this.tileType=n.cacheType,null==this.tileType&&(r.includes(n.tileInfo.format.toLowerCase())?this.tileType="Map":"lerc"===n.tileInfo.format.toLowerCase()?this.tileType="Elevation":this.tileType="Raster"),this.datasetName=n.name?.slice(n.name.indexOf("/")+1)??"";const o=await this._fetchRasterInfo({signal:t});if(null==o)throw new s("image-server-raster:open","cannot initialize image service");const c="Map"===this.tileType?_(n.tileInfo,n):m.fromJSON(n.tileInfo);a.assertIsSome(c);const[u,h]=this._computeMinMaxLOD(o,c),{extent:d,pixelSize:y}=o,x=.5/o.width*y.x,g=Math.max(y.x,y.y),{lods:v}=c;("Map"!==this.tileType&&0!==n.maxScale||Math.abs(y.x-y.y)>x||!v.some((e=>Math.abs(e.resolution-g)<x)))&&(y.x=y.y=u.resolution,o.width=Math.ceil((d.xmax-d.xmin)/y.x-.1),o.height=Math.ceil((d.ymax-d.ymin)/y.y-.1));const S=u.level-h.level,[I,w]=c.size,b=[],T=[];v.forEach(((e,t)=>{e.level>=h.level&&e.level<=u.level&&b.push({x:e.resolution,y:e.resolution}),t<v.length-1&&T.push(Math.round(10*e.resolution/v[t+1].resolution)/10)})),b.sort(((e,t)=>e.x-t.x));const M=this.computeBlockBoundary(d,I,w,c.origin,b,S),O=b.length>1?b.slice(1):null;let R;n.transposeInfo&&(R={tileSize:[n.transposeInfo.rows,n.transposeInfo.cols],packetSize:o.keyProperties?._yxs.PacketSize??0});const z=T.length<=1||T.length>=3&&T.slice(0,T.length-1).every((e=>e===T[0]))?T[0]??2:Math.round(10/(h.resolution/u.resolution)**(-1/S))/10;if(o.storageInfo=new f({blockWidth:c.size[0],blockHeight:c.size[1],pyramidBlockWidth:c.size[0],pyramidBlockHeight:c.size[1],pyramidResolutions:O,pyramidScalingFactor:z,compression:c.format,origin:c.origin,firstPyramidLevel:1,maximumPyramidLevel:S,tileInfo:c,transposeInfo:R,blockBoundary:M}),this._fixGCSShift(o),this._set("rasterInfo",o),n.capabilities.toLowerCase().includes("tilemap")){const e={tileInfo:o.storageInfo.tileInfo,parsedUrl:l.urlToObject(this.url),url:this.url,tileServers:[]};this._tilemapCache=new p.TilemapCache({layer:e})}},n.fetchRawTile=async function(e,t,i,s={}){const{storageInfo:a,extent:l}=this.rasterInfo,{transposeInfo:n}=a,r=null!=n&&!!s.transposedVariableName;if(this._slices&&!r&&null==s.sliceId)return null;const o=r?0:a.maximumPyramidLevel-e+this._levelOffset,c=`${this.url}/tile/${o}/${t}/${i}`,u=this._slices?r?{variable:s.transposedVariableName}:{sliceId:s.sliceId||0}:null,{data:h}=await this.request(c,{query:u,responseType:"array-buffer",signal:s.signal});if(!h)return null;const f=r?n.tileSize:a.tileInfo.size,m=await this.decodePixelBlock(h,{width:f[0],height:f[1],planes:null,pixelType:null,isPoint:"Elevation"===this.tileType,returnInterleaved:r,noDataValue:this.rasterInfo.noDataValue});if(null==m)return null;const p=a.blockBoundary[e];if("jpg"!==a.compression||i>p.minCol&&i<p.maxCol&&t>p.minRow&&t<p.maxRow)return m;const{origin:d,blockWidth:x,blockHeight:g}=a,{x:v,y:S}=this.getPyramidPixelSize(e),I=Math.round((l.xmin-d.x)/v)%x,w=Math.round((l.xmax-d.x)/v)%x||x,_=Math.round((d.y-l.ymax)/S)%g,b=Math.round((d.y-l.ymin)/S)%g||g,T=i===p.minCol?I:0,M=t===p.minRow?_:0,O=i===p.maxCol?w:x,R=t===p.maxRow?b:g;return y.setValidBoundary(m,{x:T,y:M},{width:O-T,height:R-M}),m},n.getSliceIndex=function(e){if(!this._slices||null==e||0===e.length)return null;const t=e;for(let i=0;i<this._slices.length;i++){const e=this._slices[i].multidimensionalDefinition;if(e.length===t.length&&!e.some((e=>{const i=t.find((t=>e.variableName===t.variableName&&t.dimensionName===e.dimensionName));if(!i)return!0;return(Array.isArray(e.values[0])?`${e.values[0][0]}-${e.values[0][1]}`:e.values[0])!==(Array.isArray(i.values[0])?`${i.values[0][0]}-${i.values[0][1]}`:i.values[0])})))return i}return null},n.fetchVariableStatisticsHistograms=async function(e,t){const i=this.request(this.url+"/statistics",{query:{variable:e,f:"json"},signal:t}).then((e=>e.data?.statistics)),s=this.request(this.url+"/histograms",{query:{variable:e,f:"json"},signal:t}).then((e=>e.data?.histograms)),a=await Promise.all([i,s]);return a[0]&&a[0].forEach((e=>{e.avg=e.mean,e.stddev=e.standardDeviation})),{statistics:a[0]||null,histograms:a[1]||null}},n.computeBestPyramidLevelForLocation=async function(e,t={}){if(!this._tilemapCache)return 0;let i=this.identifyPixelLocation(e,0,t.datumTransformation);if(null===i)return null;let s=0;const{maximumPyramidLevel:a}=this.rasterInfo.storageInfo;let l=a-s+this._levelOffset;const n=i.srcLocation;for(;l>=0;){try{if("available"===await this._tilemapCache.fetchAvailability(l,i.row,i.col,t))break}catch{}if(l--,s++,i=this.identifyPixelLocation(n,s,t.datumTransformation),null===i)return null}return-1===l||null==i?null:s},n._fetchRasterInfo=async function(e){const t=this.sourceJSON;if("Map"===this.tileType){const e=t.fullExtent||t.extent,i=Math.ceil((e.xmax-e.xmin)/t.pixelSizeX-.1),s=Math.ceil((e.ymax-e.ymin)/t.pixelSizeY-.1),a=v.fromJSON(t.spatialReference||e.spatialReference),l=new S({x:t.pixelSizeX,y:t.pixelSizeY,spatialReference:a});return new h({width:i,height:s,bandCount:3,extent:I.fromJSON(e),spatialReference:a,pixelSize:l,pixelType:"u8",statistics:null,keyProperties:{DataType:"processed"}})}const{signal:i}=e,s=g.fetchServiceRasterInfo(this.url,this.sourceJSON,{signal:i,query:this.ioConfig.customFetchParameters}),a=t.hasMultidimensions?this.request(`${this.url}/slices`,{query:{f:"json"},signal:i}).then((e=>e.data&&e.data.slices)).catch((()=>null)):null,l=await Promise.all([s,a]);return this._slices=l[1],l[0]},n._fixScaleInServiceInfo=function(){const{sourceJSON:e}=this;e.minScale&&e.minScale<0&&(e.minScale=0),e.maxScale&&e.maxScale<0&&(e.maxScale=0)},n._fixGCSShift=function(e){const{extent:t,spatialReference:i}=e;t.xmin>-1&&t.xmax>181&&i?.wkid&&i.isGeographic&&(e.nativeExtent=e.extent,e.transform=new x,e.extent=e.transform.forwardTransform(t))},n._computeMinMaxLOD=function(e,t){const{pixelSize:i}=e,s=.5/e.width*i.x,{lods:a}=t,l=t.lodAt(Math.max.apply(null,a.map((e=>e.level)))),n=t.lodAt(Math.min.apply(null,a.map((e=>e.level)))),{tileType:r}=this;if("Map"===r)return this._levelOffset=a[0].level,[l,n];if("Raster"===r){return[a.find((e=>e.resolution===i.x))??l,n]}const{minScale:o,maxScale:c}=this.sourceJSON;let u=l;c>0&&(u=a.find((e=>Math.abs(e.scale-c)<s)),u||(u=a.filter((e=>e.scale>c)).sort(((e,t)=>e.scale>t.scale?1:-1))[0]??l));let h=n;return o>0&&(h=a.find((e=>Math.abs(e.scale-o)<s))??n,this._levelOffset=h.level-n.level),[u,h]},e._createClass(i)}(d);function _(e,t){if(!e)return null;const{minScale:i,maxScale:s,minLOD:a,maxLOD:l}=t;if(null!=a&&null!=l)return m.fromJSON({...e,lods:e.lods.filter((({level:e})=>null!=e&&e>=a&&e<=l))});if(0!==i&&0!==s){const t=e=>Math.round(1e4*e)/1e4,a=i?t(i):1/0,l=s?t(s):-1/0;return m.fromJSON({...e,lods:e.lods.filter((e=>{const i=t(e.scale);return i<=a&&i>=l}))})}return m.fromJSON(e)}t.__decorate([n.property({type:String,json:{write:!0}})],w.prototype,"datasetFormat",void 0),t.__decorate([n.property()],w.prototype,"tileType",void 0),w=t.__decorate([u.subclass("esri.layers.support.rasterDatasets.ImageServerRaster")],w);return w}));
