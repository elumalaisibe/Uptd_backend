/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["../../../chunks/_rollupPluginBabelHelpers","../../../chunks/tslib.es6","../../../geometry","../../../request","../../../core/Error","../../../core/JSONSupport","../../../core/Logger","../../../core/maybe","../../../core/Promise","../../../core/promiseUtils","../../../core/accessorSupport/decorators/property","../../../core/accessorSupport/ensureType","../../../core/arrayUtils","../../../core/has","../../../core/accessorSupport/decorators/subclass","../arcgisLayerUrl","../commonProperties","../DimensionalDefinition","../LOD","../RasterStorageInfo","../TileInfo","./multidimensionalUtils","./RawBlockCache","../rasterFormats/pixelRangeUtils","../rasterFormats/RasterCodec","../rasterFunctions/pixelUtils","../rasterFunctions/rasterProjectionHelper","../rasterFunctions/vectorFieldUtils","../../../geometry/Extent","../../../geometry/Point"],(function(e,t,i,n,o,r,s,l,a,c,u,f,h,m,p,d,x,y,g,I,R,S,w,k,T,_,b,v,P,B){"use strict";const W=8,M=256;let C=function(t){function i(){var e;return(e=t.apply(this,arguments)||this).datasetName=null,e.datasetFormat=null,e.hasUniqueSourceStorageInfo=!0,e.rasterInfo=null,e.ioConfig={sampling:"closest"},e}e._inherits(i,t);var r=i.prototype;return r.init=async function(){const e=b.load();this.addResolvingPromise(e),await this.when()},r.normalizeCtorArgs=function(e){return e&&e.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:R.create(),...e.ioConfig}}),e},r.open=async function(e){throw new o("BaseRaster:open-not-implemented","open() is not implemented")},r.fetchTile=async function(e,t,i,n={}){const o=n.tileInfo||this.rasterInfo.storageInfo.tileInfo,r=this.getTileExtentFromTileInfo(e,t,i,o);return this.fetchPixels(r,o.size[0],o.size[1],n)},r.identify=async function(e,t={}){e=f.ensureClass(B,e).clone().normalize();const{multidimensionalDefinition:i,timeExtent:n}=t,{rasterInfo:o}=this,{hasMultidimensionalTranspose:r,multidimensionalInfo:s}=o;let{transposedVariableName:l}=t;const a=null!=s&&r&&(null!=n||S.isMultiSliceOrRangeDefinition(i));if(a&&!l){l=null!=i&&i.length>0?i[0].variableName??void 0:s.variables[0].name,t={...t,transposedVariableName:l}}t=this._getRequestOptionsWithSliceId(t);const{spatialReference:c,extent:u}=o,{datumTransformation:h}=t;let m=b.projectPoint(e,c,h);if(!u.intersects(m))return{location:m,value:null};if(null!=o.transform){const e=o.transform.inverseTransform(m);if(!o.nativeExtent.intersects(e))return{location:e,value:null};m=e}let p=0;const d=null!=l&&null!=s&&o.hasMultidimensionalTranspose;if("Function"===this.datasetFormat){const e=this.primaryRasters.rasters[0];if(d)return e.identify(m,t);const{pixelSize:i}=o,n=3,r=i.x*n/2,s=i.y*n/2,l=new P({xmin:m.x-r,xmax:m.x+r,ymin:m.y-s,ymax:m.y+s,spatialReference:c}),a={interpolation:"nearest"},{pixelBlock:u}=await e.fetchPixels(l,n,n,a),{pixelBlock:f}=await this.fetchPixels(l,n,n,a);if(null==u)return{location:m,value:null};const h=Math.floor(n*n*.5),p=!u.mask||u.mask[h]?u.pixels.map((e=>e[h])):null;let x;return null!=f&&(x=!f.mask||f.mask[h]?f.pixels.map((e=>e[h])):void 0),{location:m,value:p,processedValue:x,pyramidLevel:0}}if(!d)if(t.srcResolution){p=b.snapPyramid(t.srcResolution,o,this.ioConfig.sampling).pyramidLevel}else if(p=await this.computeBestPyramidLevelForLocation(e,t),null==p)return{location:m,value:null};const x=this.identifyPixelLocation(m,p,null,d);if(null===x)return{location:m,value:null};const{row:y,col:g,rowOffset:I,colOffset:R,blockWidth:k}=x,T=l??t.sliceId,_=w.getRasterId(this.url,T),v=`${p}/${y}/${g}`;let W=w.getBlock(_,null,v);null==W&&(W=this.fetchRawTile(p,y,g,t),w.putBlock(_,null,v,W));const M=await W;if(null==M||!M.pixels?.length)return{location:m,value:null};const C=I*k+R;return this._processIdentifyResult(M,{srcLocation:m,position:C,pyramidLevel:p,useTransposedTile:!!d,requestSomeSlices:a,identifyOptions:t})},r.fetchPixels=async function(e,t,i,n={}){e=b.snapExtent(e),n=this._getRequestOptionsWithSliceId(n);const{_hasNoneOrGCSShiftTransform:o}=this;if(n.requestRawData&&o)return this._fetchPixels(e,t,i,n);const r=b.getWorldWidth(e.spatialReference),s=b.getWorldWrapCount(e);if(null==r||0===s||1===s&&this._isGlobalWrappableSource&&o)return this._fetchPixels(e,t,i,n);if(s>=3)return{extent:e,pixelBlock:null};const l=[],{xmin:a,xmax:c}=e,u=Math.round(r/(c-a)*t),f=u-Math.round((r/2-a)/(c-a)*t);let h=0;const m=[];for(let y=0;y<=s;y++){const o=new P({xmin:0===y?a:-r/2,xmax:y===s?c-r*y:r/2,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference}),p=0===y?u-f:y===s?t-h:u;h+=p,m.push(p);const d=n.disableWrapAround&&y>0?null:this._fetchPixels(o,p,i,n);l.push(d)}const p=(await Promise.all(l)).map((e=>e?.pixelBlock));let d=null;const x={width:t,height:i};if(this.rasterJobHandler){d=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:x,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:m},n)).pixelBlock}else d=_.mosaic(p,x,{blockWidths:m});return{extent:e,srcExtent:b.projectExtent(e,this.rasterInfo.spatialReference,n.datumTransformation),pixelBlock:d}},r.fetchRawPixels=async function(e,t,i,n={}){t={x:Math.floor(t.x),y:Math.floor(t.y)};const o=await this._fetchRawTiles(e,t,i,n),{nativeExtent:r,nativePixelSize:s,storageInfo:l}=this.rasterInfo,a=2**e,c=s.x*a,u=s.y*a,f=new P({xmin:r.xmin+c*t.x,xmax:r.xmin+c*(t.x+i.width-1),ymin:r.ymax-u*(t.y+i.height-1),ymax:r.ymax-u*t.y,spatialReference:r.spatialReference});if(!o)return{extent:f,srcExtent:f,pixelBlock:null};const{pixelBlocks:h,mosaicSize:m}=o;if(1===h.length&&null!=h[0]&&h[0].width===i.width&&h[0].height===i.height)return{extent:f,srcExtent:f,pixelBlock:o.pixelBlocks[0]};const p=e>0?l.pyramidBlockWidth:l.blockWidth,d=e>0?l.pyramidBlockHeight:l.blockHeight,x={x:t.x%p,y:t.y%d};let y;if(this.rasterJobHandler){y=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:h,srcMosaicSize:m,destDimension:i,clipOffset:x,clipSize:i,coefs:null,sampleSpacing:null,interpolation:n.interpolation,alignmentInfo:null,blockWidths:null},n)).pixelBlock}else y=_.mosaic(h,m,{clipOffset:x,clipSize:i});return{extent:f,srcExtent:f,pixelBlock:y}},r.fetchRawTile=function(e,t,i,n){throw new o("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")},r.computeExtent=function(e){return b.projectExtent(this.rasterInfo.extent,e)},r.decodePixelBlock=function(e,t){return!this.rasterJobHandler||t.useCanvas?T.decode(e,t):this.rasterJobHandler.decode({data:e,options:t})},r.request=async function(e,t,i=0){const{customFetchParameters:o}=this.ioConfig,{range:r,query:s,headers:l}=t;i=i??t.retryCount??this.ioConfig.retryCount;const a=r?{Range:`bytes=${r.from}-${r.to}`}:null;try{return await n(e,{...t,query:{...s,...o},headers:{...l,...a}})}catch(c){if(i>0)return i--,this.request(e,t,i);throw c}},r.getSliceIndex=function(e){const{multidimensionalInfo:t}=this.rasterInfo;return null==t||null==e||0===e.length?null:S.getSliceIndex(e,t)},r.getTileExtentFromTileInfo=function(e,t,i,n){const o=l.unwrapOrThrow(n.lodAt(e));return this.getTileExtent({x:o.resolution,y:o.resolution},t,i,n.origin,n.spatialReference,n.size)},r.updateTileInfo=function(){const{storageInfo:e,spatialReference:t,extent:i,pixelSize:n}=this.rasterInfo;if(!e.tileInfo){const o=[],r=e.maximumPyramidLevel||0;let s=Math.max(n.x,n.y),l=1/.0254*96*s;for(let e=0;e<=r;e++)o.push(new g({level:r-e,resolution:s,scale:l})),s*=2,l*=2;const a=new B({x:i.xmin,y:i.ymax,spatialReference:t});e.tileInfo=new R({origin:a,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:o}),e.isVirtualTileInfo=!0}},r.createRemoteDatasetStorageInfo=function(e,t=512,i=512,n){const{width:o,height:r,nativeExtent:s,pixelSize:l,spatialReference:a}=e,c=new B({x:s.xmin,y:s.ymax,spatialReference:a});null==n&&(n=Math.max(0,Math.round(Math.log(Math.max(o,r))/Math.LN2-8)));const u=this.computeBlockBoundary(s,512,512,{x:s.xmin,y:s.ymax},[l],n);e.storageInfo=new I({blockWidth:t,blockHeight:i,pyramidBlockWidth:t,pyramidBlockHeight:i,origin:c,firstPyramidLevel:1,maximumPyramidLevel:n,blockBoundary:u})},r.computeBestPyramidLevelForLocation=async function(e,t={}){return 0},r.computeBlockBoundary=function(e,t,i,n,o,r=0,s=2){if(1===o.length&&r>0){o=[...o];let{x:e,y:t}=o[0];for(let i=0;i<r;i++)e*=s,t*=s,o.push({x:e,y:t})}const l=[],{x:a,y:c}=n;for(let u=0;u<o.length;u++){const{x:n,y:r}=o[u];l.push({minCol:Math.floor((e.xmin-a+.1*n)/t/n),maxCol:Math.floor((e.xmax-a-.1*n)/t/n),minRow:Math.floor((c-e.ymax+.1*r)/i/r),maxRow:Math.floor((c-e.ymin-.1*r)/i/r)})}return l},r.getPyramidPixelSize=function(e){const{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:i,pyramidScalingFactor:n}=this.rasterInfo.storageInfo;if(0===e)return t;if(null!=i&&i.length)return i[e-1];const o=n**e;return{x:t.x*o,y:t.y*o}},r.identifyPixelLocation=function(e,t,i,n){const{spatialReference:o,nativeExtent:r,storageInfo:s}=this.rasterInfo,{maximumPyramidLevel:l,origin:a,transposeInfo:c}=s,u=n&&null!=c?c.tileSize[0]:s.blockWidth,f=n&&null!=c?c.tileSize[1]:s.blockHeight,h=b.projectPoint(e,o,i);if(!r.intersects(h))return null;if(t<0||t>l)return null;const m=this.getPyramidPixelSize(t),{x:p,y:d}=m,x=(a.y-h.y)/d/f,y=(h.x-a.x)/p/u,g=Math.min(f-1,Math.floor((x-Math.floor(x))*f)),I=Math.min(u-1,Math.floor((y-Math.floor(y))*u));return{pyramidLevel:t,row:Math.floor(x),col:Math.floor(y),rowOffset:g,colOffset:I,blockWidth:u,srcLocation:h}},r.getTileExtent=function(e,t,i,n,o,r){const[s,l]=r,a=n.x+i*s*e.x,c=a+s*e.x,u=n.y-t*l*e.y,f=u-l*e.y;return new P({xmin:a,xmax:c,ymin:f,ymax:u,spatialReference:o})},r.getBlockWidthHeight=function(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}},r.isBlockOutside=function(e,t,i){const n=this.rasterInfo.storageInfo.blockBoundary[e];return!n||n.maxRow<t||n.maxCol<i||n.minRow>t||n.minCol>i},r._fetchPixels=async function(e,t,i,n={}){let o=b.getWorldWrapCount(e);if(o>=2)return{extent:e,pixelBlock:null};const r=this._getSourceDataInfo(e,t,i,n),{pyramidLevel:s,srcResolution:l,srcExtent:a,srcWidth:c,srcHeight:u,ul:f}=r;if(0===c||0===u)return{extent:e,srcExtent:a,pixelBlock:null};const{rasterInfo:h}=this,m=h.transform,p="gcs-shift"===m?.type,d=null!=b.getWorldWidth(e.spatialReference);!p&&d||(o=b.getWorldWrapCount(r.srcExtent,p));const x=await this._fetchRawTiles(s,f,{width:c,height:u,wrapCount:o},n);if(!x)return{extent:e,srcExtent:a,pixelBlock:null};const y=h.storageInfo,g=s>0?y.pyramidBlockWidth:y.blockWidth,I=s>0?y.pyramidBlockHeight:y.blockHeight;let{x:R,y:S}=h.pixelSize;if(s>0){const{pyramidResolutions:e,pyramidScalingFactor:t}=y;if(null!=e&&e[s-1])({x:R,y:S}=e[s-1]);else{const e=t**s;R*=e,S*=e}}const w=h.spatialReference,k=new B({x:R,y:S,spatialReference:w}),T=g===c&&I===u&&f.x%g==0&&f.y%I==0,P=new B({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference}),W=!e.spatialReference.equals(w),M=w.isGeographic?1e-9:1e-4,{datumTransformation:C}=n;if(!W&&T&&1===x.pixelBlocks.length&&g===t&&I===i&&this._isSameResolution(l,P,M))return{extent:e,srcExtent:a,srcTilePixelSize:k,pixelBlock:x.pixelBlocks[0]};const H=d&&null!=b.getWorldWidth(a.spatialReference)&&this._hasNoneOrGCSShiftTransform,E=n.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");E&&!this.rasterJobHandler&&await b.load();const L=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:x.extent,pixelSize:P.toJSON(),datumTransformation:C,rasterTransform:m,hasWrapAround:o>0||H,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:E},n):b.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:x.extent,pixelSize:P,datumTransformation:C,rasterTransform:m,hasWrapAround:o>0||H,isAdaptive:!1,includeGCSGrid:E});let z;const D=!n.requestRawData,O={rows:L.spacing[0],cols:L.spacing[1]},A=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(s,x.extent.xmin):void 0,{pixelBlocks:F,mosaicSize:G,isPartiallyFilled:N}=x;let q=null;if(this.rasterJobHandler){const e=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:F,srcMosaicSize:G,destDimension:D?{width:t,height:i}:null,coefs:D?L.coefficients:null,sampleSpacing:D?O:null,projectDirections:E,gcsGrid:E?L.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:n.interpolation,alignmentInfo:A,blockWidths:null},n);({pixelBlock:z,localNorthDirections:q}=e)}else{const e=_.mosaic(F,G,{alignmentInfo:A});z=D?_.approximateTransform(e,{width:t,height:i},L.coefficients,O,n.interpolation):e,E&&L.gcsGrid&&(q=_.getLocalArithmeticNorthRotations({width:t,height:i},L.gcsGrid),z=v.convertToLocalDirections(z,this.rasterInfo.dataType,q))}return n.requestRawData||E?{extent:e,srcExtent:a,srcTilePixelSize:k,pixelBlock:z,transformGrid:L,localNorthDirections:q,isPartiallyFilled:N}:{extent:e,srcExtent:a,srcTilePixelSize:k,pixelBlock:z}},r._fetchRawTiles=async function(e,t,i,n){const{origin:o,blockBoundary:r}=this.rasterInfo.storageInfo,{blockWidth:s,blockHeight:l}=this.getBlockWidthHeight(e);let{x:a,y:c}=t,{width:u,height:f,wrapCount:h}=i;const m=this._getRasterTileAlignmentInfo(e,0);n.buffer&&(a-=n.buffer.cols,c-=n.buffer.rows,u+=2*n.buffer.cols,f+=2*n.buffer.rows);let p=0,d=0,x=0;if(h&&null!=m){({worldColumnCountFromOrigin:d,originColumnOffset:x,rightPadding:p}=m);d*m.blockWidth-p>=a+u&&(p=0)}const y=Math.floor(a/s),g=Math.floor(c/l),I=Math.floor((a+u+p-1)/s),R=Math.floor((c+f+p-1)/l),S=r[e];if(!S)return null;const{minRow:w,minCol:k,maxCol:T,maxRow:_}=S;if(0===h&&(R<w||I<k||g>_||y>T))return null;const b=new Array;let v=!1;const B=null==this.ioConfig.allowPartialFill?n.allowPartialFill:this.ioConfig.allowPartialFill;for(let P=g;P<=R;P++)for(let t=y;t<=I;t++){let i=t;if(!n.disableWrapAround&&h&&null!=m&&d<=t&&(i=t-d-x),P>=w&&i>=k&&_>=P&&T>=i){const t=this._fetchRawTile(e,P,i,n);B?b.push(new Promise((e=>{t.then((t=>e(t))).catch((()=>{v=!0,e(null)}))}))):b.push(t)}else b.push(Promise.resolve(null))}if(0===b.length)return null;const W=await Promise.all(b),M={height:(R-g+1)*l,width:(I-y+1)*s},{spatialReference:C}=this.rasterInfo,H=this.getPyramidPixelSize(e),{x:E,y:L}=H;return{extent:new P({xmin:o.x+y*s*E,xmax:o.x+(I+1)*s*E,ymin:o.y-(R+1)*l*L,ymax:o.y-g*l*L,spatialReference:C}),pixelBlocks:W,mosaicSize:M,isPartiallyFilled:v}},r._isSameResolution=function(e,t,i){return Math.abs(e.x-t.x)<i&&Math.abs(e.y-t.y)<i},r._fetchRawTile=function(e,t,i,n){const o=this.rasterInfo.storageInfo.blockBoundary[e];if(!o)return Promise.resolve(null);const{minRow:r,minCol:s,maxCol:l,maxRow:a}=o;if(t<r||i<s||t>a||i>l)return Promise.resolve(null);const u=w.getRasterId(this.url,n.sliceId),f=`${e}/${t}/${i}`;let h=w.getBlock(u,n.registryId,f);if(null==h){const o=new AbortController;h=this.fetchRawTile(e,t,i,{...n,signal:o.signal}),w.putBlock(u,n.registryId,f,h,o),h.catch((()=>w.deleteBlock(u,n.registryId,f)))}return n.signal&&c.onAbort(n,(()=>{w.decreaseRefCount(u,n.registryId,f)})),h},r._computeMagDirValues=function(e){const{bandCount:t,dataType:i}=this.rasterInfo;if(!(2===t&&"vector-magdir"===i||"vector-uv"===i)||2!==e?.length||!e[0]?.length)return null;const n=e[0].length;if("vector-magdir"===i){const t=e[1].map((e=>(e+360)%360));return[e[0],t]}const[o,r]=e,s=[],l=[];for(let a=0;a<n;a++){const[e,t]=v.uvComponentToVector([o[a],r[a]]);s.push(e),l.push(t)}return[s,l]},r._getRasterTileAlignmentInfo=function(e,t){return null==this._rasterTileAlighmentInfo&&(this._rasterTileAlighmentInfo=b.getRasterDatasetAlignmentInfo(this.rasterInfo)),null==this._rasterTileAlighmentInfo.pyramidsInfo?null:{startX:t,halfWorldWidth:this._rasterTileAlighmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlighmentInfo.hasGCSSShiftTransform,...this._rasterTileAlighmentInfo.pyramidsInfo[e]}},r._getSourceDataInfo=function(e,t,i,n={}){const o={datumTransformation:n.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};n.srcResolution&&(o.srcResolution=n.srcResolution,this._updateSourceDataInfo(e,o));const r=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:s,srcHeight:l,pyramidLevel:a}=o,c=s/t,u=l/i,f=a<r&&c*u>=16,h=a===r&&this._requireTooManySrcTiles(s,l,t,i);if(f||h||(0===s||0===l)){const s=new B({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference});let l=b.projectResolution(s,this.rasterInfo.spatialReference,e,o.datumTransformation);const h=!l||n.srcResolution&&l.x+l.y<n.srcResolution.x+n.srcResolution.y;if(f&&n.srcResolution&&h){const e=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(r-a+3>=e){const t=2**e;l={x:n.srcResolution.x*t,y:n.srcResolution.y*t}}}l&&(o.srcResolution=l,this._updateSourceDataInfo(e,o))}return this._requireTooManySrcTiles(o.srcWidth,o.srcHeight,t,i)&&(o.srcWidth=0,o.srcHeight=0),o},r._requireTooManySrcTiles=function(e,t,i,n){const{tileInfo:o}=this.rasterInfo.storageInfo;return Math.ceil(e/o.size[0])*Math.ceil(t/o.size[1])>=M||e/i>W||t/n>W},r._updateSourceDataInfo=function(e,t){t.srcWidth=0,t.srcHeight=0;const{rasterInfo:i}=this,n=i.spatialReference,{srcResolution:o,datumTransformation:r}=t,{pyramidLevel:s,pyramidResolution:l,excessiveReading:a}=b.snapPyramid(o,i,this.ioConfig.sampling);if(a)return;let c=t.srcExtent||b.projectExtent(e,n,r);if(null==c)return;const u=i.transform;u&&(c=u.inverseTransform(c)),t.srcExtent=c;const{x:f,y:h}=i.storageInfo.origin,m=Math.floor((c.xmin-f)/l.x+.1),p=Math.floor((h-c.ymax)/l.y+.1),d=Math.floor((c.xmax-f)/l.x-.1),x=Math.floor((h-c.ymin)/l.y-.1),y=c.width<.1*l.x?0:d-m+1,g=c.height<.1*l.y?0:x-p+1;t.pyramidLevel=s,t.pyramidResolution=l,t.srcWidth=y,t.srcHeight=g,t.ul={x:m,y:p}},r._getRequestOptionsWithSliceId=function(e){return null!=this.rasterInfo.multidimensionalInfo&&null==e.sliceId&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)}),e},r._processIdentifyResult=function(e,t){const{srcLocation:i,position:n,pyramidLevel:o,useTransposedTile:r}=t,s=e.pixels[0].length/e.width/e.height;if(!(!e.mask||e.mask[n]))return{location:i,value:null};const{multidimensionalInfo:l}=this.rasterInfo;if(null==l||!r){const t=e.pixels.map((e=>e[n])),r={location:i,value:t,pyramidLevel:o},s=this._computeMagDirValues(t.map((e=>[e])));return s?.length&&(r.magdirValue=s.map((e=>e[0]))),r}let a=e.pixels.map((e=>e.slice(n*s,n*s+s))),c=this._computeMagDirValues(a);const{requestSomeSlices:u,identifyOptions:f}=t;let h=S.createSlices(l,f.transposedVariableName);if(u){const e=S.getSliceIds(h,f.multidimensionalDefinition,f.timeExtent);a=a.map((t=>e.map((e=>t[e])))),c=c?.map((t=>e.map((e=>t[e])))),h=e.map((e=>h[e]))}const m=e.noDataValues||this.rasterInfo.noDataValue,p={pixels:a,pixelType:e.pixelType};let d;null!=m&&(k.convertNoDataToMask(p,m),d=p.mask);return{location:i,value:null,dataSeries:h.map(((e,t)=>{const i={value:0===d?.[t]?null:a.map((e=>e[t])),multidimensionalDefinition:e.multidimensionalDefinition.map((e=>new y({...e,isSlice:!0})))};return c?.length&&(i.magdirValue=[c[0][t],c[1][t]]),i})),pyramidLevel:o}},e._createClass(i,[{key:"_isGlobalWrappableSource",get:function(){const{rasterInfo:e}=this,t=b.getWorldWidth(e.spatialReference);return null!=t&&e.extent.width>=t/2}},{key:"_hasNoneOrGCSShiftTransform",get:function(){const{transform:e}=this.rasterInfo;return null==e||"gcs-shift"===e.type}},{key:"rasterJobHandler",set:function(e){this._set("rasterJobHandler",e),"Function"===this.datasetFormat&&this.primaryRasters?.rasters?.forEach((t=>t.rasterJobHandler=e))}},{key:"url",set:function(e){this._set("url",d.sanitizeUrl(e,s.getLogger(this)))}}]),i}(a.EsriPromiseMixin(r.JSONSupport));t.__decorate([u.property()],C.prototype,"_rasterTileAlighmentInfo",void 0),t.__decorate([u.property({readOnly:!0})],C.prototype,"_isGlobalWrappableSource",null),t.__decorate([u.property({readOnly:!0})],C.prototype,"_hasNoneOrGCSShiftTransform",null),t.__decorate([u.property()],C.prototype,"rasterJobHandler",null),t.__decorate([u.property(x.url)],C.prototype,"url",null),t.__decorate([u.property({type:String,json:{write:!0}})],C.prototype,"datasetName",void 0),t.__decorate([u.property({type:String,json:{write:!0}})],C.prototype,"datasetFormat",void 0),t.__decorate([u.property()],C.prototype,"hasUniqueSourceStorageInfo",void 0),t.__decorate([u.property()],C.prototype,"rasterInfo",void 0),t.__decorate([u.property()],C.prototype,"ioConfig",void 0),t.__decorate([u.property()],C.prototype,"sourceJSON",void 0),C=t.__decorate([p.subclass("esri.layers.support.rasterDatasets.BaseRaster")],C);return C}));
