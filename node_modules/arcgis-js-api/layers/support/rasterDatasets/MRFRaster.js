/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["../../../chunks/_rollupPluginBabelHelpers","../../../chunks/tslib.es6","../../../geometry","../../../core/Error","../../../core/accessorSupport/decorators/property","../../../core/accessorSupport/ensureType","../../../core/arrayUtils","../../../core/has","../../../core/accessorSupport/decorators/subclass","../PixelBlock","../RasterInfo","../RasterStorageInfo","./BaseRaster","./pamParser","./xmlUtilities","../rasterFormats/utils","../rasterFunctions/stretchUtils","../../../geometry/SpatialReference","../../../geometry/Extent","../../../geometry/Point"],(function(e,t,r,s,n,a,i,o,l,c,f,u,h,p,g,m,d,y,x,w){"use strict";const b=new Map;b.set("Int8","s8"),b.set("UInt8","u8"),b.set("Int16","s16"),b.set("UInt16","u16"),b.set("Int32","s32"),b.set("UInt32","u32"),b.set("Float32","f32"),b.set("Float64","f32"),b.set("Double64","f32");const I=new Map;I.set("none",{blobExtension:".til",isOneSegment:!0,decoderFormat:"bip"}),I.set("lerc",{blobExtension:".lrc",isOneSegment:!1,decoderFormat:"lerc"}),I.set("deflate",{blobExtension:".pzp",isOneSegment:!0,decoderFormat:"deflate"}),I.set("jpeg",{blobExtension:".pjg",isOneSegment:!0,decoderFormat:"jpg"});let _=function(t){function r(){var e;return(e=t.apply(this,arguments)||this)._files=null,e._storageIndex=null,e.datasetFormat="MRF",e}e._inherits(r,t);var n=r.prototype;return n.open=async function(e){await this.init(),this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const t=e?e.signal:null,r=await this.request(this.url,{responseType:"xml",signal:t}),{rasterInfo:s,files:n}=this._parseHeader(r.data);if(-1===this.ioConfig.skipExtensions?.indexOf("aux.xml")){const t=await this._fetchAuxiliaryData(e);null!=t&&(s.statistics=t.statistics??s.statistics,s.histograms=t.histograms,t.histograms&&null==s.statistics&&(s.statistics=d.estimateStatisticsFromHistograms(t.histograms)))}this._set("rasterInfo",s),this._files=n;const a=await this.request(n.index,{responseType:"array-buffer",signal:t});this._storageIndex=this._parseIndex(a.data);const{blockWidth:i,blockHeight:o}=this.rasterInfo.storageInfo,l=this.rasterInfo.storageInfo.pyramidScalingFactor,{width:c,height:f}=this.rasterInfo,u=[],h=this._getBandSegmentCount();let p=0,g=-1;for(;p<this._storageIndex.length;){g++;const e=Math.ceil(c/i/l**g)-1,t=Math.ceil(f/o/l**g)-1;p+=(e+1)*(t+1)*h*4,u.push({maxRow:t,maxCol:e,minCol:0,minRow:0})}this.rasterInfo.storageInfo.blockBoundary=u,g>0&&(this.rasterInfo.storageInfo.firstPyramidLevel=1,this.rasterInfo.storageInfo.maximumPyramidLevel=g),this.updateTileInfo()},n.fetchRawTile=async function(e,t,r,s={}){const{blockWidth:n,blockHeight:a,blockBoundary:i}=this.rasterInfo.storageInfo,o=i[e];if(!o||o.maxRow<t||o.maxCol<r||o.minRow>t||o.minCol>r)return null;const{bandCount:l,pixelType:f}=this.rasterInfo,{ranges:u,actualTileWidth:h,actualTileHeight:p}=this._getTileLocation(e,t,r);if(!u||0===u.length)return null;if(0===u[0].from&&0===u[0].to){const e=new Uint8Array(n*a);return new c({width:n,height:a,pixels:null,mask:e,validPixelCount:0})}const{bandIds:g}=this.ioConfig,m=this._getBandSegmentCount(),d=[];let y=0;for(y=0;y<m;y++)g&&!g.includes(y)||d.push(this.request(this._files.data,{range:{from:u[y].from,to:u[y].to},responseType:"array-buffer",signal:s.signal}));const x=await Promise.all(d),w=x.map((e=>e.data.byteLength)).reduce(((e,t)=>e+t)),b=new Uint8Array(w);let _=0;for(y=0;y<m;y++)b.set(new Uint8Array(x[y].data),_),_+=x[y].data.byteLength;const A=I.get(this.rasterInfo.storageInfo.compression).decoderFormat,F=await this.decodePixelBlock(b.buffer,{width:n,height:a,format:A,planes:g?.length||l,pixelType:f});if(null==F)return null;let{noDataValue:R}=this.rasterInfo;if(null!=R&&"lerc"!==A&&!F.mask&&(R=R[0],null!=R)){const e=F.width*F.height,t=new Uint8Array(e);if(Math.abs(R)>1e24)for(y=0;y<e;y++)Math.abs((F.pixels[0][y]-R)/R)>1e-6&&(t[y]=1);else for(y=0;y<e;y++)F.pixels[0][y]!==R&&(t[y]=1);F.mask=t}let S=0,E=0;if(h!==n||p!==a){let e=F.mask;if(e)for(y=0;y<a;y++)if(E=y*n,y<p)for(S=h;S<n;S++)e[E+S]=0;else for(S=0;S<n;S++)e[E+S]=0;else for(e=new Uint8Array(n*a),F.mask=e,y=0;y<p;y++)for(E=y*n,S=0;S<h;S++)e[E+S]=1}return F},n._parseIndex=function(e){if(e.byteLength%16>0)throw new Error("invalid array buffer must be multiples of 16");let t,r,s,n,a,i;if(m.isPlatformLittleEndian){for(r=new Uint8Array(e),n=new ArrayBuffer(e.byteLength),s=new Uint8Array(n),a=0;a<e.byteLength/4;a++)for(i=0;i<4;i++)s[4*a+i]=r[4*a+3-i];t=new Uint32Array(n)}else t=new Uint32Array(e);return t},n._getBandSegmentCount=function(){return I.get(this.rasterInfo.storageInfo.compression).isOneSegment?1:this.rasterInfo.bandCount},n._getTileLocation=function(e,t,r){const{blockWidth:s,blockHeight:n,pyramidScalingFactor:a}=this.rasterInfo.storageInfo,{width:i,height:o}=this.rasterInfo,l=this._getBandSegmentCount();let c,f,u,h=0,p=0;for(u=0;u<e;u++)p=a**u,c=Math.ceil(i/s/p),f=Math.ceil(o/n/p),h+=c*f;p=a**e,c=Math.ceil(i/s/p),f=Math.ceil(o/n/p),h+=t*c+r,h*=4*l;const g=this._storageIndex.subarray(h,h+4*l);let m=0,d=0;const y=[];for(let x=0;x<l;x++)m=g[4*x]*2**32+g[4*x+1],d=m+g[4*x+2]*2**32+g[4*x+3],y.push({from:m,to:d});return{ranges:y,actualTileWidth:r<c-1?s:Math.ceil(i/p)-s*(c-1),actualTileHeight:t<f-1?n:Math.ceil(o/p)-n*(f-1)}},n._parseHeader=function(e){const t=g.getElement(e,"MRF_META/Raster");if(!t)throw new s("mrf:open","not a valid MRF format");const r=g.getElement(t,"Size"),n=parseInt(r.getAttribute("x"),10),a=parseInt(r.getAttribute("y"),10),i=parseInt(r.getAttribute("c"),10),o=(g.getElementValue(t,"Compression")||"none").toLowerCase();if(!I.has(o))throw new s("mrf:open","currently does not support compression "+o);const l=g.getElementValue(t,"DataType")||"UInt8",c=b.get(l);if(null==c)throw new s("mrf:open","currently does not support pixel type "+l);const h=g.getElement(t,"PageSize"),m=parseInt(h.getAttribute("x"),10),d=parseInt(h.getAttribute("y"),10),_=g.getElement(t,"DataValues");let A,F;_&&(F=_.getAttribute("NoData"),null!=F&&(A=F.trim().split(" ").map((e=>parseFloat(e)))));if(g.getElement(e,"MRF_META/CachedSource"))throw new s("mrf:open","currently does not support MRF referencing other data files");const R=g.getElement(e,"MRF_META/GeoTags"),S=g.getElement(R,"BoundingBox");let E,k=!1;if(null!=S){const e=parseFloat(S.getAttribute("minx")),t=parseFloat(S.getAttribute("miny")),r=parseFloat(S.getAttribute("maxx")),s=parseFloat(S.getAttribute("maxy")),n=g.getElementValue(R,"Projection")||"";let a=y.WGS84;if("LOCAL_CS[]"!==n)if(n.toLowerCase().startsWith("epsg:")){const e=Number(n.slice(5));isNaN(e)||0===e||(a=new y({wkid:e}))}else a=p.parseSpatialReference(n)??y.WGS84;else k=!0,a=new y({wkid:3857});E=new x(e,t,r,s),E.spatialReference=a}else k=!0,E=new x({xmin:-.5,ymin:.5-a,xmax:n-.5,ymax:.5,spatialReference:new y({wkid:3857})});const M=g.getElement(e,"MRF_META/Rsets"),T=parseInt(M&&M.getAttribute("scale")||"2",10),C=E.spatialReference,U=new u({origin:new w({x:E.xmin,y:E.ymax,spatialReference:C}),blockWidth:m,blockHeight:d,pyramidBlockWidth:m,pyramidBlockHeight:d,compression:o,pyramidScalingFactor:T}),B=new w({x:E.width/n,y:E.height/a,spatialReference:C}),L=new f({width:n,height:a,extent:E,isPseudoSpatialReference:k,spatialReference:C,bandCount:i,pixelType:c,pixelSize:B,noDataValue:A,storageInfo:U}),P=g.getElementValue(e,"datafile"),H=g.getElementValue(e,"IndexFile");return{rasterInfo:L,files:{mrf:this.url,index:H||this.url.replace(".mrf",".idx"),data:P||this.url.replace(".mrf",I.get(o).blobExtension)}}},n._fetchAuxiliaryData=async function(e){try{const{data:t}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:e?.signal});return p.parsePAMInfo(t)}catch{return null}},e._createClass(r)}(h);t.__decorate([n.property()],_.prototype,"_files",void 0),t.__decorate([n.property()],_.prototype,"_storageIndex",void 0),t.__decorate([n.property({type:String,json:{write:!0}})],_.prototype,"datasetFormat",void 0),_=t.__decorate([l.subclass("esri.layers.support.rasterIO.MRFRaster")],_);return _}));
