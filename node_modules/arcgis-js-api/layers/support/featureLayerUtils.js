/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["require","exports","../../kernel","../../symbols","../../core/Error","../../core/jsonMap","../../core/sql","../../core/accessorSupport/extensions/serializableProperty/reader","./layerUtils","../../renderers/SimpleRenderer","../../renderers/UniqueValueRenderer","../../rest/support/AttachmentQuery","../../rest/support/Query","../../rest/support/RelationshipQuery"],(function(e,t,r,n,a,s,o,i,u,c,l,d,p,y){"use strict";const f=new s.JSONMap({esriGeometryPoint:"point",esriGeometryMultipoint:"multipoint",esriGeometryPolyline:"polyline",esriGeometryPolygon:"polygon",esriGeometryMultiPatch:"multipatch"});async function h(e,t,r,n){const s=await L(e);if(await m(e,t,n),!s.addAttachment)throw new a(n,"Layer source does not support addAttachment capability");return s.addAttachment(t,r)}function m(e,t,r){const{attributes:n}=t,{objectIdField:s}=e;return e.get("capabilities.data.supportsAttachment")?t?n?s&&n[s]?Promise.resolve():Promise.reject(new a(r,`feature is missing the identifying attribute ${s}`)):Promise.reject(new a(r,"'attributes' are required on a feature to query attachments")):Promise.reject(new a(r,"A feature is required to add/delete/update attachments")):Promise.reject(new a(r,"this layer doesn't support attachments"))}async function w(e,t,r,n,s){const o=await L(e);if(await m(e,t,s),!o.updateAttachment)throw new a(s,"Layer source does not support updateAttachment capability");return o.updateAttachment(t,r,n)}async function b(t,r,n){const{applyEdits:a}=await new Promise(((t,r)=>e(["../graphics/editingSupport"],t,r))),s=await t.load();return a(s,s.source,r,n)}async function g(t,r,n){const{uploadAssets:a}=await new Promise(((t,r)=>e(["../graphics/editingSupport"],t,r))),s=await t.load();return a(s,s.source,r,n)}async function q(e,t,r,n){const s=await L(e);if(await m(e,t,n),!s.deleteAttachments)throw new a(n,"Layer source does not support deleteAttachments capability");return s.deleteAttachments(t,r)}async function F(e,t,r){const n=(await e.load({signal:t?.signal})).source;if(!n.fetchRecomputedExtents)throw new a(r,"Layer source does not support fetchUpdates capability");return n.fetchRecomputedExtents(t)}async function I(e,t,r,n){t=d.from(t),await e.load();const s=e.source,o=e.capabilities;if(!o?.data?.supportsAttachment)throw new a(n,"this layer doesn't support attachments");const{attachmentTypes:i,objectIds:u,globalIds:c,num:l,size:p,start:y,where:f}=t;if(!o?.operations?.supportsQueryAttachments){if(i?.length>0||c?.length>0||p?.length>0||l||y||f)throw new a(n,"when 'capabilities.operations.supportsQueryAttachments' is false, only objectIds is supported",t)}if(!(u?.length||c?.length||f))throw new a(n,"'objectIds', 'globalIds', or 'where' are required to perform attachment query",t);if(!s.queryAttachments)throw new a(n,"Layer source does not support queryAttachments capability",t);return s.queryAttachments(t)}async function P(e,t,r,n){const s=await L(e);if(!s.queryObjectIds)throw new a(n,"Layer source does not support queryObjectIds capability");return s.queryObjectIds(p.from(t)??e.createQuery(),r)}async function A(e,t,r,n){const s=await L(e);if(!s.queryFeatureCount)throw new a(n,"Layer source does not support queryFeatureCount capability");return s.queryFeatureCount(p.from(t)??e.createQuery(),r)}async function E(e,t,r,n){const s=await L(e);if(!s.queryExtent)throw new a(n,"Layer source does not support queryExtent capability");return s.queryExtent(p.from(t)??e.createQuery(),r)}async function O(e,t,r,n){const s=await L(e);if(!s.queryRelatedFeatures)throw new a(n,"Layer source does not support queryRelatedFeatures capability");return s.queryRelatedFeatures(y.from(t),r)}async function R(e,t,r,n){const s=await L(e);if(!s.queryRelatedFeaturesCount)throw new a(n,"Layer source does not support queryRelatedFeaturesCount capability");return s.queryRelatedFeaturesCount(y.from(t),r)}async function S(e){const t=e.source;if(t?.refresh)try{const{dataChanged:r,updates:n}=await t.refresh();if(null!=n&&(e.sourceJSON={...e.sourceJSON,...n},e.read(n,{origin:"service",url:e.parsedUrl})),r)return!0}catch{}if(e.definitionExpression)try{return(await o.parseWhereClause(e.definitionExpression,e.fieldsIndex)).hasDateFunctions}catch{}return!1}function j(e){const t=new p,r=e.get("capabilities.data"),n=e.get("capabilities.query");t.historicMoment=e.historicMoment,t.gdbVersion=e.gdbVersion,t.returnGeometry=!0,n&&(t.compactGeometryEnabled=n.supportsCompactGeometry,t.defaultSpatialReferenceEnabled=n.supportsDefaultSpatialReference),r&&(r.supportsZ&&null!=e.returnZ&&(t.returnZ=e.returnZ),r.supportsM&&null!=e.returnM&&(t.returnM=e.returnM)),t.outFields=["*"];const{timeOffset:a,timeExtent:s}=e;return t.timeExtent=null!=a&&null!=s?s.offset(-a.value,a.unit):s||null,t.multipatchOption="multipatch"===e.geometryType?"xyFootprint":null,t}function x(e){const{globalIdField:t,fields:r}=e;if(t)return t;if(r)for(const n of r)if("esriFieldTypeGlobalID"===n.type)return n.name}function C(e){const{objectIdField:t,fields:r}=e;if(t)return t;if(r)for(const n of r)if("esriFieldTypeOID"===n.type)return n.name}function M(e){return e.currentVersion?e.currentVersion:e.hasOwnProperty("capabilities")||e.hasOwnProperty("drawingInfo")||e.hasOwnProperty("hasAttachments")||e.hasOwnProperty("htmlPopupType")||e.hasOwnProperty("relationships")||e.hasOwnProperty("timeInfo")||e.hasOwnProperty("typeIdField")||e.hasOwnProperty("types")?10:9.3}async function L(e){return(await e.load()).source}async function G(e,t){if(!r.id)return;if(r.id.findCredential(e))return;let n;try{const a=await u.getOwningPortalUrl(e,t);a&&(n=await r.id.checkSignInStatus(`${a}/sharing`))}catch(a){}if(n)try{const n=null!=t?t.signal:null;await r.id.getCredential(e,{signal:n})}catch(a){}}async function v(e,t){const r=e.parsedUrl?.path;r&&Q(e)&&await G(r,t)}function Q(e){const t=e.editFieldsInfo;return!(!t?.creatorField&&!t?.editorField)||(e.userHasUpdateItemPrivileges?e.hasUpdateItemRestrictions:!!e.userHasFullEditingPrivileges&&e.hasFullEditingRestrictions)}function T(e){return!e.sourceJSON?.isMultiServicesView&&(e.userHasUpdateItemPrivileges||e.editingEnabled)}const U=i.createTypeReader({types:n.symbolTypesRenderer});function V(e,t){if(e.defaultSymbol)return e.types&&e.types.length?new l({defaultSymbol:U(e.defaultSymbol,e,t),field:e.typeIdField,uniqueValueInfos:e.types.map((e=>({id:e.id,symbol:U(e.symbol,e,t)})))}):new c({symbol:U(e.defaultSymbol,e,t)})}t.addAttachment=h,t.applyEdits=b,t.computeEffectiveEditingEnabled=T,t.createDefaultRenderer=V,t.createQuery=j,t.deleteAttachments=q,t.ensureLayerCredential=v,t.fetchRecomputedExtents=F,t.geometryTypeKebabDict=f,t.hasDataChanged=S,t.queryAttachments=I,t.queryExtent=E,t.queryFeatureCount=A,t.queryObjectIds=P,t.queryRelatedFeatures=O,t.queryRelatedFeaturesCount=R,t.readGlobalIdField=x,t.readObjectIdField=C,t.readVersion=M,t.updateAttachment=w,t.uploadAssets=g,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
