/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["../../chunks/_rollupPluginBabelHelpers","../../core/Error","../../core/workers/workers","./PixelBlock"],(function(e,r,o,n){"use strict";return function(){function t(){this._workerThread=null,this._destroyed=!1}var i=t.prototype;return i.initialize=async function(){const e=await o.open("RasterWorker");this._destroyed?e.close():this._workerThread=e},i.destroy=function(){this._destroyed=!0,this._workerThread&&(this._workerThread.close(),this._workerThread=null)},i.convertVectorFieldData=async function(e,o){if(!this._workerThread)throw new r("raster-jobhandler:no-connection","no available worker connection");const t=await this._workerThread.invoke("convertVectorFieldData",{pixelBlock:e.pixelBlock.toJSON(),type:e.dataType},o);return t?new n(t):null},i.computeStatisticsHistograms=function(e,o){if(!this._workerThread)throw new r("raster-jobhandler:no-connection","no available worker connection");return this._workerThread.invoke("computeStatisticsHistograms",{pixelBlock:e.pixelBlock.toJSON()},o)},i.decode=async function(e,o){if(!this._workerThread)throw new r("raster-jobhandler:no-connection","no available worker connection");const t=await this._workerThread.invoke("decode",e,o);return t?new n(t):null},i.symbolize=async function(e,o){if(!this._workerThread)throw new r("raster-jobhandler:no-connection","no available worker connection");const t={extent:e.extent&&e.extent.toJSON(),pixelBlock:null!=e.pixelBlock&&e.pixelBlock.toJSON(),simpleStretchParams:e.simpleStretchParams,bandIds:e.bandIds},i=await this._workerThread.invoke("symbolize",t,o);return i?new n(i):null},i.updateSymbolizer=async function(e,o){if(!this._workerThread)throw new r("raster-jobhandler:no-connection","no available worker connection");const n=e?.rendererJSON?.histograms;await Promise.all(this._workerThread.broadcast("updateSymbolizer",{symbolizerJSON:e.toJSON(),histograms:n},o))},i.updateRasterFunction=async function(e,o){if(!this._workerThread)throw new r("raster-jobhandler:no-connection","no available worker connection");await Promise.all(this._workerThread.broadcast("updateRasterFunction",{rasterFunctionJSON:e.toJSON()},o))},i.process=async function(e,o){if(!this._workerThread)throw new r("raster-jobhandler:no-connection","no available worker connection");const t=await this._workerThread.invoke("process",{extent:e.extent?.toJSON(),primaryPixelSizes:e.primaryPixelSizes?.map((e=>null!=e?e.toJSON():null)),primaryPixelBlocks:e.primaryPixelBlocks.map((e=>null!=e?e.toJSON():null)),primaryRasterIds:e.primaryRasterIds},o);return t?new n(t):null},i.stretch=async function(e,o){if(!this._workerThread)throw new r("raster-jobhandler:no-connection","no available worker connection");if(!e?.pixelBlock)return null;const t={srcPixelBlock:e.pixelBlock.toJSON(),stretchParams:e.stretchParams},i=await this._workerThread.invoke("stretch",t,o);return i?new n(i):null},i.split=async function(e,o){if(!this._workerThread)throw new r("raster-jobhandler:no-connection","no available worker connection");if(!e?.pixelBlock)return null;const t={srcPixelBlock:e.pixelBlock.toJSON(),tileSize:e.tileSize,maximumPyramidLevel:e.maximumPyramidLevel},i=await this._workerThread.invoke("split",t,o);return i&&i.forEach(((e,r)=>{i.set(r,e?n.fromJSON(e):null)})),i},i.estimateStatisticsHistograms=async function(e,o){if(!this._workerThread)throw new r("raster-jobhandler:no-connection","no available worker connection");if(!e?.pixelBlock)return null;const n={srcPixelBlock:e.pixelBlock.toJSON()};return await this._workerThread.invoke("estimateStatisticsHistograms",n,o)},i.mosaicAndTransform=async function(e,o){if(!this._workerThread)throw new r("raster-jobhandler:no-connection","no available worker connection");if(!e?.srcPixelBlocks?.length)return{pixelBlock:null};const t={...e,srcPixelBlocks:e.srcPixelBlocks.map((e=>null!=e?e.toJSON():null))},i=await this._workerThread.invoke("mosaicAndTransform",t,o);return{pixelBlock:i.pixelBlock?new n(i.pixelBlock):null,localNorthDirections:i.localNorthDirections}},i.createFlowMesh=async function(e,o){if(!this._workerThread)throw new r("raster-jobhandler:no-connection","no available worker connection");const n={buffer:e.flowData.data.buffer,maskBuffer:e.flowData.mask.buffer,width:e.flowData.width,height:e.flowData.height},{meshType:t,simulationSettings:i}=e,a=await this._workerThread.invoke("createFlowMesh",{meshType:t,flowData:n,simulationSettings:i},{...o,transferList:[n.buffer,n.maskBuffer]});return{vertexData:new Float32Array(a.vertexBuffer),indexData:new Uint32Array(a.indexBuffer)}},i.getProjectionOffsetGrid=function(e,o){if(!this._workerThread)throw new r("raster-jobhandler:no-connection","no available worker connection");const n=null!=e.datumTransformation?e.datumTransformation.steps.map((e=>({wkid:e.wkid,wkt:e.wkt,isInverse:e.isInverse}))):null,t=null!=e.rasterTransform?e.rasterTransform.toJSON():null,i={projectedExtent:e.projectedExtent.toJSON(),srcBufferExtent:e.srcBufferExtent.toJSON(),pixelSize:e.pixelSize,hasWrapAround:e.hasWrapAround,spacing:e.spacing,datumTransformationSteps:n,rasterTransform:t,isAdaptive:e.isAdaptive,includeGCSGrid:e.includeGCSGrid};return this._workerThread.invoke("getProjectionOffsetGrid",i,o)},e._createClass(t)}()}));
