/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["../../../../chunks/_rollupPluginBabelHelpers","../../../../chunks/tslib.es6","../../../../geometry","../../../../core/accessorSupport/decorators/property","../../../../core/accessorSupport/ensureType","../../../../core/arrayUtils","../../../../core/has","../../../../core/accessorSupport/decorators/subclass","../../../../layers/support/rasterFunctions/stretchUtils","../../../../rest/support/ImageHistogramParameters","./RasterLayerAdapter","../../../../geometry/Point"],(function(t,e,s,r,a,i,o,n,c,l,u,h){"use strict";let p=function(e){function s(){var t;return(t=e.apply(this,arguments)||this)._cacheSize=20,t._statsCache=new Map,t}t._inherits(s,e);var r=s.prototype;return r.generateRasterInfo=function(t){const e=t?.rasterFunction;try{return this.layer.generateRasterInfo(e,{signal:t?.signal})}catch{return Promise.resolve(this.layer.serviceRasterInfo)}},r.estimateStatisticsHistograms=async function(t){const e=t?.rasterFunction?.functionName??"default";if(this._statsCache.has(e))return this._statsCache.get(e);let{width:s,height:r,pixelSize:a}=this.layer.rasterInfo,i=1;for(;s>2e3||r>2e3;)s/=2,r/=2,i*=2;const o=t?.rasterFunction??this.layer.rasterFunction,{fullExtent:n,mosaicRule:u}=this.layer;a=new h(a.x*i,a.y*i,n.spatialReference);const p=new l({geometry:n,pixelSize:a,renderingRule:o,mosaicRule:u});let y;if(this.layer.capabilities.operations.supportsComputeStatisticsHistograms)y=await this.layer.computeStatisticsHistograms(p,t);else{const{histograms:e}=await this.layer.computeHistograms(p,t);y={statistics:c.estimateStatisticsFromHistograms(e),histograms:e}}if(this._statsCache.set(e,y),this._statsCache.size>this._cacheSize){const t=this._statsCache.keys().next().value;this._statsCache.delete(t)}return y},r.supportsMultidirectionalHillshade=function(){return this.layer.version>=10.81},r.load=function(t){return this.addResolvingPromise(this.layer.load(t).then((()=>{this.generateRasterInfo({rasterFunction:this.rasterFunction,signal:t?.signal}).then((t=>this.rasterInfo=t))}))),Promise.resolve(this)},t._createClass(s)}(u);e.__decorate([r.property()],p.prototype,"layer",void 0),p=e.__decorate([n.subclass("esri.smartMapping.support.adapters.ImageryLayerAdapter")],p);return p}));
