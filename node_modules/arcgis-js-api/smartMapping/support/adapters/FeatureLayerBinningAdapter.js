/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["../../../chunks/_rollupPluginBabelHelpers","../../../chunks/tslib.es6","../../../core/arrayUtils","../../../core/Error","../../../core/promiseUtils","../../../core/Logger","../../../core/accessorSupport/ensureType","../../../core/has","../../../core/accessorSupport/decorators/subclass","../../../layers/support/fieldType","../../../layers/support/fieldUtils","../../statistics/support/predominanceUtils","../../statistics/support/statsWorker","../../statistics/support/utils","../../statistics/support/WorkerClient","../utils","./FeatureLayerAdapter","./support/utils"],(function(e,t,a,i,r,s,n,o,l,u,m,p,g,d,c,y,f,h){"use strict";let w=function(t){function s(){var e;return(e=t.apply(this,arguments)||this).adapterName="feature-layer-binning-adapter",e}e._inherits(s,t);var n=s.prototype;return n._getNormalizationTotalFromMemory=async function(e,t,a){const{featuresJSON:r,graphics:s,layerView:n,query:o}=t,l=(!r&&!s&&n&&"queryAggregateSummaryStatistics"in n?await n.queryAggregateSummaryStatistics(o,{field:e},{signal:a}):r?await this.workerClient.summaryStatistics({field:e},r):await g.summaryStatistics({attribute:{field:e},features:s})).sum;if(null==l)throw new i(`${this.adapterName}:invalid`,"invalid normalizationTotal");return l},n._processStatsFromMemoryParams=async function(e){const{features:t,filter:a}=e;if(t?.length)return this._getFilteredFeatures(t,a);const{view:r,field:s,field2:n,field3:o,normalizationField:l,valueExpression:u,returnGeometry:m,layerViewFunc:p,signal:g}=e;let d=null,c=null,f=null,w=null,F=null;if(r)try{if(d=await r.whenLayerView(this.layer),c=null!=p&&p in d&&"function"==typeof d[p],c){await this._waitForLayerViewUpdate(d);const e=await y.getFieldsList({field:s,field2:n,field3:o,normalizationField:l,valueExpression:u});h.getMissingFieldsForBinning(this,e).length?c=!1:(f="createAggregateQuery"in d?d.createAggregateQuery():null,f?(f.outFields=e,f.returnGeometry=!1,h.updateQueryWithFeatureFilter(f,a)):c=!1),d.suspended&&(c=!1)}}catch{c=!1}if(!c&&(F=h.getFeatureReductionFields(this.layer).map((e=>e.toJSON())),w=await this._fetchFeaturesForStats({field:s,field2:n,field3:o,valueExpression:u,normalizationField:l,returnGeometry:m,filter:a,view:r,signal:g},"json"),!w?.length))throw new i(`${this.adapterName}:insufficient-data`,"No features are available to calculate statistics");return{layerView:d,query:f,featuresJSON:w,fieldInfos:F}},n._summaryStatsFromMemory=async function(e,t){const{view:a,field:i,valueExpression:r,normalizationType:s,signal:n}=e,o={field:i,valueExpression:r,normalizationType:s,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue},{featuresJSON:l,graphics:m,layerView:p,query:d,fieldInfos:c}=await this._processStatsFromMemoryParams({...e,layerViewFunc:"queryAggregateSummaryStatistics"});return r&&a&&(l||m)&&(o.fieldType=t?.type?u.kebabDict.toJSON(t.type):null,o.viewInfoParams=h.getViewInfoParams(a),o.fieldInfos=c),"percent-of-total"===s&&null==e.normalizationTotal&&(o.normalizationTotal=await this._getNormalizationTotalFromMemory(i,{featuresJSON:l,graphics:m,layerView:p,query:d},n)),!l&&!m&&p&&"queryAggregateSummaryStatistics"in p?p.queryAggregateSummaryStatistics(d,o,{signal:n}):l?this.workerClient.summaryStatistics(o,l):g.summaryStatistics({attribute:o,features:m})},n._uvFromMemory=async function(e,t){const{view:a,field:i,valueExpression:r,returnAllCodedValues:s,signal:n}=e,{featuresJSON:o,graphics:l,layerView:u,query:m,fieldInfos:p}=await this._processStatsFromMemoryParams({...e,layerViewFunc:"queryAggregateUniqueValues"}),d={field:i,field2:e.field2,field3:e.field3,fieldDelimiter:y.FIELD_DELIMITER,valueExpression:r,domains:t,returnAllCodedValues:s};return r&&a&&(o||l)&&(d.viewInfoParams=h.getViewInfoParams(a),d.fieldInfos=p),!o&&!l&&u&&"queryAggregateUniqueValues"in u?u.queryAggregateUniqueValues(m,d,{signal:n}):o?this.workerClient.uniqueValues(d,o):g.uniqueValues({attribute:d,features:l})},n._histogramFromMemory=async function(e){const{view:t,field:a,valueExpression:i,signal:r}=e,{featuresJSON:s,graphics:n,layerView:o,query:l,fieldInfos:u}=await this._processStatsFromMemoryParams({...e,layerViewFunc:"queryAggregateHistogram"}),m={field:a,valueExpression:i,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numBins:e.numBins};return i&&t&&(s||n)&&(m.viewInfoParams=h.getViewInfoParams(t),m.fieldInfos=u),"percent-of-total"===e.normalizationType&&null==e.normalizationTotal&&(m.normalizationTotal=await this._getNormalizationTotalFromMemory(a,{featuresJSON:s,graphics:n,layerView:o,query:l},r)),!s&&!n&&o&&"queryAggregateHistogram"in o?o.queryAggregateHistogram(l,m,{signal:r}):s?this.workerClient.histogram(m,s):g.histogram({attribute:m,features:n})},n._classBreaksFromMemory=async function(e){const{view:t,field:a,valueExpression:i,signal:r}=e,{featuresJSON:s,graphics:n,layerView:o,query:l,fieldInfos:u}=await this._processStatsFromMemoryParams({...e,layerViewFunc:"queryAggregateClassBreaks"}),m={field:a,valueExpression:i,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numClasses:e.numClasses};return i&&t&&(s||n)&&(m.viewInfoParams=h.getViewInfoParams(t),m.fieldInfos=u),"percent-of-total"===e.normalizationType&&null==e.normalizationTotal&&(m.normalizationTotal=await this._getNormalizationTotalFromMemory(a,{featuresJSON:s,graphics:n,layerView:o,query:l},r)),!s&&!n&&o&&"queryAggregateClassBreaks"in o?o.queryAggregateClassBreaks(l,m,{signal:r}):s?this.workerClient.classBreaks(m,s):g.classBreaks({attribute:m,features:n})},n.getField=function(e=""){const t=h.getFeatureReductionFields(this.layer);return t?.find((t=>t.name.toLowerCase()===e?.toLowerCase()))},n.getFieldUsageInfo=function(e){return this.getField(e)?{supportsLabelingInfo:!0,supportsRenderer:!0,supportsPopupTemplate:!0,supportsLayerQuery:!1,supportsStatistics:!0}:null},n.getFieldDomain=function(e,t){return null},n.summaryStatistics=async function(e){const{field:t}=e,a=t?this.getField(t):null,r=m.isDateField(a),s=e.sqlExpression&&!e.valueExpression&&!t;if(r||s)throw new i(`${this.adapterName}:not-supported`,"Date field and sqlExpression are not supported");return this._summaryStatsFromMemory(e,a)},n.uniqueValues=async function(e){const t=await h.getDomainsForFields(e,this);return this._uvFromMemory(e,t)},n.histogram=async function(e){const{field:t}=e,a=t?this.getField(t):null,r=m.isDateField(a),s=e.sqlExpression&&!e.valueExpression&&!t;if(r||s)throw new i(`${this.adapterName}:not-supported`,"Date field and sqlExpression are not supported");return this._histogramFromMemory(e)},n.classBreaks=async function(e){return(!1!==e.analyzeData?this._classBreaksFromMemory(e):this._classBreaksFromInterpolation(e)).catch((()=>(r.throwIfAborted(e.signal),this._classBreaksFromMemory(e))))},n.queryFeatureCount=async function(e){const t=await(e.view?.whenLayerView(this.layer));if(!t||!("queryAggregateCount"in t)||!t.queryAggregateCount)throw new i(`${this.adapterName}:not-supported`,"LayerView is not supported.");await this._waitForLayerViewUpdate(t);const a=t.createAggregateQuery();return a.where=d.mergeWhereClauses(a.where,e.whereClause),h.updateQueryWithFeatureFilter(a,e.filter),t.queryAggregateCount(a,{signal:e.signal})},n.generateRenderer=function(e,t){throw new i(`${this.adapterName}:not-supported`,"'generateRenderer' is not supported.")},n.heatmapStatistics=function(e){throw new i(`${this.adapterName}:not-supported`,"'heatmapStatistics' is not supported.")},n.predominantCategories=async function(e){const{fields:t,view:a,signal:i}=e,r=p.getArcadeForPredominantCategory(t),s=await this._uvFromMemory({valueExpression:r,view:a,signal:i});return h.getPredominantCategoriesFromUVInfos(s.uniqueValueInfos,t)},n.getSampleFeatures=async function(e,t){const{view:r,sampleSize:s,requiredFields:n,returnGeometry:o,filter:l,signal:u}=e;if(!r)throw new i(`${this.adapterName}:not-supported`,"'view' is required to get sample features for binning.");if("3d"===r.type)throw new i(`${this.adapterName}:not-supported`,"3d 'view' is not supported to get sample features for binning.");const m=await r.whenLayerView(this.layer);if(!("queryAggregateJSON"in m&&m.queryAggregateJSON&&"queryAggregates"in m&&m.queryAggregates))throw new i(`${this.adapterName}:not-supported`,"LayerView is not supported.");await this._waitForLayerViewUpdate(m);if(h.getMissingFieldsForBinning(this,n).length)throw new i(`${this.adapterName}:insufficient-data`,"Layer does not have required fields");const p=1,g="json"===t,d=m.createAggregateQuery();d.outSpatialReference=e.spatialReference||r&&r.spatialReference,d.returnGeometry=!!o,d.outFields=n,h.updateQueryWithFeatureFilter(d,l);const{features:c}=g?await m.queryAggregateJSON(d,{signal:u}):await m.queryAggregates(d,{signal:u});return c.length&&null!=s&&s>0&&s<=c.length?a.pickRandom(c,s,p):c},n.load=function(e){const t=this.layer.load(e).then((async t=>{if(this.geometryType="polygon",this.objectIdField=null,this.supportsSQLExpression=!1,this._hasLocalSource=!1,this.hasQueryEngine=!0,this.minScale=t.minScale,this.maxScale=t.maxScale,this.fullExtent=t.fullExtent,"geometryType"in t&&"point"!==t.geometryType)throw new i(`${this.adapterName}:invalid-parameters`,"Only 'point' geometry type is supported");const a="featureReduction"in t?t.featureReduction:null;if("binning"!==a?.type&&"cluster"!==a?.type)throw new i(`${this.adapterName}:invalid-parameters`,`Feature reduction type ${a?.type} is not supported`);this.workerClient=c.WorkerClient.getInstance(),await this.workerClient.open(e.signal)}));return this.addResolvingPromise(t),Promise.resolve(this)},e._createClass(s)}(f);w=t.__decorate([l.subclass("esri.smartMapping.support.adapters.FeatureLayerBinningAdapter")],w);return w}));
