/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
define(["exports","../../chunks/_rollupPluginBabelHelpers","../../Color","../../request","../../core/Error","../../core/has","../../core/Logger","../../core/LRUCache","../../core/promiseUtils","../../core/string","../../core/Version","../../layers/support/FieldsIndex","../../support/arcadeOnDemand","../../symbols/CIMSymbol"],(function(e,t,i,s,o,n,r,l,a,c,u,h,f,y){"use strict";const m="esri.renderers.support.DictionaryLoader",d={type:"CIMSimpleLineCallout",lineSymbol:{type:"CIMLineSymbol",symbolLayers:[{type:"CIMSolidStroke",width:.5,color:[0,0,0,255]}]}};let p=function(){function e(e,t,i){this.config=null,this.fieldMap=null,this.url=null,this._ongoingRequests=new Map,this._symbolCache=new l.LRUCache(100),this._dictionaryVersion=null,this._fieldIndex=null,this._dictionaryPromise=null,this.url=e,this.config=t,this.fieldMap=i}var n=e.prototype;return n.getSymbolFields=function(){return this._symbolFields},n.getSymbolAsync=async function(e,t){let s;this._dictionaryPromise||(this._dictionaryPromise=this.fetchResources(t));try{s=await this._dictionaryPromise}catch(p){if(a.isAbortError(p))return this._dictionaryPromise=null,null}const o=this._dictionaryVersion&&this._dictionaryVersion.since(4,0),n={};if(this.fieldMap)for(const i of this._symbolFields){const t=this._getFieldName(this.fieldMap[i]);n[i]=t?o?e.attributes[t]:""+e.attributes[t]:""}let r=null;try{r=s?.(n,t)}catch(g){return null}if(!r||"string"!=typeof r)return null;const l=c.numericHash(r).toString(),u=this._symbolCache.get(l);if(u)return u.catch((()=>{this._symbolCache.pop(l)})),u;const h=r.split(";"),f=[],y=[];for(const a of h)if(a)if(a.includes("po:")){const e=a.substr(3).split("|");if(3===e.length){const t=e[0],s=e[1];let o=e[2];if("DashTemplate"===s)o=o.split(" ").map((e=>Number(e)));else if("Color"===s){const e=new i(o).toRgba();o=[e[0],e[1],e[2],255*e[3]]}else o=Number(o);y.push({primitiveName:t,propertyName:s,value:o})}}else if(a.includes("|")){for(const e of a.split("|"))if(this._itemNames.has(e)){f.push(e);break}}else this._itemNames.has(a)&&f.push(a);const m=null==e.geometry||!e.geometry.hasZ&&"point"===e.geometry.type,d=this._cimPartsToCIMSymbol(f,y,m,t);return this._symbolCache.put(l,d,1),d},n.fetchResources=async function(e){if(this._dictionaryPromise)return this._dictionaryPromise;if(!this.url)return void r.getLogger(m).error("no valid URL!");const t=s(this.url+"/resources/styles/dictionary-info.json",{responseType:"json",query:{f:"json"},signal:null!=e?e.signal:null}),[{data:i}]=await Promise.all([t,f.loadArcade()]);if(!i)throw this._dictionaryPromise=null,new o("esri.renderers.DictionaryRenderer","Bad dictionary data!");const{authoringInfo:n,dictionary_version:l,expression:a,itemsNames:c}=i,y=a;let d=!1;l&&(this._dictionaryVersion=u.Version.parse(l),d=this._dictionaryVersion.since(4,0)),this._refSymbolUrlTemplate=this.url+"/"+i.cimRefTemplateUrl,this._itemNames=new Set(c),this._symbolFields=n.symbol;const p={};if(this.config){const e=this.config;for(const t in e)p[t]=e[t]}if(n.configuration)for(const s of n.configuration)p.hasOwnProperty(s.name)||(p[s.name]=s.value);const g=[];if(null!=e&&e.fields&&this.fieldMap)for(const s of this._symbolFields){const t=this.fieldMap[s],i=e.fields.filter((e=>e.name.toLowerCase()===t?.toLowerCase()));i.length>0&&g.push({...i[0],type:d?i[0].type:"esriFieldTypeString"})}g.length>0&&(this._fieldIndex=new h(g));const b=f.createDictionaryExpression(y,null!=e?e.spatialReference:null,g,p).then((e=>{const t={scale:0};return(i,s)=>{if(null==e)return null;const o=e.repurposeFeature({geometry:null,attributes:i});return t.scale=null!=s?s.scale??void 0:void 0,e.evaluate({$feature:o,$view:t},e.services)}})).catch((e=>(r.getLogger(m).error("Creating dictinoary expression failed:",e),null)));return this._dictionaryPromise=b,b},n._cimPartsToCIMSymbol=async function(e,t,i,s){const o=new Array(e.length);for(let l=0;l<e.length;l++)o[l]=this._getSymbolPart(e[l],s);const n=await Promise.all(o),r=this.fieldMap;if(r)for(const l of n)g(l,r);return new y({data:this._combineSymbolParts(n,t,i)})},n._getSymbolPart=async function(e,t){if(this._ongoingRequests.has(e))return this._ongoingRequests.get(e).then((e=>e.data));const i=this._refSymbolUrlTemplate.replaceAll(/\{itemName\}/gi,e),o=s(i,{responseType:"json",query:{f:"json"},...t});this._ongoingRequests.set(e,o);try{return(await o).data}catch(n){throw this._ongoingRequests.delete(e),n}},n._combineSymbolParts=function(e,t,i){if(!e||0===e.length)return null;const s={...e[0]};if(e.length>1){s.symbolLayers=[];for(const t of e){const e=t;s.symbolLayers.unshift(...e.symbolLayers)}}return i&&(s.callout=d),{type:"CIMSymbolReference",symbol:s,primitiveOverrides:t}},n._getFieldName=function(e){if(null!==this._fieldIndex){const t=this._fieldIndex.get(e);return t?t.name:e}return e},t._createClass(e)}();function g(e,t){if(!e)return;const i=e.symbolLayers;if(!i)return;let s=i.length;for(;s--;){const e=i[s];if(e&&!1!==e.enable&&"CIMVectorMarker"===e.type)b(e,t)}}function b(e,t){const i=e.markerGraphics;if(i)for(const s of i){if(!s)continue;const e=s.symbol;if(e)switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":g(e,t);break;case"CIMTextSymbol":e.fieldMap=t}}}e.DictionaryLoader=p,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
